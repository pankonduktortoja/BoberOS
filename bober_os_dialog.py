# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BoberOSDialog
 Plugin base generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-12-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Bartosz Łęczycki
        email                : bartosz.leczycki98@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import time

from qgis.core import *
from qgis.core import QgsVectorLayer, QgsProject, QgsFeatureRequest, QgsVectorFileWriter, QgsGeometry, QgsCoordinateTransformContext
from qgis.PyQt import *
from qgis.PyQt import uic
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtWidgets import QMessageBox, QDialog, QColorDialog
from PyQt5.QtWidgets import QTableWidgetItem, QInputDialog, QMessageBox
from PyQt5.QtCore import Qt
import sqlite3
from qgis.gui import *
from datetime import datetime
from qgis.utils import iface



FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'bober_os_dialog_base.ui'))


class BoberOSDialog(QtWidgets.QDialog, FORM_CLASS):
    BDOT_LAYERS = {
        "OT_SWRS": "BDOT_siec_wod_rzeka_strumien",
        "OT_SWKN": "BDOT_siec_wod_kanal",
        "OT_SWRM": "BDOT_siec_wod_row_melioracyjny",

        "OT_SKJZ": "BDOT_siec_kom_jezdnia",
        "OT_SKDR": "BDOT_siec_kom_droga",
        "OT_SKRW": "BDOT_siec_kom_rondo_wezel",
        "OT_SKRP": "BDOT_siec_kom_ciag_pieszy_rower",
        "OT_SKTR": "BDOT_siec_kom_tory",
        "OT_SKPP": "BDOT_siec_kom_przeprawy",

        "OT_SULN": "BDOT_infra_linia_elektro",
        "OT_SUPR": "BDOT_infra_przewod_rurowy",

        "OT_PTWP": "BDOT_pokrycie_woda",
        "OT_PTZB": "BDOT_pokrycie_zabudowa",
        "OT_PTLZ": "BDOT_pokrycie_las_zadrzewienie",
        "OT_PTRK": "BDOT_pokrycie_rosl_krzewiasta",
        "OT_PTUT": "BDOT_pokrycie_uprawa_trwala",
        "OT_PTTR": "BDOT_pokrycie_rosl_trawiasta_upr_rolna",
        "OT_PTKM": "BDOT_pokrycie_teren_komunikacji",
        "OT_PTGN": "BDOT_pokrycie_grunt_nieuzytkowany",
        "OT_PTPL": "BDOT_pokrycie_plac",
        "OT_PTSO": "BDOT_pokrycie_skladowisko_odpadow",
        "OT_PTWZ": "BDOT_pokrycie_wyrobiska",
        "OT_PTNZ": "BDOT_pokrycie_inny_teren_niezab",

        "OT_BUBD": "BDOT_bud_budynek",
        "OT_BUIN": "BDOT_bud_budowla_inzynierska",
        "OT_BUHD": "BDOT_bud_budowla_hydrotechniczna",
        "OT_BUSP": "BDOT_bud_budowla_sportowa",
        "OT_BUWT": "BDOT_bud_wysoka_budowla_techniczna",
        "OT_BUZT": "BDOT_bud_zbiornik_techniczny",
        "OT_BUUO": "BDOT_bud_umocnienia",
        "OT_BUZM": "BDOT_bud_budowle_ziemne",
        "OT_BUTR": "BDOT_bud_urzadzenia_transportowe",
        "OT_BUIT": "BDOT_bud_inne_urzadzenia_techniczne",
        "OT_BUIB": "BDOT_bud_inne_budowle",

        "OT_ADMS": "BDOT_adm_miejscowosc",

        "OT_OIPR": "BDOT_inne_obiekt_przyr",
        "OT_OIKM": "BDOT_inne_obiekt_komunikacja",
        "OT_OIOR": "BDOT_inne_obiekt_orientacyjny",
        "OT_OIMK": "BDOT_inne_mokradlo",
        "OT_OISZ": "BDOT_inne_szuwary",
    }    
    
    def __init__(self, parent=None):
        if parent is None:
            parent = iface.mainWindow()
        super(BoberOSDialog, self).__init__(parent)
        self.iface = iface
        self.setupUi(self)
        self.init_ui_color_customization()
        
        self.setWindowFlags(Qt.Window | Qt.WindowMinMaxButtonsHint | Qt.WindowCloseButtonHint)
        
        for btn in self.findChildren(QtWidgets.QPushButton):
            btn.setDefault(False)
            btn.setAutoDefault(False)
        
        self.pbClearConsole.clicked.connect(self.run_clear_console)

        self.project_path.setStorageMode(QgsFileWidget.GetFile)
        self.project_path.setFilter("GeoPackage files (*.gpkg)")
        
        self.project_path.fileChanged.connect(lambda path: self.save_setting("project_path", path))
        saved_path = self.load_setting("project_path")
        if saved_path:
            self.project_path.setFilePath(saved_path)
                
        self.layer_area.currentIndexChanged.connect(self.update_label_layer_area)
        
        saved_buffer = self.load_setting("buffer_value")
        if saved_buffer:
            self.sbBufferValue.setValue(int(saved_buffer))
        self.sbBufferValue.valueChanged.connect(self.update_buffer_value)
        self.update_buffer_value(self.sbBufferValue.value())
        
        self.layer_area.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.layer_area.setCurrentIndex(-1)
        
        self.resource_path.setStorageMode(QgsFileWidget.GetDirectory)
        self.resource_path.setFilePath("")

        self.resource_path.fileChanged.connect(lambda path: self.save_setting("resource_path", path))
        saved_resource = self.load_setting("resource_path")
        if saved_resource:
            self.resource_path.setFilePath(saved_resource)
        
        self.pb_act_fop.clicked.connect(self.act_fop_layers)
        self.pb_act_pomniki.clicked.connect(self.act_pomniki_layers)
        self.pb_act_pig.clicked.connect(self.act_pig_layers)
        self.pb_act_adm.clicked.connect(self.act_adm_layers)
        self.pb_act_oze.clicked.connect(self.act_oze_layers)
        self.fop_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.fop_path.setFilter("Shapefile (*.shp)")
        self.pomniki_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.pomniki_path.setFilter("GPKG (*.gpkg)")
        self.pig_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.pig_path.setFilter("Shapefile (*.shp)")
        self.adm_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.adm_path.setFilter("GML file (*.gml)")
        self.oze_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.oze_path.setFilter("GPKG file (*.gpkg)")
        
        button_configs = {
            self.pb_import_fop: {"": ["DANE_AKTUALIZOWANE", "FOP"]},
            self.pb_import_pig: {"": ["DANE_AKTUALIZOWANE", "PIG"]},
            self.pb_import_um: {"ADM_MorskieLinieBrzegowe.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"],
                "ADM_MorskieWodyWewnetrzne.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"],
                "ADM_PasOchronny.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"],
                "ADM_PasTechniczny.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_obreb: {"ADM_ObrebyEwidencyjne.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_gmina: {"ADM_Gminy.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_powiat: {"ADM_Powiaty.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_wojewodztwo: {"ADM_Wojewodztwa.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_nadlesnictwo: {"ADM_Nadlesnictwa.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_zz: {"ADM_ZarzadyZlewni.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_oze: {"": ["DANE_AKTUALIZOWANE", "OZE"]},
            self.pb_import_jcwpd: {"WODY_JCWPd.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_gzwp: {"WODY_GZWP.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwprz: {"WODY_Zlewnie_JCWP_rzeczne.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwpj: {"WODY_Zlewnie_JCWP_jeziorne.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwpprzej: {"WODY_Zlewnie_JCWP_przejsciowe.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwpprzyb: {"WODY_Zlewnie_JCWP_przybrzezne.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwpzbior: {"WODY_Zlewnie_JCWP_zbiornikowe.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwppozos: {"WODY_JCWP_pozostale.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_powodz_rzeka10: {"POWODZ_rzeka_10.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_rzeka100: {"POWODZ_rzeka_100.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_rzeka500: {"POWODZ_rzeka_500.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_rzekaWZ: {"POWODZ_rzeka_WZ.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_morze100: {"POWODZ_morze_100.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_morze500: {"POWODZ_morze_500.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_morzeWZ: {"POWODZ_morze_WZ.gpkg": ["DANE_POWODZ"]},
            self.pb_import_skorowidze: {"INNE_Skorowidz50k_92.gpkg": ["DANE_INNE"]},
            self.pb_import_fizgeo: {"INNE_Mezoregiony.gpkg": ["DANE_INNE"]},
            self.pb_import_roslinnosc: {"INNE_Potencjalna_roslinnosc_naturalna.gpkg": ["DANE_INNE"]},
            self.pb_import_reg_klim: {"INNE_Wos_1999_regiony_klimatyczne.gpkg": ["DANE_INNE"]},
            self.pb_import_pkp_halas_ldwn: {"INNE_PKP_halas_imisja_LDWN.gpkg": ["DANE_INNE"]},
            self.pb_import_pkp_halas_ln: {"INNE_PKP_halas_imisja_LN.gpkg": ["DANE_INNE"]},
            self.pb_import_torfowiska_alk: {"INNE_Torfowiska_alkaliczne.gpkg": ["DANE_INNE"]},
            self.pb_import_korytarze: {"INNE_Korytarze_ekologiczne.gpkg": ["DANE_INNE"]},
        }

        for btn, config in button_configs.items():
            btn.clicked.connect(lambda _, c=config: self.import_filtered_layers(c))

        self.pb_import_act_all.clicked.connect(self.import_all_updated_data)
        self.pb_import_wody_all.clicked.connect(self.import_all_wody_data)
        self.pb_import_powodz_all.clicked.connect(self.import_all_powodz_data)
        self.pb_layout_area.clicked.connect(self.layout_area_gen)
        self.pb_pog_numeracja.clicked.connect(self.pog_numeracja)
        self.pb_pog_profil.clicked.connect(self.pog_korekta_profilu)
        self.pb_pog_spacje.clicked.connect(self.pog_korekta_spacje)
        self.pb_style_save_single.clicked.connect(self.style_save_single)
        self.pb_style_save_all.clicked.connect(self.style_save_all)
        self.pb_reset_fid_values.clicked.connect(self.reset_fid_values)
        self.pb_numeracja_pol.clicked.connect(self.numeracja_pol)
        self.pb_numeracja_unikalna.clicked.connect(self.numeracja_unikalna)
        self.pb_import_external.clicked.connect(self.import_external)
        self.pb_anal_fop.clicked.connect(self.anal_fop)
        self.pb_anal_adm.clicked.connect(self.anal_adm)
        self.pb_anal_pig.clicked.connect(self.anal_pig)
        self.pb_anal_wody.clicked.connect(self.anal_wody)
        self.pb_anal_powodz.clicked.connect(self.anal_powodz)
        self.pb_anal_inne.clicked.connect(self.anal_inne)
        self.pb_anal_oze.clicked.connect(self.anal_oze)
        self.pb_anal_fop_10km.clicked.connect(self.anal_fop_10km)
        
        
        
        self.pb_gpkg_load_layers.clicked.connect(self.load_layers)
        self.pb_gpkg_delete_layers.clicked.connect(self.delete_selected_layers)
        self.pb_gpkg_rename_layers.clicked.connect(self.rename_selected_layer)
        self.pb_gpkg_vacuum_layers.clicked.connect(self.vacuum_gpkg)
        
        self.pb_bdot_refresh.clicked.connect(self.populate_bdot_table)
        self.pb_bdot_import.clicked.connect(self.import_selected_bdot_layers)
        self.pb_bdot_uncheck.clicked.connect(self.uncheck_all_bdot)
       
  
    def save_setting(self, key: str, value: str):
        settings = QSettings()
        settings.setValue(f"bober_os/settings/{key}", value)
        if key == "project_path":
            self.tbConsole.append(f"Zapisano ścieżkę do paczki projektu: {value}")
        if key == "resource_path":
            self.tbConsole.append(f"Zapisano ścieżkę do zasobu danych: {value}")
        elif key == "buffer_value":
            self.tbConsole.append(f"Zapisano wartość buforu: {value} m")

    def load_setting(self, key: str) -> str:
        settings = QSettings()
        return settings.value(f"bober_os/settings/{key}", "")

    def update_buffer_value(self, value):
        self.save_setting("buffer_value", str(value))
        if value == 0:
            self.labelBuffer.setText("Brak buforu")
        else:
            self.labelBuffer.setText(f"Wybrany bufor: {value} m")
    
    def update_label_layer_area(self):
        layer = self.layer_area.currentLayer()
        if layer:
            self.labelLayerArea.setText(f"Wybrana warstwa: {layer.name()}")
        else:
            self.labelLayerArea.setText("Brak wybranej warstwy")
    
    def init_ui_color_customization(self):
        self._ui_color_settings_key = "bober_os/settings/ui_bg_color"
        self._ui_color_default = "rgb(231, 255, 241)"
        self._base_stylesheet = self.styleSheet()
        settings = QSettings()
        color = settings.value(self._ui_color_settings_key, self._ui_color_default)
        self.apply_ui_bg_color(color)

        self.pbUiColor.clicked.connect(self.open_ui_color_slider)

    def apply_ui_bg_color(self, color_str: str):
        self.setStyleSheet(
            self._base_stylesheet +
            f"""
            QWidget {{
                background-color: {color_str};
            }}
            """
        )

    def open_ui_color_slider(self):
        dlg = QColorDialog(self)
        dlg.setOption(QColorDialog.DontUseNativeDialog, True)
        dlg.setOption(QColorDialog.ShowAlphaChannel, False)
        dlg.setWindowTitle("Wybierz kolor tła")

        if dlg.exec() != QColorDialog.Accepted:
            return

        color = dlg.currentColor()
        if not color.isValid():
            return

        color_str = f"rgb({color.red()}, {color.green()}, {color.blue()})"

        self.apply_ui_bg_color(color_str)
        QSettings().setValue(self._ui_color_settings_key, color_str)

        if hasattr(self, "tbConsole"):
            self.tbConsole.append(f"Ustawiono kolor tła: {color_str}")

    def layer_area_2180(self) -> QgsVectorLayer | None:
        src_layer = self.layer_area.currentLayer()
        if not src_layer:
            return None

        target_crs = QgsCoordinateReferenceSystem("EPSG:2180")
        if hasattr(self, "_layer_area_2180_cache"):
            cached_id, cached_layer = self._layer_area_2180_cache
            if cached_id == src_layer.id():
                return cached_layer
        if src_layer.crs() == target_crs:
            self._layer_area_2180_cache = (src_layer.id(), src_layer)
            return src_layer

        context = QgsProject.instance().transformContext()
        transform = QgsCoordinateTransform(
            src_layer.crs(),
            target_crs,
            context
        )

        mem_layer = QgsVectorLayer(
            f"{QgsWkbTypes.displayString(src_layer.wkbType())}?crs=EPSG:2180",
            f"{src_layer.name()}_2180",
            "memory"
        )

        provider = mem_layer.dataProvider()
        provider.addAttributes(src_layer.fields())
        mem_layer.updateFields()

        feats = []
        for f in src_layer.getFeatures():
            geom = f.geometry()
            if geom and not geom.isEmpty():
                geom = QgsGeometry(geom)
                geom.transform(transform)

                nf = QgsFeature(mem_layer.fields())
                nf.setAttributes(f.attributes())
                nf.setGeometry(geom)
                feats.append(nf)

        if not feats:
            return None

        provider.addFeatures(feats)
        mem_layer.updateExtents()
        self._layer_area_2180_cache = (src_layer.id(), mem_layer)

        return mem_layer

    def run_clear_console(self):
        self.tbConsole.setText("")
        self.progressBar.reset()   
    
    def process_vector_files(
        self,
        input_paths: list,
        match_rules: dict,
        fields_per_rule: dict,
        encoding: str = "CP1250",
        target_crs: str = "EPSG:2180",
        subfolder=""):
        if isinstance(input_paths, str):
            input_paths = [input_paths]

        resource_base = self.resource_path.filePath()
        if not resource_base:
            self.tbConsole.append("Brak ścieżki zasobu (resource_path).")
            return

        if isinstance(subfolder, list):
            resource_dir = os.path.join(resource_base, *subfolder)
        else:
            resource_dir = os.path.join(resource_base, subfolder)
        os.makedirs(resource_dir, exist_ok=True)

        total = len(input_paths)
        if total == 0:
            self.tbConsole.append("Nie wybrano żadnych plików wejściowych.")
            return

        self.progressBar.setValue(0)

        for i, path in enumerate(input_paths):
            base = os.path.basename(path)

            gpkg_name = None
            matched_pattern = None
            for pattern, target in match_rules.items():
                p = pattern.replace("%", "")
                if pattern.startswith("%") and pattern.endswith("%"):
                    if p in base:
                        gpkg_name = target
                        break
                elif pattern.startswith("%"):
                    if base.endswith(p):
                        gpkg_name = target
                        break
                elif pattern.endswith("%"):
                    if base.startswith(p):
                        gpkg_name = target
                        break
                else:
                    if base == p:
                        gpkg_name = target
                        break

            if gpkg_name is None:
                self.tbConsole.append(f"Brak reguły dopasowania dla: {base}\n")
                continue

            fields_to_delete = fields_per_rule.get(matched_pattern, [])

            gpkg_path = os.path.normpath(os.path.join(resource_dir, gpkg_name))
            os.makedirs(os.path.dirname(gpkg_path), exist_ok=True)

            self.tbConsole.append(f"Przetwarzanie pliku: {base}")
            self.tbConsole.append(f"Docelowy GPKG: {gpkg_path}")

            layer = QgsVectorLayer(path, "input", "ogr")
            if not layer.isValid():
                self.tbConsole.append(f"Nie można wczytać warstwy: {base}\n")
                continue

            layer.setProviderEncoding(encoding)
            layer.dataProvider().setEncoding(encoding)

            layer.setCrs(QgsCoordinateReferenceSystem(target_crs))

            provider = layer.dataProvider()
            existing = provider.fields().names()
            delete_list = [f for f in fields_to_delete if f in existing]
            if delete_list:
                idxs = [provider.fieldNameIndex(f) for f in delete_list]
                provider.deleteAttributes(idxs)
                layer.updateFields()
                self.tbConsole.append(f"Usunięto pola: {', '.join(delete_list)}")
            else:
                self.tbConsole.append("Brak pól do usunięcia.")

            if os.path.exists(gpkg_path):
                try:
                    os.remove(gpkg_path)
                    self.tbConsole.append(f"Usunięto istniejący plik: {gpkg_path}")
                except Exception as e:
                    self.tbConsole.append(f"Nie udało się usunąć GPKG:\n{e}\n")
                    continue

            import re
            layer_name = re.sub(r'[^a-zA-Z0-9_]', '_', os.path.splitext(base)[0])
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "GPKG"
            options.encoding = encoding
            options.layerName = layer_name
            options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteFile

            error = QgsVectorFileWriter.writeAsVectorFormatV2(
                layer,
                gpkg_path,
                QgsProject.instance().transformContext(),
                options
            )

            if os.path.exists(gpkg_path):
                mod_time = time.ctime(os.path.getmtime(gpkg_path))
                self.tbConsole.append(f"Zapis GPKG zakończony pomyślnie. Data ostatniej modyfikacji: {mod_time}")
            else:
                self.tbConsole.append(f"Błąd zapisu GPKG: {error}")

            pct = int(((i + 1) / total) * 100)
            self.progressBar.setValue(pct)

            self.tbConsole.append("Operacja zakończona.\n")
 
    def act_fop_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.fop_path.filePath())

        match_rules = {
            "ParkiKrajobrazowe%": "FOP_ParkiKrajobrazowe.gpkg",
            "ParkiNarodowe%": "FOP_ParkiNarodowe.gpkg",
            "Rezerwaty%": "FOP_Rezerwaty.gpkg",
            "ObszaryChronionegoKrajobrazu%": "FOP_ObszaryChronionegoKrajobrazu.gpkg",
            "ObszarySpecjalnejOchrony%": "FOP_ObszarySpecjalnejOchrony.gpkg",
            "SpecjalneObszaryOchrony%": "FOP_SpecjalneObszaryOchrony.gpkg",
            "StanowiskaDokumentacyjne%": "FOP_StanowiskaDokumentacyjne.gpkg",
            "UzytkiEkologiczne%": "FOP_UzytkiEkologiczne.gpkg",
            "ZespolyPrzyrodniczoKrajobrazowe%": "FOP_ZespolyPrzyrodniczoKrajobrazowe.gpkg"
        }

        fields_per_rule = {k: ["gid", "kodinspire"] for k in match_rules.keys()}

        self.process_vector_files(
            input_paths=shp_list,
            match_rules=match_rules,
            fields_per_rule=fields_per_rule,
            encoding="CP1250",
            target_crs="EPSG:2180",
            subfolder=["DANE_AKTUALIZOWANE", "FOP"]
        )
    
    def act_pomniki_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.pomniki_path.filePath())

        match_rules = {
            "PomnikiPrzyrodyPunktowe%": "FOP_PomnikiPrzyrody_punktowe.gpkg",
            "PomnikiPrzyrodyPowierzchniowe%": "FOP_PomnikiPrzyrody_powierzchniowe.gpkg",
        }

        fields_per_rule = {k: ["gid", "kodinspire"] for k in match_rules.keys()}

        self.process_vector_files(
            input_paths=shp_list,
            match_rules=match_rules,
            fields_per_rule=fields_per_rule,
            encoding="UTF-8",
            target_crs="EPSG:2180",
            subfolder=["DANE_AKTUALIZOWANE", "FOP"]
        )        

    def act_pig_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.pig_path.filePath())

        match_rules = {
            "cbdg_midas_zloza%": "PIG_UdokumentowaneZloza.gpkg",
            "cbdg_midas_tereny%": "PIG_TerenyGornicze.gpkg",
            "cbdg_midas_obszary%": "PIG_ObszaryGornicze.gpkg",
        }

        fields_per_rule = {
            "cbdg_midas_zloza%": ["UKL_WSP", "KOPALINA_A", "SHAPE_AREA", "SHAPE_LEN"],
            "cbdg_midas_tereny%": ["ID_KONTURU", "STATUS", "STATUS_EN", "KOMENTARZ",
                                    "UKLAD_WSP", "ARK_MAP_50", "SHAPE_AREA", "SHAPE_LEN"],
            "cbdg_midas_obszary%": ["ID_KONTURU", "STATUS", "STATUS_EN", "KOMENTARZ",
                                    "UKLAD_WSP", "ARK_MAP_50", "SHAPE_AREA", "SHAPE_LEN"],
        }

        self.process_vector_files(
            input_paths=shp_list,
            match_rules=match_rules,
            fields_per_rule=fields_per_rule,
            encoding="UTF-8",
            target_crs="EPSG:2180",
            subfolder=["DANE_AKTUALIZOWANE", "PIG"]
        )

    def act_oze_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.oze_path.filePath())

        match_rules = {
            "elektrownie wiatrowe%": "OZE_elektrownie_wiatrowe.gpkg",
            "fotowoltaika%": "OZE_fotowoltaika.gpkg",
            "biogazownie%": "OZE_biogazownie.gpkg",
        }

        fields_per_rule = {
            "elektrownie wiatrowe%": ["organ"],
            "fotowoltaika%": ["powierzchnia zabudowy [ha]", "powierzchnia zabudowy 2 [ha]", "RDOŚ"],
            "biogazownie%": ["RDOŚ"],
        }

        self.process_vector_files(
            input_paths=shp_list,
            match_rules=match_rules,
            fields_per_rule=fields_per_rule,
            encoding="UTF-8",
            target_crs="EPSG:2180",
            subfolder=["DANE_AKTUALIZOWANE", "OZE"]
        )        

    def act_adm_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.adm_path.filePath())

        match_rules = {
            "%Pas_ochronny%": "ADM_PasOchronny.gpkg",
            "%Pas_techniczny%": "ADM_PasTechniczny.gpkg",
            "%Morskie_linie_brzegowe%": "ADM_MorskieLinieBrzegowe.gpkg",
            "%Morskie_wody_wewnetrzne%": "ADM_MorskieWodyWewnetrzne.gpkg",
            "%Nadlesnictwo%": "ADM_Nadlesnictwa.gpkg",
            "%Zarzad_zlewni_PGWWP%": "ADM_ZarzadyZlewni.gpkg",
            "%Granice_wojewodztw%": "ADM_Wojewodztwa.gpkg",
            "%Granice_powiatow%": "ADM_Powiaty.gpkg",
            "%Granice_gmin%": "ADM_Gminy.gpkg",
            "%Granice_obrebow_ewidencyjnych%": "ADM_ObrebyEwidencyjne.gpkg",
        }

        fields_per_rule = {
            "%Pas_ochronny%": [
                "gml_id", "DOCUMENT_I", "COASTAL_ZO", "TERYT_NO", "COASTAL_Z0",
                "FULL_NAME", "SHORT_NAME", "DESCRIPTIO", "COMMENTS", "NOTES",
                "SYS_NODE_C", "SYS_VERSIO", "SYS_VERSI0", "SYS_DATE_A", "SYS_DATA_A",
                "SYS_DATA_E", "SYS_UUID", "IIP_PRZEST"
            ],
            "%Pas_techniczny%": [
                "gml_id", "DOCUMENT_I", "COASTAL_ZO", "TERYT_NO", "COASTAL_Z0",
                "FULL_NAME", "SHORT_NAME", "DESCRIPTIO", "COMMENTS", "NOTES",
                "SYS_NODE_C", "SYS_VERSIO", "SYS_VERSI0", "SYS_DATE_A", "SYS_DATA_A",
                "SYS_DATA_E", "SYS_UUID", "IIP_PRZEST"
            ],
            "%W06_Morskie_linie_brzegowe%": [
                "gml_id", "DOCUMENT_I", "COASTAL_ZO", "TERYT_NO", "COASTAL_Z0",
                "FULL_NAME", "SHORT_NAME", "DESCRIPTIO", "COMMENTS", "NOTES",
                "SYS_NODE_C", "SYS_VERSIO", "SYS_VERSI0", "SYS_DATE_A", "SYS_DATA_A",
                "SYS_DATA_E", "SYS_UUID", "IIP_PRZEST"
            ],
            "%Morskie_wody_wewnetrzne%": [
                "gml_id", "FID", "ID", "SHORT_NAME", "AREA", "WERSJA_OD", "IIP_PRZEST"
            ],
            "%Zarzad_zlewni_PGWWP%": [
                "gml_id", "RZGW_KOD", "REGON"
            ],
            "%Nadlesnictwo%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_ORGAN_", "JPT_JOR_ID",
                "WERSJA_OD", "WERSJA_DO", "WAZNY_OD", "WAZNY_DO", "JPT_KOD__1",
                "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "ID_BUFORA_", "ID_BUFORA1",
                "ID_TECHNIC", "IIP_PRZEST", "IIP_IDENTY", "IIP_WERSJA", "JPT_KJ_IIP",
                "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_OPIS", "JPT_SPS_KO", "ID_BUFOR_1",
                "JPT_ID", "JPT_POWI_1", "JPT_KJ_I_3", "JPT_GEOMET", "JPT_GEOM_1",
                "SHAPE_LENG", "SHAPE_AREA", "REGON", "JPT_POWIER"
            ],
            "%Granice_obrebow_ewidencyjnych%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_POWIER", "JPT_ORGAN_",
                "JPT_KOD__1", "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "IIP_PRZEST",
                "IIP_IDENTY", "JPT_KJ_IIP", "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_SPS_KO",
                "JPT_POWI_1", "JPT_KJ_I_3", "JPT_JOR_ID", "WERSJA_OD", "WERSJA_DO",
                "WAZNY_OD", "WAZNY_DO", "IIP_WERSJA", "JPT_OPIS", "JPT_ID",
                "SHAPE_LENG", "SHAPE_AREA"
            ],
            "%Granice_gmin%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_POWIER", "JPT_ORGAN_",
                "JPT_KOD__1", "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "IIP_PRZEST",
                "IIP_IDENTY", "JPT_KJ_IIP", "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_SPS_KO",
                "JPT_POWI_1", "JPT_KJ_I_3", "JPT_JOR_ID", "WERSJA_OD", "WERSJA_DO",
                "WAZNY_OD", "WAZNY_DO", "IIP_WERSJA", "JPT_OPIS", "JPT_ID", "REGON",
                "SHAPE_LENG", "SHAPE_AREA"
            ],
            "%Granice_powiatow%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_POWIER", "JPT_ORGAN_",
                "JPT_KOD__1", "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "IIP_PRZEST",
                "IIP_IDENTY", "JPT_KJ_IIP", "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_SPS_KO",
                "JPT_POWI_1", "JPT_KJ_I_3", "JPT_JOR_ID", "WERSJA_OD", "WERSJA_DO",
                "WAZNY_OD", "WAZNY_DO", "IIP_WERSJA", "JPT_OPIS", "JPT_ID", "REGON",
                "SHAPE_LENG", "SHAPE_AREA"
            ],
            "%Granice_wojewodztw%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_POWIER", "JPT_ORGAN_",
                "JPT_KOD__1", "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "IIP_PRZEST",
                "IIP_IDENTY", "JPT_KJ_IIP", "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_SPS_KO",
                "JPT_POWI_1", "JPT_KJ_I_3", "JPT_JOR_ID", "WERSJA_OD", "WERSJA_DO",
                "WAZNY_OD", "WAZNY_DO", "IIP_WERSJA", "JPT_OPIS", "JPT_ID", "REGON",
                "SHAPE_LENG", "SHAPE_AREA"
            ]
        }

        resource_base = self.resource_path.filePath()
        if not resource_base:
            self.tbConsole.append("Brak ścieżki zasobu (resource_path).")
            QtWidgets.QApplication.processEvents()
            return

        resource_dir = os.path.join(resource_base, "DANE_AKTUALIZOWANE", "ADMINISTRACYJNE")
        os.makedirs(resource_dir, exist_ok=True)

        total = len(shp_list)
        for i, gml_path in enumerate(shp_list):
            base = os.path.basename(gml_path)

            gpkg_name = None
            matched_pattern = None
            for pattern, target in match_rules.items():
                p = pattern.replace("%", "")
                if pattern.startswith("%") and pattern.endswith("%") and p in base:
                    gpkg_name = target
                    matched_pattern = pattern
                    break
                elif pattern.startswith("%") and base.endswith(p):
                    gpkg_name = target
                    matched_pattern = pattern
                    break
                elif pattern.endswith("%") and base.startswith(p):
                    gpkg_name = target
                    matched_pattern = pattern
                    break
                elif base == p:
                    gpkg_name = target
                    matched_pattern = pattern
                    break

            if not gpkg_name:
                self.tbConsole.append(f"Brak reguły dopasowania dla: {base}\n")
                QtWidgets.QApplication.processEvents()
                continue

            gpkg_path = os.path.join(resource_dir, gpkg_name)
            layer_name_in_gpkg = os.path.splitext(gpkg_name)[0]

            self.tbConsole.append(f"Przetwarzanie pliku: {base}")
            QtWidgets.QApplication.processEvents()
            self.tbConsole.append(f"Docelowy GPKG: {gpkg_path}")
            QtWidgets.QApplication.processEvents()

            if os.path.exists(gpkg_path):
                try:
                    os.remove(gpkg_path)
                    self.tbConsole.append(f"Usunięto istniejący plik: {gpkg_path}")
                    QtWidgets.QApplication.processEvents()
                except Exception as e:
                    self.tbConsole.append(f"Nie udało się usunąć GPKG:\n{e}\n")
                    QtWidgets.QApplication.processEvents()
                    continue

            layer = QgsVectorLayer(gml_path, "input", "ogr")
            if not layer.isValid():
                self.tbConsole.append(f"Nie można wczytać warstwy: {base}\n")
                QtWidgets.QApplication.processEvents()
                continue

            fields_to_delete = fields_per_rule.get(matched_pattern, [])
            all_fields = layer.fields().names()
            fields_to_keep = [f for f in all_fields if f not in fields_to_delete]

            geom_type = layer.wkbType()
            crs = layer.crs()
            mem_layer = QgsVectorLayer(f"{QgsWkbTypes.displayString(geom_type)}?crs={crs.authid()}", layer_name_in_gpkg, "memory")
            mem_provider = mem_layer.dataProvider()
            mem_provider.addAttributes([layer.fields()[layer.fields().indexFromName(f)] for f in fields_to_keep])
            mem_layer.updateFields()

            feats = []
            for feat in layer.getFeatures():
                new_feat = QgsFeature(mem_layer.fields())
                for f in fields_to_keep:
                    new_feat[f] = feat[f]
                new_feat.setGeometry(feat.geometry())
                feats.append(new_feat)
            mem_provider.addFeatures(feats)
            mem_layer.updateExtents()

            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "GPKG"
            options.layerName = layer_name_in_gpkg
            options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteFile
            options.encoding = "UTF-8"

            error = QgsVectorFileWriter.writeAsVectorFormatV2(
                mem_layer,
                gpkg_path,
                QgsProject.instance().transformContext(),
                options
            )

            if error[0] != QgsVectorFileWriter.NoError:
                self.tbConsole.append(f"Błąd zapisu GPKG: {error}\n")
                QtWidgets.QApplication.processEvents()
                continue

            self.tbConsole.append(f"Utworzono GPKG: {gpkg_path} z usuniętymi polami")
            QtWidgets.QApplication.processEvents()

            try:
                conn = sqlite3.connect(gpkg_path)
                conn.execute("VACUUM;")
                conn.close()
                self.tbConsole.append("GPKG zoptymalizowany (VACUUM).")
                QtWidgets.QApplication.processEvents()
            except Exception as e:
                self.tbConsole.append(f"Nie udało się wykonać VACUUM:\n{e}")
                QtWidgets.QApplication.processEvents()

            pct = int(((i + 1) / total) * 100)
            self.progressBar.setValue(pct)
            QtWidgets.QApplication.processEvents()

            self.tbConsole.append("Operacja zakończona.\n")
            QtWidgets.QApplication.processEvents()

    def build_filter_geometry(self) -> QgsGeometry | None:
        layer = self.layer_area_2180()
        if not layer or layer.featureCount() == 0:
            return None

        buffer_value = self.sbBufferValue.value()
        result = None

        for f in layer.getFeatures():
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            if buffer_value > 0:
                g = g.buffer(buffer_value, 5)
            result = g if result is None else result.combine(g)

        return result

    def list_gpkg_layers_file(self, gpkg_path: str) -> set[str]:
        layers: set[str] = set()

        if not gpkg_path or not os.path.isfile(gpkg_path):
            return layers

        provider = QgsProviderRegistry.instance().providerMetadata("ogr")
        sublayers = provider.querySublayers(gpkg_path)

        for sub in sublayers:
            name = sub.name()
            if name:
                layers.add(name)

        return layers

    def import_layers(
        self,
        source_files: list[str],
        target_gpkg: str,
        layer_suffix: str,):
        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak geometrii filtrującej.")
            return

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        existing_layers = self.list_gpkg_layers_file(target_gpkg)

        total = len(source_files)
        if total == 0:
            self.tbConsole.append("Brak plików do importu.")
            return

        self.progressBar.setValue(0)

        for i, path in enumerate(source_files, start=1):
            base = os.path.basename(path)
            layer_name = os.path.splitext(base)[0] + layer_suffix

            if layer_name in existing_layers:
                self.tbConsole.append(f"Pominięto (istnieje): {layer_name}")
                continue

            layer = QgsVectorLayer(path, "src", "ogr")
            if not layer.isValid():
                self.tbConsole.append(f"Błąd wczytania: {base}")
                continue

            request = QgsFeatureRequest()
            request.setFilterRect(bbox)

            matching_features: list[QgsFeature] = []

            for f in layer.getFeatures(request):
                g = f.geometry()
                if g and engine.intersects(g.constGet()):
                    matching_features.append(f)

            if not matching_features:
                self.tbConsole.append(f"Pominięto (brak przecięć): {layer_name}. \n")
                continue

            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "GPKG"
            options.layerName = layer_name
            options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
            options.encoding = "UTF-8"

            writer = QgsVectorFileWriter.create(
                target_gpkg,
                layer.fields(),
                layer.wkbType(),
                layer.crs(),
                QgsProject.instance().transformContext(),
                options
            )

            for f in matching_features:
                writer.addFeature(f)

            del writer

            self.tbConsole.append(
                f"Dodano {len(matching_features)} obiektów → {layer_name}"
            )

            if i % 3 == 0:
                self.progressBar.setValue(int(i / total * 100))
                QtWidgets.QApplication.processEvents()

        self.progressBar.setValue(100)
        self.tbConsole.append("Import zakończony.\n")

    def import_filtered_layers(self, layers_config: dict):
        resource_base = self.resource_path.filePath()
        project_gpkg = self.project_path.filePath()

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        files: list[str] = []

        for src, subfolders in layers_config.items():
            if src.lower().endswith(".gpkg"):
                files.append(os.path.join(resource_base, *subfolders, src))
            else:
                folder = os.path.join(resource_base, *subfolders)
                if not os.path.exists(folder):
                    continue
                files.extend(
                    os.path.join(folder, f)
                    for f in os.listdir(folder)
                    if f.lower().endswith((".gpkg", ".shp"))
                )

        self.import_layers(files, project_gpkg, suffix)

    def import_all_updated_data(self):
        base = os.path.join(self.resource_path.filePath(), "DANE_AKTUALIZOWANE")
        files = [
            os.path.join(root, f)
            for root, _, fs in os.walk(base)
            for f in fs if f.lower().endswith((".gpkg", ".shp"))
        ]

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        self.import_layers(files, self.project_path.filePath(), suffix)

    def import_all_wody_data(self):
        base = os.path.join(self.resource_path.filePath(), "DANE_PGW_GZWP")
        files = [
            os.path.join(root, f)
            for root, _, fs in os.walk(base)
            for f in fs if f.lower().endswith((".gpkg", ".shp"))
        ]

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        self.import_layers(files, self.project_path.filePath(), suffix)

    def import_all_powodz_data(self):
        base = os.path.join(self.resource_path.filePath(), "DANE_POWODZ")
        files = [
            os.path.join(root, f)
            for root, _, fs in os.walk(base)
            for f in fs if f.lower().endswith((".gpkg", ".shp"))
        ]

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        self.import_layers(files, self.project_path.filePath(), suffix)

    def populate_bdot_table(self):
        table = self.table_bdot
        table.clear()
        table.setRowCount(0)
        table.setColumnCount(2)
        table.setHorizontalHeaderLabels(["Import", "Warstwa"])

        base_dir = os.path.join(
            self.resource_path.filePath(),
            "DANE_BDOT"
        )

        if not os.path.isdir(base_dir):
            self.tbConsole.append("Brak katalogu DANE_BDOT.")
            return

        row = 0

        for filename in sorted(os.listdir(base_dir)):
            if not filename.lower().endswith(".gpkg"):
                continue

            name = os.path.splitext(filename)[0]  # OT_BUHD_A
            parts = name.split("_")

            # base BDOT code (OT_BUHD)
            base_code = "_".join(parts[:2]) if len(parts) > 2 else parts[0]

            if base_code not in self.BDOT_LAYERS:
                continue

            # geometry suffix
            geom_suffix = ""
            if parts[-1] in ("A", "L", "P"):
                geom_suffix = f"_{parts[-1]}"

            display_name = self.BDOT_LAYERS[base_code] + geom_suffix

            table.insertRow(row)

            chk = QTableWidgetItem()
            chk.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
            chk.setCheckState(Qt.Unchecked)

            label = QTableWidgetItem(display_name)
            label.setData(Qt.UserRole, filename)

            table.setItem(row, 0, chk)
            table.setItem(row, 1, label)

            row += 1

        table.resizeColumnsToContents()
        table.horizontalHeader().setStretchLastSection(True)

        self.tbConsole.append(f"Załadowano {row} warstw BDOT.")

    def get_matching_teryt_codes(self) -> set[str]:
        area = self.layer_area_2180()
        if not area:
            return set()

        powiat_path = os.path.join(
            self.resource_path.filePath(),
            "DANE_BDOT/HELP",
            "POWIAT_TERYT.gpkg"
        )

        layer = QgsVectorLayer(powiat_path, "powiat", "ogr")
        if not layer.isValid():
            self.tbConsole.append("Nie można wczytać POWIAT_TERYT.")
            return set()

        geom = self.build_filter_geometry()
        bbox = geom.boundingBox()

        engine = QgsGeometry.createGeometryEngine(geom.constGet())
        engine.prepareGeometry()

        request = QgsFeatureRequest().setFilterRect(bbox)

        teryt = set()
        for f in layer.getFeatures(request):
            g = f.geometry()
            if g and engine.intersects(g.constGet()):
                teryt.add(str(f["JPT_KOD_JE"]))

        return teryt

    def import_selected_bdot_layers(self):
        project_gpkg = self.project_path.filePath()
        if not project_gpkg:
            self.tbConsole.append("Brak project_path.")
            return

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak geometrii filtrującej.")
            return

        teryt_codes = self.get_matching_teryt_codes()
        if not teryt_codes:
            self.tbConsole.append("Brak dopasowanych TERYT.")
            return

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        base = os.path.join(self.resource_path.filePath(), "DANE_BDOT")

        for row in range(self.table_bdot.rowCount()):
            if self.table_bdot.item(row, 0).checkState() != Qt.Checked:
                continue

            fn = self.table_bdot.item(row, 1).data(Qt.UserRole)
            src = os.path.join(base, fn)
            out_name = self.table_bdot.item(row, 1).text() + suffix

            layer = QgsVectorLayer(src, "src", "ogr")
            if not layer.isValid():
                self.tbConsole.append(f"Błąd: {fn}")
                continue

            req = QgsFeatureRequest()
            req.setFilterRect(bbox)
            req.setSubsetOfAttributes(layer.fields().names(), layer.fields())

            feats = []
            for f in layer.getFeatures(req):
                if str(f["TERYT"]) not in teryt_codes:
                    continue
                g = f.geometry()
                if g and engine.intersects(g.constGet()):
                    feats.append(f)

            if not feats:
                self.tbConsole.append(f"Pominięto {out_name} – brak obiektów.")
                continue

            opts = QgsVectorFileWriter.SaveVectorOptions()
            opts.driverName = "GPKG"
            opts.layerName = out_name
            opts.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
            opts.encoding = "UTF-8"

            writer = QgsVectorFileWriter.create(
                project_gpkg,
                layer.fields(),
                layer.wkbType(),
                layer.crs(),
                QgsProject.instance().transformContext(),
                opts
            )

            for f in feats:
                writer.addFeature(f)
            del writer

            self.tbConsole.append(f"Dodano {len(feats)} → {out_name}")

        self.tbConsole.append("BDOT import zakończony.\n")
    
    def uncheck_all_bdot(self):
        table = self.table_bdot

        for row in range(table.rowCount()):
            item = table.item(row, 0)
            if item is not None:
                item.setCheckState(Qt.Unchecked)

    def layout_area_gen(self):
        self.tbConsole.append("Rozpoczynam generowanie zasięgów układów...")

        target_crs = QgsCoordinateReferenceSystem("EPSG:2180")
        context = QgsProject.instance().transformContext()

        layout_manager = QgsProject.instance().layoutManager()
        layouts = layout_manager.printLayouts()

        if not layouts:
            self.tbConsole.append("Brak układów w projekcie. Nie dodano żadnych warstw.")
            if self.progressBar:
                self.progressBar.setValue(0)
            return

        total = len(layouts)
        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        unique_extents = []
        created_layers = 0

        for idx, layout in enumerate(layouts, start=1):

            layout_name = layout.name()
            self.tbConsole.append(f"Przetwarzanie układu: {layout_name}")

            map_item = None
            for item in layout.items():
                if isinstance(item, QgsLayoutItemMap) and item.id() in ['Mapa 1', 'Map 1']:
                    map_item = item
                    break

            if map_item is None:
                self.tbConsole.append(f"  Układ pominięty – brak elementu mapy 'Mapa 1' / 'Map 1'.")
                self.progressBar.setValue(idx)
                continue

            extent = map_item.extent()
            source_crs = map_item.crs()
            transform = QgsCoordinateTransform(source_crs, target_crs, context)

            try:
                transformed_extent = transform.transformBoundingBox(extent)
            except Exception as e:
                self.tbConsole.append(f"  Błąd transformacji zasięgu: {e}")
                self.progressBar.setValue(idx)
                continue

            if any(transformed_extent == existing for existing in unique_extents):
                self.tbConsole.append("  Pominięto — zasięg duplikat.")
                self.progressBar.setValue(idx)
                continue

            unique_extents.append(transformed_extent)

            polygon_geom = QgsGeometry.fromRect(transformed_extent)

            layer = QgsVectorLayer(
                "Polygon?crs=EPSG:2180",
                f"Zasięg - {layout_name}",
                "memory"
            )

            provider = layer.dataProvider()
            provider.addAttributes([QgsField("nazwa", QVariant.String)])
            layer.updateFields()

            feature = QgsFeature(layer.fields())
            feature.setGeometry(polygon_geom)
            feature.setAttribute("nazwa", layout_name)
            provider.addFeature(feature)

            QgsProject.instance().addMapLayer(layer)

            created_layers += 1
            self.tbConsole.append(f"Dodano warstwę: Zasięg - {layout_name}")

            self.progressBar.setValue(idx)

        if created_layers == 0:
            self.tbConsole.append("Nie dodano żadnych nowych warstw — brak unikalnych zasięgów.")
        else:
            self.tbConsole.append(f"Zakończono.")

    def pog_numeracja(self):
        self.tbConsole.append("Rozpoczynam numerację obiektów POG...")

        layer = self.iface.activeLayer()
        if not layer:
            self.tbConsole.append("Brak aktywnej warstwy. Wybierz warstwę i spróbuj ponownie.")
            if self.progressBar:
                self.progressBar.setValue(0)
            return

        symbol_field = "symbol"
        oznaczenie_field = "oznaczenie"
        lokalny_field = "lokalnyId"

        if symbol_field not in layer.fields().names():
            self.tbConsole.append(f"Brak wymaganej kolumny '{symbol_field}'.")
            return
        if oznaczenie_field not in layer.fields().names():
            self.tbConsole.append(f"Brak pola '{oznaczenie_field}' do zapisu numeracji.")
            return
        if lokalny_field not in layer.fields().names():
            self.tbConsole.append(f"Brak pola '{lokalny_field}' do zapisu ID lokalnego.")
            return

        unique_symbols = list(layer.uniqueValues(layer.fields().lookupField(symbol_field)))

        if not unique_symbols:
            self.tbConsole.append("Brak unikalnych wartości w kolumnie 'symbol'.")
            return

        self.tbConsole.append(f"Znaleziono {len(unique_symbols)} unikalnych symboli: {unique_symbols}")

        self.progressBar.setMaximum(len(unique_symbols))
        self.progressBar.setValue(0)

        layer.startEditing()

        processed_symbols = 0
        total_numbered = 0

        for idx, symbol in enumerate(unique_symbols, start=1):

            self.tbConsole.append(f"Przetwarzanie symbolu: {symbol}")

            request = QgsFeatureRequest(QgsExpression(f'"{symbol_field}" = \'{symbol}\''))
            features = [f for f in layer.getFeatures(request)
                        if f.geometry() and not f.geometry().isEmpty()]

            if not features:
                self.tbConsole.append("  Brak obiektów z tym symbolem – pomijam.")
                self.progressBar.setValue(idx)
                continue

            if len(features) < 2:
                self.tbConsole.append("  Za mało obiektów do wyznaczenia kolejności – pomijam.")
                self.progressBar.setValue(idx)
                continue

            start_feature = min(features, key=lambda f: (
                f.geometry().centroid().asPoint().x(),
                f.geometry().centroid().asPoint().y()
            ))

            visited = [start_feature]
            features.remove(start_feature)
            current_feature = start_feature

            while features:
                current_pt = current_feature.geometry().centroid().asPoint()
                next_feature = min(
                    features,
                    key=lambda f: current_pt.sqrDist(f.geometry().centroid().asPoint())
                )
                visited.append(next_feature)
                features.remove(next_feature)
                current_feature = next_feature

            for i, feature in enumerate(visited, start=1):
                oznaczenie_value = f"{i}{symbol}"
                lokalnyId_value = f"1POG-{oznaczenie_value}"

                feature.setAttribute(oznaczenie_field, oznaczenie_value)
                feature.setAttribute(lokalny_field, lokalnyId_value)
                layer.updateFeature(feature)

            processed_symbols += 1
            total_numbered += len(visited)

            self.tbConsole.append(
                f"  Znumerowano {len(visited)} obiektów dla symbolu {symbol}."
            )

            self.progressBar.setValue(idx)

        if processed_symbols == 0:
            self.tbConsole.append("Nie wykonano numeracji – żadna grupa nie spełniała wymagań.")
        else:
            self.tbConsole.append(
                f"Zakończono numerację. Przetworzono {processed_symbols} symboli, "
                f"znumerowano {total_numbered} obiektów."
            )

    def pog_korekta_profilu(self):
        self.tbConsole.append("Rozpoczynam korektę profilu podstawowego...")

        symbol_to_profile = {
            "SW": "teren zabudowy mieszkaniowej wielorodzinnej,teren usług,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SJ": "teren zabudowy mieszkaniowej jednorodzinnej,teren usług,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SZ": "teren zabudowy zagrodowej,teren produkcji w gospodarstwach rolnych,teren akwakultury i obsługi rybactwa,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SU": "teren usług,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SH": "teren handlu wielkopowierzchniowego,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SP": "teren produkcji,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SR": "teren produkcji w gospodarstwach rolnych,teren wielkotowarowej produkcji rolnej,teren akwakultury i obsługi rybactwa,teren komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SI": "teren infrastruktury technicznej,teren komunikacji,teren ogrodów działkowych",
            "SN": "teren zieleni urządzonej,teren plaży,teren wód,teren komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SC": "teren cmentarza,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SG": "teren górnictwa i wydobycia,teren komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SO": "teren rolnictwa z zakazem zabudowy,teren lasu,teren zieleni naturalnej,teren wód,teren komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SK": "teren autostrady,teren drogi ekspresowej,teren drogi głównej ruchu przyspieszonego,teren drogi głównej,teren komunikacji kolejowej i szynowej,teren komunikacji kolei linowej,teren komunikacji wodnej,teren komunikacji lotniczej,teren obsługi komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej"
        }

        layer = self.iface.activeLayer()
        if not layer:
            self.tbConsole.append("Brak aktywnej warstwy.")
            return

        fields = layer.fields()
        if "symbol" not in fields.names() or "profilPodstawowy" not in fields.names():
            self.tbConsole.append("Brak wymaganych pól.")
            return

        symbol_idx = fields.indexFromName("symbol")
        profile_idx = fields.indexFromName("profilPodstawowy")

        features = list(layer.getFeatures())
        total = len(features)
        if total == 0:
            self.tbConsole.append("Warstwa nie zawiera obiektów.")
            return

        changes = {}

        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        for i, f in enumerate(features, start=1):
            expected = symbol_to_profile.get(f[symbol_idx])
            if expected and f[profile_idx] != expected:
                changes[f.id()] = {profile_idx: expected}
            self.progressBar.setValue(i)

        if changes:
            layer.startEditing()
            layer.dataProvider().changeAttributeValues(changes)
            layer.commitChanges()
            self.tbConsole.append(f"Zaktualizowano {len(changes)} obiektów.")
        else:
            self.tbConsole.append("Nie dokonano żadnych zmian.")

    def pog_korekta_spacje(self):
        self.tbConsole.append("Rozpoczynam korektę spacji w kolumnach...")

        layer = self.iface.activeLayer()
        if not layer:
            self.tbConsole.append("Brak aktywnej warstwy. Wybierz warstwę i spróbuj ponownie.")
            self.progressBar.setValue(0)
            return

        columns_to_process = ["profilPodstawowy", "profilDodatkowy"]
        for col in columns_to_process:
            if col not in layer.fields().names():
                self.tbConsole.append(f"Brak wymaganego pola '{col}'. Operacja przerwana.")
                return

        features = list(layer.getFeatures())
        total = len(features)
        if total == 0:
            self.tbConsole.append("Warstwa nie zawiera obiektów – nic do korekty.")
            self.progressBar.setValue(0)
            return

        field_indexes = {c: layer.fields().indexFromName(c) for c in columns_to_process}
        changes = {}

        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        for idx, f in enumerate(features, start=1):
            fid = f.id()
            attr_changes = {}

            for col in columns_to_process:
                val = f[col]
                if isinstance(val, str):
                    new_val = val.replace(" ,", ",").replace(", ", ",").rstrip().replace("\xa0", " ").replace("\n", "")
                    if new_val != val:
                        attr_changes[field_indexes[col]] = new_val

            if attr_changes:
                changes[fid] = attr_changes

            self.progressBar.setValue(idx)

        if changes:
            layer.startEditing()
            layer.dataProvider().changeAttributeValues(changes)
            layer.commitChanges()
            self.tbConsole.append(f"Zakończono korektę spacji. Zaktualizowano {len(changes)} obiektów.")
        else:
            self.tbConsole.append("Nie dokonano żadnych zmian – wszystkie wartości były poprawne.")

    # def pog_zgodnosc_z_planem             TO-DO

    def style_save_single(self):
        self.progressBar.reset()
        self.progressBar.setValue(0)
        self.tbConsole.append("Rozpoczynam zapisywanie stylu aktywnej warstwy...")

        layer = self.iface.activeLayer()

        if not layer:
            self.tbConsole.append("Brak aktywnej warstwy. Operacja przerwana.")
            self.progressBar.setValue(0)
            return

        if layer.type() != QgsMapLayerType.VectorLayer:
            self.tbConsole.append(f"Warstwa '{layer.name()}' nie jest warstwą wektorową.")
            self.progressBar.setValue(0)
            return

        layer_name = layer.name()

        try:
            layer.saveStyleToDatabase(
                layer_name,
                "",
                True,
                "",
                QgsMapLayer.AllStyleCategories
            )

            layer.triggerRepaint()

            self.progressBar.setValue(100)
            self.tbConsole.append(f"Zapisano styl warstwy '{layer_name}'.")

        except Exception as e:
            self.tbConsole.append(f"Błąd podczas zapisywania stylu: {str(e)}")
            self.progressBar.setValue(0)

    def style_save_all(self):
        reply = QMessageBox.question(
            self,
            "Potwierdzenie",
            "Czy na pewno chcesz zapisać style dla wszystkich warstw wektorowych?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply != QMessageBox.Yes:
            self.tbConsole.append("Operacja anulowana.")
            return

        self.tbConsole.append("Rozpoczynam zapisywanie stylów dla wszystkich warstw...")
        self.progressBar.reset()
        self.progressBar.setValue(0)

        project = QgsProject.instance()
        vector_layers = [
            layer for layer in project.mapLayers().values()
            if layer.type() == QgsMapLayerType.VectorLayer
        ]

        layer_count_total = len(vector_layers)

        if layer_count_total == 0:
            self.tbConsole.append("Brak warstw wektorowych w projekcie — nic do zapisania.")
            return

        self.tbConsole.append(f"Liczba warstw do zapisania: {layer_count_total}")

        self.progressBar.setMaximum(100)

        processed = 0

        for layer in vector_layers:
            layer_name = layer.name()

            try:
                layer.saveStyleToDatabase(
                    layer_name,
                    "",
                    True,
                    "",
                    QgsMapLayer.AllStyleCategories
                )

                layer.triggerRepaint()
                processed += 1

                progress = int((processed / layer_count_total) * 100)
                self.progressBar.setValue(progress)

                self.tbConsole.append(
                    f"[{processed}/{layer_count_total}] Zapisano styl dla: {layer_name}"
                )

            except Exception as e:
                self.tbConsole.append(f"Błąd przy zapisywaniu stylu warstwy '{layer_name}': {str(e)}")

        self.tbConsole.append("Zakończono zapisywanie stylów dla wszystkich warstw.")
        self.progressBar.setValue(100)

    def reset_fid_values(self):
        layer = self.iface.activeLayer()
        if not layer or "fid" not in layer.fields().names():
            self.tbConsole.append("Brak warstwy lub pola 'fid'.")
            return

        idx = layer.fields().indexFromName("fid")
        changes = {}

        for f in layer.getFeatures():
            changes[f.id()] = {idx: f.id()}

        layer.startEditing()
        layer.dataProvider().changeAttributeValues(changes)
        layer.commitChanges()

        self.tbConsole.append("Zresetowano kolumnę fid.")

    def numeracja_pol(self):
        self.tbConsole.append("Rozpoczynam numerację wszystkich obiektów...")

        layer = self.iface.activeLayer()
        if not layer:
            self.tbConsole.append("Brak aktywnej warstwy.")
            return

        field_name = "numeracja"
        if field_name not in layer.fields().names():
            layer.startEditing()
            layer.addAttribute(QgsField(field_name, QVariant.String))
            layer.commitChanges()
            layer.updateFields()

        idx = layer.fields().indexFromName(field_name)

        features = [f for f in layer.getFeatures() if f.geometry() and not f.geometry().isEmpty()]
        if not features:
            self.tbConsole.append("Brak obiektów z geometrią.")
            return

        centroids = {f.id(): f.geometry().centroid().asPoint() for f in features}
        features.sort(key=lambda f: (centroids[f.id()].x(), centroids[f.id()].y()))

        changes = {}
        total = len(features)
        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        for i, f in enumerate(features, start=1):
            changes[f.id()] = {idx: str(i)}
            self.progressBar.setValue(i)

        layer.startEditing()
        layer.dataProvider().changeAttributeValues(changes)
        layer.commitChanges()

        self.tbConsole.append(f"Zakończono numerację {total} obiektów.")

    def numeracja_unikalna(self):
        self.tbConsole.append("Rozpoczynam numerację grup obiektów...")

        layer = self.iface.activeLayer()
        if not layer:
            self.tbConsole.append("Brak aktywnej warstwy.")
            return

        group_field = self.te_numeracja_unikalna.text().strip()
        if not group_field or group_field not in layer.fields().names():
            self.tbConsole.append("Nieprawidłowe pole grupujące.")
            return

        num_field = "numeracja"
        if num_field not in layer.fields().names():
            layer.startEditing()
            layer.addAttribute(QgsField(num_field, QVariant.String))
            layer.commitChanges()
            layer.updateFields()

        num_idx = layer.fields().indexFromName(num_field)
        groups = layer.uniqueValues(layer.fields().lookupField(group_field))

        self.progressBar.setMaximum(len(groups))
        self.progressBar.setValue(0)

        layer.startEditing()
        total_numbered = 0

        for i, gval in enumerate(groups, start=1):
            feats = [
                f for f in layer.getFeatures(QgsFeatureRequest(QgsExpression(f'"{group_field}" = \'{gval}\'')))
                if f.geometry() and not f.geometry().isEmpty()
            ]
            if not feats:
                self.progressBar.setValue(i)
                continue

            centroids = {f.id(): f.geometry().centroid().asPoint() for f in feats}
            feats.sort(key=lambda f: (centroids[f.id()].x(), centroids[f.id()].y()))

            changes = {f.id(): {num_idx: str(j)} for j, f in enumerate(feats, start=1)}
            layer.dataProvider().changeAttributeValues(changes)

            total_numbered += len(feats)
            self.progressBar.setValue(i)

        layer.commitChanges()
        self.tbConsole.append(f"Zakończono numerację. Zaktualizowano {total_numbered} obiektów.")

    def import_external(self):
        target_layer = self.layer_area_2180()
        if not target_layer:
            self.tbConsole.append("Nie wybrano warstwy referencyjnej (layer_area).")
            return


        buffer_value = self.sbBufferValue.value()
        target_crs = QgsCoordinateReferenceSystem("EPSG:2180")

        if buffer_value > 0:
            buffer_layer = QgsVectorLayer(f"Polygon?crs={target_crs.authid()}", "buffer", "memory")
            buffer_provider = buffer_layer.dataProvider()
            buffer_provider.addAttributes(target_layer.fields())
            buffer_layer.updateFields()

            feats = []
            xform_buffer = QgsCoordinateTransform(target_layer.crs(), target_crs, QgsProject.instance())
            for f in target_layer.getFeatures():
                geom = QgsGeometry(f.geometry())
                if geom:
                    geom.transform(xform_buffer)
                    buffered = geom.buffer(buffer_value, 5)
                    new_feat = QgsFeature(buffer_layer.fields())
                    new_feat.setGeometry(buffered)
                    feats.append(new_feat)
            buffer_provider.addFeatures(feats)
            buffer_layer.updateExtents()
            filter_geom = buffer_layer
        else:
            filter_geom = QgsVectorLayer(f"{QgsWkbTypes.displayString(target_layer.wkbType())}?crs={target_crs.authid()}",
                                         "filter_layer", "memory")
            filter_provider = filter_geom.dataProvider()
            filter_provider.addAttributes(target_layer.fields())
            filter_geom.updateFields()

            xform_filter = QgsCoordinateTransform(target_layer.crs(), target_crs, QgsProject.instance())
            feats = []
            for f in target_layer.getFeatures():
                geom = QgsGeometry(f.geometry())
                if geom:
                    geom.transform(xform_filter)
                    new_feat = QgsFeature(filter_geom.fields())
                    for field in target_layer.fields().names():
                        new_feat[field] = f[field]
                    new_feat.setGeometry(geom)
                    feats.append(new_feat)
            filter_provider.addFeatures(feats)
            filter_geom.updateExtents()

        if filter_geom.featureCount() == 0:
            self.tbConsole.append("Brak funkcji w layer_area lub jego buforze. Import przerwany.")
            QtWidgets.QApplication.processEvents()
            return

        project_gpkg = self.project_path.filePath()
        if not project_gpkg:
            self.tbConsole.append("Nie ustawiono ścieżki do paczki projektu (project_path).")
            QtWidgets.QApplication.processEvents()
            return

        src_path = self.import_external_path.filePath()
        if not src_path or not os.path.exists(src_path):
            self.tbConsole.append("Nie wybrano pliku wektorowego lub plik nie istnieje.")
            QtWidgets.QApplication.processEvents()
            return

        custom_name = self.te_import_external_name.text().strip()
        base_name = os.path.splitext(os.path.basename(src_path))[0]
        layer_name = custom_name if custom_name else base_name

        if buffer_value > 0:
            layer_name += f"_bufor{buffer_value}"

        if self.cb_date_suffix.isChecked():
            date_suffix = datetime.now().strftime("%Y_%m_%d")
            layer_name += f"_{date_suffix}"

        self.tbConsole.append(f"Przetwarzanie: {os.path.basename(src_path)} jako {layer_name}")
        QtWidgets.QApplication.processEvents()

        layer = QgsVectorLayer(src_path, "input", "ogr")
        if not layer.isValid():
            self.tbConsole.append(f"Nie można wczytać warstwy: {src_path}")
            QtWidgets.QApplication.processEvents()
            return

        mem_layer = QgsVectorLayer(f"{QgsWkbTypes.displayString(layer.wkbType())}?crs={target_crs.authid()}",
                                   layer_name, "memory")
        mem_provider = mem_layer.dataProvider()
        mem_provider.addAttributes(layer.fields())
        mem_layer.updateFields()

        xform = QgsCoordinateTransform(layer.crs(), target_crs, QgsProject.instance())

        feats_to_add = []
        for f in layer.getFeatures():
            geom = QgsGeometry(f.geometry())
            if geom:
                geom.transform(xform)

                for filter_feat in filter_geom.getFeatures():
                    filter_geom_obj = filter_feat.geometry()
                    if filter_geom_obj and geom.intersects(filter_geom_obj):
                        new_feat = QgsFeature(mem_layer.fields())
                        for field in layer.fields().names():
                            new_feat[field] = f[field]
                        new_feat.setGeometry(geom)
                        feats_to_add.append(new_feat)
                        break

        if not feats_to_add:
            self.tbConsole.append(f"Pominięto {layer_name} - brak funkcji po przefiltrowaniu")
            QtWidgets.QApplication.processEvents()
            return

        mem_provider.addFeatures(feats_to_add)
        mem_layer.updateExtents()

        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = "GPKG"
        options.layerName = layer_name
        options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
        options.encoding = "UTF-8"

        error = QgsVectorFileWriter.writeAsVectorFormatV2(
            mem_layer,
            project_gpkg,
            QgsProject.instance().transformContext(),
            options
        )
        if error[0] == QgsVectorFileWriter.NoError:
            self.tbConsole.append(f"Dodano warstwę: {layer_name} do {project_gpkg}")
        else:
            self.tbConsole.append(f"Błąd zapisu: {error}")
        QtWidgets.QApplication.processEvents()

        self.progressBar.setValue(100)
        QtWidgets.QApplication.processEvents()

        self.tbConsole.append("Operacja zakończona.\n")
        QtWidgets.QApplication.processEvents()

    def report_intersections(
        self,
        layer: QgsVectorLayer,
        filter_geom: QgsGeometry,
        fields: list[str] | None,
        existence_only: bool = False,) -> int:

        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()
        bbox = filter_geom.boundingBox()

        request = QgsFeatureRequest()
        request.setFilterRect(bbox)

        count = 0

        for f in layer.getFeatures(request):
            g = f.geometry()
            if not g or g.isEmpty():
                continue

            if engine.intersects(g.constGet()):
                count += 1

                if existence_only:
                    return 1

                if fields:
                    vals = []
                    for fld in fields:
                        v = f.attribute(fld)
                        vals.append("" if v is None else str(v))
                    self.tbConsole.append(" | ".join(vals))
                    QtWidgets.QApplication.processEvents()

        return count

    def anal_fop(self):
        self.tbConsole.append("Analiza FOP - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak funkcji w layer_area lub buforze.")
            return

        resource_base = self.resource_path.filePath()

        layers = {
            "DANE_AKTUALIZOWANE/FOP/FOP_ObszaryChronionegoKrajobrazu.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_ObszarySpecjalnejOchrony.gpkg": ["kod", "nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_SpecjalneObszaryOchrony.gpkg": ["kod", "nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_ParkiKrajobrazowe.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_ParkiNarodowe.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_Rezerwaty.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_UzytkiEkologiczne.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_ZespolyPrzyrodniczoKrajobrazowe.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_StanowiskaDokumentacyjne.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_PomnikiPrzyrody_powierzchniowe.gpkg": None,
            "DANE_AKTUALIZOWANE/FOP/FOP_PomnikiPrzyrody_punktowe.gpkg": None,
        }

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        for rel_path, fields in layers.items():
            abs_path = os.path.join(resource_base, rel_path)
            self.tbConsole.append(f"\nWarstwa: {rel_path}")

            if not os.path.exists(abs_path):
                self.tbConsole.append("Plik nie istnieje.")
                continue

            layer = QgsVectorLayer(abs_path, "src", "ogr")
            if not layer.isValid():
                self.tbConsole.append("Nie można wczytać warstwy.")
                continue

            request = QgsFeatureRequest().setFilterRect(bbox)

            matches = []
            for f in layer.getFeatures(request):
                g = f.geometry()
                if g and engine.intersects(g.constGet()):
                    matches.append(f)

            count = len(matches)
            if count == 0:
                self.tbConsole.append("Brak przecięć.")
                continue

            self.tbConsole.append(f"Liczba przecięć: {count}")

            if not fields:
                continue

            is_uzytki = rel_path.endswith("FOP_UzytkiEkologiczne.gpkg")
            if is_uzytki and count > 10:
                self.tbConsole.append("    > 10 obiektów – pominięto listę nazw.")
                continue

            for f in matches:
                vals = [str(f[fld]) for fld in fields if f[fld] is not None]
                if vals:
                    self.tbConsole.append(" | ".join(vals))

        self.tbConsole.append("Analiza FOP - koniec\n")

    def anal_fop_10km(self):
        import os
        from qgis.PyQt import QtWidgets

        self.tbConsole.append("Analiza FOP 10 km - start")
        QtWidgets.QApplication.processEvents()

        area_layer = self.layer_area_2180()
        if not area_layer or area_layer.featureCount() == 0:
            self.tbConsole.append("Brak warstwy obszaru odniesienia.")
            return

        area_geom = None
        for f in area_layer.getFeatures():
            g = f.geometry()
            if g and not g.isEmpty():
                area_geom = g if area_geom is None else area_geom.combine(g)

        if not area_geom:
            self.tbConsole.append("Nie udało się zbudować geometrii obszaru.")
            return

        buffer_geom = area_geom.buffer(10_000, 8)
        bbox = buffer_geom.boundingBox()

        engine_buf = QgsGeometry.createGeometryEngine(buffer_geom.constGet())
        engine_buf.prepareGeometry()

        engine_area = QgsGeometry.createGeometryEngine(area_geom.constGet())
        engine_area.prepareGeometry()

        resource_base = self.resource_path.filePath()
        if not resource_base:
            self.tbConsole.append("Brak ustawionej ścieżki do zasobów.")
            return

        layers = {
            "DANE_AKTUALIZOWANE/FOP/FOP_ObszaryChronionegoKrajobrazu.gpkg": ("Obszar Chronionego Krajobrazu", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_ObszarySpecjalnejOchrony.gpkg": ("Obszar Natura 2000", ["nazwa", "kod"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_SpecjalneObszaryOchrony.gpkg": ("Obszar Natura 2000", ["nazwa", "kod"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_ParkiKrajobrazowe.gpkg": ("Park Krajobrazowy", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_ParkiNarodowe.gpkg": ("Park Narodowy", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_Rezerwaty.gpkg": ("Rezerwat przyrody", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_UzytkiEkologiczne.gpkg": ("Użytek ekologiczny", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_ZespolyPrzyrodniczoKrajobrazowe.gpkg": ("Zespół przyrodniczo-krajobrazowy", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_StanowiskaDokumentacyjne.gpkg": ("Stanowisko dokumentacyjne", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_PomnikiPrzyrody_powierzchniowe.gpkg": ("Pomniki przyrody powierzchniowe", None),
            "DANE_AKTUALIZOWANE/FOP/FOP_PomnikiPrzyrody_punktowe.gpkg": ("Pomniki przyrody punktowe", None),
        }

        angle_ranges = [
            ((337.5, 360.0), "północ"),
            ((0.0, 22.5), "północ"),
            ((22.5, 67.5), "północny wschód"),
            ((67.5, 112.5), "wschód"),
            ((112.5, 157.5), "południowy wschód"),
            ((157.5, 202.5), "południe"),
            ((202.5, 247.5), "południowy zachód"),
            ((247.5, 292.5), "zachód"),
            ((292.5, 337.5), "północny zachód"),
        ]

        def azimuth_label(az):
            az = az % 360
            for (a, b), txt in angle_ranges:
                if a <= az < b:
                    return txt
            return "północ"

        for rel_path, (prefix, fields) in layers.items():
            abs_path = os.path.join(resource_base, rel_path)
            layer_name = os.path.basename(rel_path)

            if not os.path.exists(abs_path):
                continue

            layer = QgsVectorLayer(abs_path, layer_name, "ogr")
            if not layer.isValid():
                continue

            request = QgsFeatureRequest().setFilterRect(bbox)
            matches = []

            for f in layer.getFeatures(request):
                g = f.geometry()
                if g and engine_buf.intersects(g.constGet()):
                    matches.append(f)

            if not matches:
                continue

            if fields is None:
                self.tbConsole.append(f"{prefix}: {len(matches)}")
                continue

            if "UzytkiEkologiczne" in layer_name and len(matches) > 10:
                self.tbConsole.append(f"Użytki ekologiczne: {len(matches)}")
                continue

            for f in matches:
                parts = [prefix]

                for fld in fields:
                    val = f[fld]
                    if val:
                        parts.append(str(val))

                g = f.geometry()

                if engine_area.intersects(g.constGet()):
                    parts.append("- w obszarze")
                else:
                    try:
                        pt = g.centroid().asPoint()
                        # najpierw znajdź najbliższy punkt na granicy obszaru
                        _, p_area, _, _ = area_geom.closestSegmentWithContext(pt)
                        # potem najbliższy punkt na granicy obiektu względem tego punktu
                        _, p_obj, _, _ = g.closestSegmentWithContext(p_area)

                        if p_area and p_obj:
                            # azymut od granicy obszaru do obiektu
                            az = p_area.azimuth(p_obj)
                        else:
                            az = 0
                    except Exception:
                        az = 0

                    az = az % 360

                    dist_km = round(area_geom.distance(g) / 1000, 1)
                    dist_txt = f"{dist_km:.1f}".replace(".", ",")

                    parts.append(f"- {dist_txt} km na {azimuth_label(az)}")

                self.tbConsole.append(" ".join(parts))

        self.tbConsole.append("Analiza FOP 10 km - koniec\n")



    def anal_adm(self):
        self.tbConsole.append("Analiza ADMINISTRACYJNE - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        base = self.resource_path.filePath()

        if not filter_geom:
            self.tbConsole.append("Brak layer_area.")
            return

        layers = {
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_Gminy.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_MorskieLinieBrzegowe.gpkg": None,
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_MorskieWodyWewnetrzne.gpkg": None,
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_Nadlesnictwa.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_ObrebyEwidencyjne.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_PasOchronny.gpkg": None,
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_PasTechniczny.gpkg": None,
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_Powiaty.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_Wojewodztwa.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_ZarzadyZlewni.gpkg": ["ZZ_MIASTO", "RZGW"],
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if fields is None:
                self.tbConsole.append(
                    f"{name}: {'istnieje' if os.path.exists(path) else 'NIE istnieje'}."
                )
                self.progressBar.setValue(int(i / total * 100))
                continue

            if not os.path.exists(path):
                self.tbConsole.append(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.tbConsole.append(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.tbConsole.append(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.tbConsole.append("Analiza ADMINISTRACYJNE zakończona.\n")

    def anal_pig(self):
        self.tbConsole.append("Analiza PIG - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak funkcji w layer_area.")
            return

        base = self.resource_path.filePath()
        layers = {
            "DANE_AKTUALIZOWANE/PIG/PIG_ObszaryGornicze.gpkg": ["NAZWA_OG"],
            "DANE_AKTUALIZOWANE/PIG/PIG_TerenyGornicze.gpkg": ["NAZWA_TG"],
            "DANE_AKTUALIZOWANE/PIG/PIG_UdokumentowaneZloza.gpkg": ["SYMBOL_KOP", "NR_ZLOZA", "NAZWA_ZL"],
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if not os.path.exists(path):
                self.tbConsole.append(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.tbConsole.append(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.tbConsole.append(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.tbConsole.append("Analiza PIG zakończona.\n")

    def anal_wody(self):
        self.tbConsole.append("Analiza WODY - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak funkcji w layer_area.")
            return

        base = self.resource_path.filePath()
        layers = {
            "DANE_PGW_GZWP/WODY_GZWP.gpkg": ["NR_GZWP", "NAZWA"],
            "DANE_PGW_GZWP/WODY_JCWP_pozostale.gpkg": ["MS_KOD", "Nazwa_JCWP"],
            "DANE_PGW_GZWP/WODY_JCWPd.gpkg": ["kod_jcwpd"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_jeziorne.gpkg": ["MS_KOD"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_przejsciowe.gpkg": ["MS_KOD"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_przybrzezne.gpkg": ["MS_KOD"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_rzeczne.gpkg": ["MS_KOD"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_zbiornikowe.gpkg": ["MS_KOD"],
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if not os.path.exists(path):
                self.tbConsole.append(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.tbConsole.append(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.tbConsole.append(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.tbConsole.append("Analiza WODY zakończona.\n")

    def anal_powodz(self):
        self.tbConsole.append("Analiza POWODZ - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak funkcji w layer_area.")
            return

        base = self.resource_path.filePath()
        layers = {
            "DANE_POWODZ/POWODZ_rzeka_10.gpkg": None,
            "DANE_POWODZ/POWODZ_rzeka_100.gpkg": None,
            "DANE_POWODZ/POWODZ_rzeka_500.gpkg": None,
            "DANE_POWODZ/POWODZ_rzeka_WZ.gpkg": None,
            "DANE_POWODZ/POWODZ_morze_100.gpkg": None,
            "DANE_POWODZ/POWODZ_morze_500.gpkg": None,
            "DANE_POWODZ/POWODZ_morze_WZ.gpkg": None,
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if not os.path.exists(path):
                self.tbConsole.append(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.tbConsole.append(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.tbConsole.append(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.tbConsole.append("Analiza POWODZ zakończona.\n")

    def anal_inne(self):
        self.tbConsole.append("Analiza INNE - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak funkcji w layer_area lub buforze.")
            return

        resource_base = self.resource_path.filePath()

        layers = {
            "DANE_INNE/INNE_Mezoregiony.gpkg": ["k_MEZO", "n_MEZO"],
            "DANE_INNE/INNE_PKP_halas_imisja_LDWN.gpkg": ["CATEGORY"],
            "DANE_INNE/INNE_PKP_halas_imisja_LN.gpkg": ["CATEGORY"],
            "DANE_INNE/INNE_Potencjalna_roslinnosc_naturalna.gpkg": ["kod", "nazwa_PL"],
            "DANE_INNE/INNE_Torfowiska_alkaliczne.gpkg": None,
            "DANE_INNE/INNE_Wos_1999_regiony_klimatyczne.gpkg": ["numer", "nazwa"],
            "DANE_INNE/INNE_Korytarze_ekologiczne.gpkg": ["nazwa"],
        }

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        for rel_path, fields in layers.items():
            abs_path = os.path.join(resource_base, rel_path)
            self.tbConsole.append(f"\nWarstwa: {rel_path}")

            if not os.path.exists(abs_path):
                self.tbConsole.append("Plik nie istnieje.")
                continue

            layer = QgsVectorLayer(abs_path, "src", "ogr")
            if not layer.isValid():
                self.tbConsole.append("Nie można wczytać warstwy.")
                continue

            field_names = set(layer.fields().names())
            request = QgsFeatureRequest().setFilterRect(bbox)

            count = 0
            is_roslinnosc = rel_path.endswith("INNE_Potencjalna_roslinnosc_naturalna.gpkg")
            unique_rows = set()

            for f in layer.getFeatures(request):
                g = f.geometry()
                if not g or not engine.intersects(g.constGet()):
                    continue

                count += 1

                if not fields:
                    continue

                values = []
                for fld in fields:
                    if fld not in field_names:
                        values = []
                        break
                    val = f.attribute(fld)
                    values.append("" if val is None else str(val))

                if not values:
                    continue

                if is_roslinnosc:
                    unique_rows.add(tuple(values))
                else:
                    self.tbConsole.append(" | ".join(values))

            if count == 0:
                self.tbConsole.append("Brak przecięć.")
                continue

            self.tbConsole.append(f"Liczba przecięć: {count}")

            if is_roslinnosc and unique_rows:
                for row in sorted(unique_rows):
                    self.tbConsole.append(" | ".join(row))

        self.tbConsole.append("Analiza INNE zakończona.\n")

    def anal_oze(self):
        self.tbConsole.append("Analiza OZE - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak funkcji w layer_area.")
            return

        base = self.resource_path.filePath()
        layers = {
            "DANE_AKTUALIZOWANE/OZE/OZE_elektrownie_wiatrowe.gpkg": None,
            "DANE_AKTUALIZOWANE/OZE/OZE_biogazownie.gpkg": None,
            "DANE_AKTUALIZOWANE/OZE/OZE_fotowoltaika.gpkg": None,
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if not os.path.exists(path):
                self.tbConsole.append(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.tbConsole.append(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.tbConsole.append(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.tbConsole.append("Analiza OZE zakończona.\n")

    def list_project_gpkg_layers(self) -> list[str]:
        gpkg = self.project_path.filePath()
        if not gpkg or not os.path.isfile(gpkg):
            return []

        try:
            conn = sqlite3.connect(gpkg)
            cur = conn.cursor()
            cur.execute(
                "SELECT table_name FROM gpkg_contents WHERE data_type = 'features'"
            )
            return [row[0] for row in cur.fetchall()]
        finally:
            conn.close()

    def load_layers(self):
        table = self.table_gpkg
        table.setRowCount(0)
        table.setColumnCount(2)
        table.setHorizontalHeaderLabels([" ", "Nazwa warstwy"])

        layers = self.list_project_gpkg_layers()

        for i, name in enumerate(layers):
            table.insertRow(i)

            chk = QTableWidgetItem()
            chk.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
            chk.setCheckState(Qt.Unchecked)
            table.setItem(i, 0, chk)

            table.setItem(i, 1, QTableWidgetItem(name))

        if table.rowCount() > 0:
            width = table.sizeHintForIndex(
                table.model().index(0, 0)
            ).width()
        else:
            width = 25

        table.setColumnWidth(0, width + 10)
        table.horizontalHeader().setStretchLastSection(True)

        self.tbConsole.append("Tabela zaktualizowana.")

    def delete_selected_layers(self):
        table = self.table_gpkg
        rows_to_delete = [r for r in range(table.rowCount()) if table.item(r, 0).checkState() == Qt.Checked]
        if not rows_to_delete:
            self.tbConsole.append("Brak wybranych warstw do usunięcia.")
            return

        from PyQt5.QtWidgets import QMessageBox
        confirm = QMessageBox.question(
            self,
            "Potwierdzenie usunięcia",
            f"Czy na pewno usunąć {len(rows_to_delete)} wybrane warstwy?",
            QMessageBox.Yes | QMessageBox.No
        )
        if confirm != QMessageBox.Yes:
            self.tbConsole.append("Operacja zabortowana przez użytkownika.")
            return

        self.tbConsole.append(f"Usuwanie {len(rows_to_delete)} wybranych warstw...")
        layers_to_delete = [table.item(r, 1).text() for r in rows_to_delete]
        try:
            conn = sqlite3.connect(self.project_path.filePath())
            cursor = conn.cursor()
            for layer in layers_to_delete:
                cursor.execute(f"DROP TABLE IF EXISTS '{layer}'")
                cursor.execute(f"DELETE FROM gpkg_contents WHERE table_name='{layer}'")
                cursor.execute(f"DELETE FROM gpkg_geometry_columns WHERE table_name='{layer}'")
                self.tbConsole.append(f"Usunięto warstwę: {layer}")
            conn.commit()
            conn.close()
            self.load_layers()
            self.tbConsole.append("Usuwanie zakończone, tabela zaktualizowana.")
        except Exception as e:
            self.tbConsole.append(f"Błąd usuwania warstw: {e}")

    def rename_selected_layer(self):
        table = self.table_gpkg
        rows_checked = [r for r in range(table.rowCount()) if table.item(r, 0).checkState() == Qt.Checked]
        if len(rows_checked) != 1:
            self.tbConsole.append("Zaznacz tylko jedną warstwę do zmiany nazwy.")
            return

        row = rows_checked[0]
        old_name = table.item(row, 1).text()
        new_name, ok = QInputDialog.getText(self, "Rename Layer", "New name:", text=old_name)
        if not ok or not new_name:
            self.tbConsole.append("Zmiana nazwy anulowana.")
            return

        try:
            conn = sqlite3.connect(self.project_path.filePath())
            cursor = conn.cursor()
            cursor.execute(f"ALTER TABLE '{old_name}' RENAME TO '{new_name}'")
            cursor.execute(f"UPDATE gpkg_contents SET table_name='{new_name}' WHERE table_name='{old_name}'")
            cursor.execute(f"UPDATE gpkg_geometry_columns SET table_name='{new_name}' WHERE table_name='{old_name}'")
            conn.commit()
            conn.close()
            self.load_layers()
            self.tbConsole.append(f"Nazwę warstwy '{old_name}' zmieniono na '{new_name}' i odświeżono tabelę.")
        except Exception as e:
            self.tbConsole.append(f"Błąd zmiany nazwy: {e}")

    def vacuum_gpkg(self):
        try:
            conn = sqlite3.connect(self.project_path.filePath())
            conn.execute("VACUUM")
            conn.close()
            self.tbConsole.append("Geopaczka odkurzona.")
        except Exception as e:
            self.tbConsole.append(f"Błąd odkurzania geopaczki: {e}")

    #



# xD