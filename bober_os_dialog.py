# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BoberOSDialog
 Plugin base generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-12-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Bartosz Łęczycki
        email                : bartosz.leczycki98@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import time

from qgis.core import *
from qgis.core import QgsVectorLayer, QgsProject, QgsFeatureRequest, QgsVectorFileWriter, QgsGeometry, QgsCoordinateTransformContext, QgsWkbTypes, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsFeature
from qgis.PyQt import *
from qgis.PyQt import uic
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtWidgets import QMessageBox, QDialog, QColorDialog
from PyQt5.QtWidgets import QTableWidgetItem, QInputDialog, QMessageBox
from PyQt5.QtCore import Qt, QVariant
import sqlite3
import processing
from qgis.gui import *
from datetime import datetime
from qgis.utils import iface



FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'bober_os_dialog_base.ui'))


class BoberOSDialog(QtWidgets.QDialog, FORM_CLASS):
    BDOT_LAYERS = {
        "OT_SWRS": "BDOT_siec_wod_rzeka_strumien",
        "OT_SWKN": "BDOT_siec_wod_kanal",
        "OT_SWRM": "BDOT_siec_wod_row_melioracyjny",

        "OT_SKJZ": "BDOT_siec_kom_jezdnia",
        "OT_SKDR": "BDOT_siec_kom_droga",
        "OT_SKRW": "BDOT_siec_kom_rondo_wezel",
        "OT_SKRP": "BDOT_siec_kom_ciag_pieszy_rower",
        "OT_SKTR": "BDOT_siec_kom_tory",
        "OT_SKPP": "BDOT_siec_kom_przeprawy",

        "OT_SULN": "BDOT_infra_linia_elektro",
        "OT_SUPR": "BDOT_infra_przewod_rurowy",

        "OT_PTWP": "BDOT_pokrycie_woda",
        "OT_PTZB": "BDOT_pokrycie_zabudowa",
        "OT_PTLZ": "BDOT_pokrycie_las_zadrzewienie",
        "OT_PTRK": "BDOT_pokrycie_rosl_krzewiasta",
        "OT_PTUT": "BDOT_pokrycie_uprawa_trwala",
        "OT_PTTR": "BDOT_pokrycie_rosl_trawiasta_upr_rolna",
        "OT_PTKM": "BDOT_pokrycie_teren_komunikacji",
        "OT_PTGN": "BDOT_pokrycie_grunt_nieuzytkowany",
        "OT_PTPL": "BDOT_pokrycie_plac",
        "OT_PTSO": "BDOT_pokrycie_skladowisko_odpadow",
        "OT_PTWZ": "BDOT_pokrycie_wyrobiska",
        "OT_PTNZ": "BDOT_pokrycie_inny_teren_niezab",

        "OT_BUBD": "BDOT_bud_budynek",
        "OT_BUIN": "BDOT_bud_budowla_inzynierska",
        "OT_BUHD": "BDOT_bud_budowla_hydrotechniczna",
        "OT_BUSP": "BDOT_bud_budowla_sportowa",
        "OT_BUWT": "BDOT_bud_wysoka_budowla_techniczna",
        "OT_BUZT": "BDOT_bud_zbiornik_techniczny",
        "OT_BUUO": "BDOT_bud_umocnienia",
        "OT_BUZM": "BDOT_bud_budowle_ziemne",
        "OT_BUTR": "BDOT_bud_urzadzenia_transportowe",
        "OT_BUIT": "BDOT_bud_inne_urzadzenia_techniczne",
        "OT_BUIB": "BDOT_bud_inne_budowle",

        "OT_ADMS": "BDOT_adm_miejscowosc",

        "OT_OIPR": "BDOT_inne_obiekt_przyr",
        "OT_OIKM": "BDOT_inne_obiekt_komunikacja",
        "OT_OIOR": "BDOT_inne_obiekt_orientacyjny",
        "OT_OIMK": "BDOT_inne_mokradlo",
        "OT_OISZ": "BDOT_inne_szuwary",
    }    
    
    def __init__(self, parent=None):
        if parent is None:
            parent = iface.mainWindow()
        super(BoberOSDialog, self).__init__(parent)
        self.iface = iface
        self.setupUi(self)
        self.init_ui_color_customization()
        
        self.setWindowFlags(Qt.Window | Qt.WindowMinMaxButtonsHint | Qt.WindowCloseButtonHint)
        
        for btn in self.findChildren(QtWidgets.QPushButton):
            btn.setDefault(False)
            btn.setAutoDefault(False)

        self.pbClearConsole.clicked.connect(self.run_clear_console)

        self.project_path.setStorageMode(QgsFileWidget.GetFile)
        self.project_path.setFilter("GeoPackage files (*.gpkg)")
        
        self.mpzp_layer.layerChanged.connect(self.populate_mpzp_symbol_columns)
        self.numeracja_layer.layerChanged.connect(self.populate_numeracja_unikalna_columns)
        
        
        self.project_path.fileChanged.connect(lambda path: self.save_setting("project_path", path))
        saved_path = self.load_setting("project_path")
        if saved_path:
            self.project_path.setFilePath(saved_path)
                
        self.layer_area.currentIndexChanged.connect(self.update_label_layer_area)
        
        saved_buffer = self.load_setting("buffer_value")
        if saved_buffer:
            self.sbBufferValue.setValue(int(saved_buffer))
        self.sbBufferValue.valueChanged.connect(self.update_buffer_value)
        self.update_buffer_value(self.sbBufferValue.value())
        
        self.wind_area.setFilters(
            QgsMapLayerProxyModel.PolygonLayer |
            QgsMapLayerProxyModel.PointLayer
        )
        self.mpzp_layer.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.pog_layer.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.numeracja_layer.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        
        self.layer_area.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.layer_area.setCurrentIndex(-1)
        
        self.resource_path.setStorageMode(QgsFileWidget.GetDirectory)
        self.resource_path.setFilePath("")

        self.resource_path.fileChanged.connect(lambda path: self.save_setting("resource_path", path))
        saved_resource = self.load_setting("resource_path")
        if saved_resource:
            self.resource_path.setFilePath(saved_resource)
        
        self.pb_act_fop.clicked.connect(self.act_fop_layers)
        self.pb_act_pomniki.clicked.connect(self.act_pomniki_layers)
        self.pb_act_pig.clicked.connect(self.act_pig_layers)
        self.pb_act_adm.clicked.connect(self.act_adm_layers)
        self.pb_act_oze.clicked.connect(self.act_oze_layers)
        self.fop_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.fop_path.setFilter("Shapefile (*.shp)")
        self.pomniki_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.pomniki_path.setFilter("GPKG (*.gpkg)")
        self.pig_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.pig_path.setFilter("Shapefile (*.shp)")
        self.adm_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.adm_path.setFilter("GML file (*.gml)")
        self.oze_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.oze_path.setFilter("GPKG file (*.gpkg)")
        
        button_configs = {
            self.pb_import_fop: {"": ["DANE_AKTUALIZOWANE", "FOP"]},
            self.pb_import_pig: {"": ["DANE_AKTUALIZOWANE", "PIG"]},
            self.pb_import_um: {"ADM_MorskieLinieBrzegowe.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"],
                "ADM_MorskieWodyWewnetrzne.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"],
                "ADM_PasOchronny.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"],
                "ADM_PasTechniczny.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_obreb: {"ADM_ObrebyEwidencyjne.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_gmina: {"ADM_Gminy.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_powiat: {"ADM_Powiaty.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_wojewodztwo: {"ADM_Wojewodztwa.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_nadlesnictwo: {"ADM_Nadlesnictwa.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_zz: {"ADM_ZarzadyZlewni.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_oze: {"": ["DANE_AKTUALIZOWANE", "OZE"]},
            self.pb_import_jcwpd: {"WODY_JCWPd.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_gzwp: {"WODY_GZWP.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwprz: {"WODY_Zlewnie_JCWP_rzeczne.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwpj: {"WODY_Zlewnie_JCWP_jeziorne.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwpprzej: {"WODY_Zlewnie_JCWP_przejsciowe.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwpprzyb: {"WODY_Zlewnie_JCWP_przybrzezne.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwpzbior: {"WODY_Zlewnie_JCWP_zbiornikowe.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwppozos: {"WODY_JCWP_pozostale.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_powodz_rzeka10: {"POWODZ_rzeka_10.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_rzeka100: {"POWODZ_rzeka_100.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_rzeka500: {"POWODZ_rzeka_500.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_rzekaWZ: {"POWODZ_rzeka_WZ.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_morze100: {"POWODZ_morze_100.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_morze500: {"POWODZ_morze_500.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_morzeWZ: {"POWODZ_morze_WZ.gpkg": ["DANE_POWODZ"]},
            self.pb_import_skorowidze: {"INNE_Skorowidz50k_92.gpkg": ["DANE_INNE"]},
            self.pb_import_fizgeo: {"INNE_Mezoregiony.gpkg": ["DANE_INNE"]},
            self.pb_import_roslinnosc: {"INNE_Potencjalna_roslinnosc_naturalna.gpkg": ["DANE_INNE"]},
            self.pb_import_reg_klim: {"INNE_Wos_1999_regiony_klimatyczne.gpkg": ["DANE_INNE"]},
            self.pb_import_pkp_halas_ldwn: {"INNE_PKP_halas_imisja_LDWN.gpkg": ["DANE_INNE"]},
            self.pb_import_pkp_halas_ln: {"INNE_PKP_halas_imisja_LN.gpkg": ["DANE_INNE"]},
            self.pb_import_torfowiska_alk: {"INNE_Torfowiska_alkaliczne.gpkg": ["DANE_INNE"]},
            self.pb_import_korytarze: {"INNE_Korytarze_ekologiczne.gpkg": ["DANE_INNE"]},
            self.pb_import_lasy: {"INNE_Lasy_BDL.gpkg": ["DANE_INNE"]}
        }

        for btn, config in button_configs.items():
            btn.clicked.connect(lambda _, c=config: self.import_filtered_layers(c))

        self.pb_import_act_all.clicked.connect(self.import_all_updated_data)
        self.pb_import_wody_all.clicked.connect(self.import_all_wody_data)
        self.pb_import_powodz_all.clicked.connect(self.import_all_powodz_data)
        self.pb_layout_area.clicked.connect(self.layout_area_gen)
        self.pb_pog_numeracja.clicked.connect(self.pog_numeracja)
        self.pb_pog_profil.clicked.connect(self.pog_korekta_profilu)
        self.pb_pog_spacje.clicked.connect(self.pog_korekta_spacje)
        self.pb_pog_zgodnosc.clicked.connect(self.pog_zgodnosc)
        
        self.pb_style_save_single.clicked.connect(self.style_save_single)
        self.pb_style_save_all.clicked.connect(self.style_save_all)
        
        self.pb_reset_fid_values.clicked.connect(self.reset_fid_values)
        self.pb_numeracja_pol.clicked.connect(self.numeracja_pol)
        self.pb_numeracja_unikalna.clicked.connect(self.numeracja_unikalna)
        self.pb_import_external.clicked.connect(self.import_external)
        self.import_external_filter_path.fileChanged.connect(self.populate_import_external_filter_columns)
        self.pb_import_external_filter.clicked.connect(self.import_external_filter)
        
        self.pb_anal_fop.clicked.connect(self.anal_fop)
        self.pb_anal_adm.clicked.connect(self.anal_adm)
        self.pb_anal_pig.clicked.connect(self.anal_pig)
        self.pb_anal_wody.clicked.connect(self.anal_wody)
        self.pb_anal_powodz.clicked.connect(self.anal_powodz)
        self.pb_anal_inne.clicked.connect(self.anal_inne)
        self.pb_anal_oze.clicked.connect(self.anal_oze)
        self.pb_anal_fop_10km.clicked.connect(self.anal_fop_10km)
                
        self.pb_gpkg_load_layers.clicked.connect(self.load_layers)
        self.pb_gpkg_delete_layers.clicked.connect(self.delete_selected_layers)
        self.pb_gpkg_rename_layers.clicked.connect(self.rename_selected_layer)
        self.pb_gpkg_vacuum_layers.clicked.connect(self.vacuum_gpkg)
        
        self.pb_bdot_refresh.clicked.connect(self.populate_bdot_table)
        self.pb_bdot_import.clicked.connect(self.import_selected_bdot_layers)
        self.pb_bdot_uncheck.clicked.connect(self.uncheck_all_bdot)
        
        self.pb_anal_wind_pobliska.clicked.connect(self.anal_wind_pobliska)
        self.pb_anal_wind_build_700.clicked.connect(self.anal_wind_build_700)
        self.pb_anal_wind_build_700_rad.clicked.connect(self.anal_wind_build_700_rad)
        self.pb_anal_wind_elect.clicked.connect(self.anal_wind_elect)
        
        self.pb_anal_pog_flood_buildings.clicked.connect(self.anal_pog_flood_buildings)
        self.pb_anal_pog_all_buildings.clicked.connect(self.anal_pog_all_buildings)


    def save_setting(self, key: str, value: str):
        settings = QSettings()
        settings.setValue(f"bober_os/settings/{key}", value)
        if key == "project_path":
            self.tbConsole.append(f"Zapisano ścieżkę do paczki projektu: {value}")
        if key == "resource_path":
            self.tbConsole.append(f"Zapisano ścieżkę do zasobu danych: {value}")
        elif key == "buffer_value":
            self.tbConsole.append(f"Zapisano wartość buforu: {value} m")

    def load_setting(self, key: str) -> str:
        settings = QSettings()
        return settings.value(f"bober_os/settings/{key}", "")

    def update_buffer_value(self, value):
        self.save_setting("buffer_value", str(value))
    
    def update_label_layer_area(self):
        layer = self.layer_area.currentLayer()
        if layer:
            self.labelLayerArea.setText(f"Wybrana warstwa: {layer.name()}")
        else:
            self.labelLayerArea.setText("Brak wybranej warstwy")

    def populate_mpzp_symbol_columns(self):
        self.cb_mpzp_symbol_col.blockSignals(True)
        self.cb_mpzp_symbol_col.clear()

        layer = self.mpzp_layer.currentLayer()
        if not layer or layer.type() != QgsMapLayerType.VectorLayer:
            self.cb_mpzp_symbol_col.blockSignals(False)
            return

        for f in layer.fields():
            self.cb_mpzp_symbol_col.addItem(f.name())

        self.cb_mpzp_symbol_col.blockSignals(False)

    def populate_import_external_filter_columns(self):
        self.cb_import_external_filter.clear()

        src_path = self.import_external_filter_path.filePath()
        if not src_path or not os.path.exists(src_path):
            return

        layer = QgsVectorLayer(src_path, "src", "ogr")
        if not layer.isValid():
            self.tbConsole.append("Nie można wczytać warstwy do filtrowania.")
            return

        for field in layer.fields():
            self.cb_import_external_filter.addItem(field.name())
    
    def populate_numeracja_unikalna_columns(self):
        self.cb_numeracja_unikalna.blockSignals(True)
        self.cb_numeracja_unikalna.clear()

        layer = self.numeracja_layer.currentLayer()
        if not layer:
            self.cb_numeracja_unikalna.blockSignals(False)
            return

        for f in layer.fields():
            self.cb_numeracja_unikalna.addItem(f.name())

        self.cb_numeracja_unikalna.blockSignals(False)    

    def init_ui_color_customization(self):
        self._ui_color_settings_key = "bober_os/settings/ui_bg_color"
        self._ui_color_default = "rgb(231, 255, 241)"
        self._base_stylesheet = self.styleSheet()
        settings = QSettings()
        color = settings.value(self._ui_color_settings_key, self._ui_color_default)
        self.apply_ui_bg_color(color)

        self.pbUiColor.clicked.connect(self.open_ui_color_slider)

    def apply_ui_bg_color(self, color_str: str):
        self.setStyleSheet(
            self._base_stylesheet +
            f"""
            QWidget {{
                background-color: {color_str};
            }}
            """
        )

    def open_ui_color_slider(self):
        dlg = QColorDialog(self)
        dlg.setOption(QColorDialog.DontUseNativeDialog, True)
        dlg.setOption(QColorDialog.ShowAlphaChannel, False)
        dlg.setWindowTitle("Wybierz kolor tła")

        if dlg.exec() != QColorDialog.Accepted:
            return

        color = dlg.currentColor()
        if not color.isValid():
            return

        color_str = f"rgb({color.red()}, {color.green()}, {color.blue()})"

        self.apply_ui_bg_color(color_str)
        QSettings().setValue(self._ui_color_settings_key, color_str)

        if hasattr(self, "tbConsole"):
            self.tbConsole.append(f"Ustawiono kolor tła: {color_str}")

    def layer_area_2180(self) -> QgsVectorLayer | None:
        src_layer = self.layer_area.currentLayer()
        if not src_layer:
            return None

        target_crs = QgsCoordinateReferenceSystem("EPSG:2180")
        if hasattr(self, "_layer_area_2180_cache"):
            cached_id, cached_layer = self._layer_area_2180_cache
            if cached_id == src_layer.id():
                return cached_layer
        if src_layer.crs() == target_crs:
            self._layer_area_2180_cache = (src_layer.id(), src_layer)
            return src_layer

        context = QgsProject.instance().transformContext()
        transform = QgsCoordinateTransform(
            src_layer.crs(),
            target_crs,
            context
        )

        mem_layer = QgsVectorLayer(
            f"{QgsWkbTypes.displayString(src_layer.wkbType())}?crs=EPSG:2180",
            f"{src_layer.name()}_2180",
            "memory"
        )

        provider = mem_layer.dataProvider()
        provider.addAttributes(src_layer.fields())
        mem_layer.updateFields()

        feats = []
        for f in src_layer.getFeatures():
            geom = f.geometry()
            if geom and not geom.isEmpty():
                geom = QgsGeometry(geom)
                geom.transform(transform)

                nf = QgsFeature(mem_layer.fields())
                nf.setAttributes(f.attributes())
                nf.setGeometry(geom)
                feats.append(nf)

        if not feats:
            return None

        provider.addFeatures(feats)
        mem_layer.updateExtents()
        self._layer_area_2180_cache = (src_layer.id(), mem_layer)

        return mem_layer

    def run_clear_console(self):
        self.tbConsole.setText("")
        self.progressBar.reset()   
    
    def process_vector_files(
        self,
        input_paths,
        match_rules,
        fields_per_rule,
        target_crs="EPSG:2180",
        subfolder="",
        force_cp1250=False):
        if isinstance(input_paths, str):
            input_paths = [input_paths]

        if not input_paths:
            self.tbConsole.append("No input files selected.")
            return

        base_dir = self.resource_path.filePath()
        if not base_dir:
            self.tbConsole.append("Resource path not set.")
            return

        out_dir = (
            os.path.join(base_dir, *subfolder)
            if isinstance(subfolder, (list, tuple))
            else os.path.join(base_dir, subfolder)
        )
        os.makedirs(out_dir, exist_ok=True)

        target_crs_obj = QgsCoordinateReferenceSystem(target_crs)
        context = QgsProject.instance().transformContext()

        total = len(input_paths)
        self.progressBar.setValue(0)

        for i, src_path in enumerate(input_paths, 1):
            base = os.path.basename(src_path)

            gpkg_name = None
            matched = None
            for pat, tgt in match_rules.items():
                p = pat.replace("%", "")
                if (
                    (pat.startswith("%") and pat.endswith("%") and p in base)
                    or (pat.startswith("%") and base.endswith(p))
                    or (pat.endswith("%") and base.startswith(p))
                    or base == p
                ):
                    gpkg_name = tgt
                    matched = pat
                    break

            if not gpkg_name:
                self.tbConsole.append(f"No rule for: {base}")
                self.progressBar.setValue(int(i / total * 100))
                continue

            gpkg_path = os.path.join(out_dir, gpkg_name)

            layer = QgsVectorLayer(src_path, "src", "ogr")
            if not layer.isValid():
                self.tbConsole.append(f"Failed to load layer: {base}")
                self.progressBar.setValue(int(i / total * 100))
                continue

            # THIS IS THE KEY LINE – ALWAYS FORCE CP1250 WHEN REQUESTED
            if force_cp1250:
                layer.dataProvider().setEncoding("CP1250")

            src_fields = layer.fields()
            drop = set(fields_per_rule.get(matched, []))
            keep_idx = [i for i, f in enumerate(src_fields) if f.name() not in drop]

            geom_type = layer.wkbType()
            need_tr = layer.crs().isValid() and layer.crs() != target_crs_obj
            if need_tr:
                tr = QgsCoordinateTransform(layer.crs(), target_crs_obj, context)

            mem = QgsVectorLayer(
                f"{QgsWkbTypes.displayString(geom_type)}?crs={target_crs}",
                "mem",
                "memory"
            )
            prov = mem.dataProvider()
            prov.addAttributes([src_fields[i] for i in keep_idx])
            mem.updateFields()

            feats = []
            for f in layer.getFeatures():
                g = f.geometry()
                if not g or g.isEmpty():
                    continue

                if need_tr:
                    g = QgsGeometry(g)
                    g.transform(tr)

                nf = QgsFeature(mem.fields())
                nf.setGeometry(g)
                nf.setAttributes([f[i] for i in keep_idx])
                feats.append(nf)

            if not feats:
                self.tbConsole.append(f"No valid features: {base}")
                self.progressBar.setValue(int(i / total * 100))
                continue

            prov.addFeatures(feats)
            mem.updateExtents()

            layer_name = os.path.splitext(gpkg_name)[0]

            if os.path.exists(gpkg_path):
                try:
                    os.remove(gpkg_path)
                except Exception:
                    self.tbConsole.append(f"Cannot overwrite file: {gpkg_path}")
                    self.progressBar.setValue(int(i / total * 100))
                    continue

            opts = QgsVectorFileWriter.SaveVectorOptions()
            opts.driverName = "GPKG"
            opts.layerName = layer_name
            opts.encoding = "UTF-8"
            opts.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteFile

            err, _ = QgsVectorFileWriter.writeAsVectorFormatV2(
                mem, gpkg_path, context, opts
            )

            if err != QgsVectorFileWriter.NoError:
                self.tbConsole.append(f"Write failed: {base}")

            self.progressBar.setValue(int(i / total * 100))
            QtWidgets.QApplication.processEvents()

        self.progressBar.setValue(100)
        self.tbConsole.append("Operation completed.")
 
    def act_fop_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.fop_path.filePath())

        match_rules = {
            "ParkiKrajobrazowe%": "FOP_ParkiKrajobrazowe.gpkg",
            "ParkiNarodowe%": "FOP_ParkiNarodowe.gpkg",
            "Rezerwaty%": "FOP_Rezerwaty.gpkg",
            "ObszaryChronionegoKrajobrazu%": "FOP_ObszaryChronionegoKrajobrazu.gpkg",
            "ObszarySpecjalnejOchrony%": "FOP_ObszarySpecjalnejOchrony.gpkg",
            "SpecjalneObszaryOchrony%": "FOP_SpecjalneObszaryOchrony.gpkg",
            "StanowiskaDokumentacyjne%": "FOP_StanowiskaDokumentacyjne.gpkg",
            "UzytkiEkologiczne%": "FOP_UzytkiEkologiczne.gpkg",
            "ZespolyPrzyrodniczoKrajobrazowe%": "FOP_ZespolyPrzyrodniczoKrajobrazowe.gpkg"
        }

        fields_per_rule = {k: ["gid", "kodinspire"] for k in match_rules.keys()}

        self.process_vector_files(
            input_paths=shp_list,
            match_rules=match_rules,
            fields_per_rule=fields_per_rule,
            target_crs="EPSG:2180",
            subfolder=["DANE_AKTUALIZOWANE", "FOP"],
            force_cp1250=True
        )
    
    def act_pomniki_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.pomniki_path.filePath())

        match_rules = {
            "PomnikiPrzyrodyPunktowe%": "FOP_PomnikiPrzyrody_punktowe.gpkg",
            "PomnikiPrzyrodyPowierzchniowe%": "FOP_PomnikiPrzyrody_powierzchniowe.gpkg",
        }

        fields_per_rule = {k: ["gid", "kodinspire"] for k in match_rules.keys()}

        self.process_vector_files(
            input_paths=shp_list,
            match_rules=match_rules,
            fields_per_rule=fields_per_rule,
            target_crs="EPSG:2180",
            subfolder=["DANE_AKTUALIZOWANE", "FOP"],
            force_cp1250=True
        )        

    def act_pig_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.pig_path.filePath())

        match_rules = {
            "cbdg_midas_zloza%": "PIG_UdokumentowaneZloza.gpkg",
            "cbdg_midas_tereny%": "PIG_TerenyGornicze.gpkg",
            "cbdg_midas_obszary%": "PIG_ObszaryGornicze.gpkg",
        }

        fields_per_rule = {
            "cbdg_midas_zloza%": ["UKL_WSP", "KOPALINA_A", "SHAPE_AREA", "SHAPE_LEN"],
            "cbdg_midas_tereny%": ["ID_KONTURU", "STATUS", "STATUS_EN", "KOMENTARZ",
                                    "UKLAD_WSP", "ARK_MAP_50", "SHAPE_AREA", "SHAPE_LEN"],
            "cbdg_midas_obszary%": ["ID_KONTURU", "STATUS", "STATUS_EN", "KOMENTARZ",
                                    "UKLAD_WSP", "ARK_MAP_50", "SHAPE_AREA", "SHAPE_LEN"],
        }

        self.process_vector_files(
            input_paths=shp_list,
            match_rules=match_rules,
            fields_per_rule=fields_per_rule,
            target_crs="EPSG:2180",
            subfolder=["DANE_AKTUALIZOWANE", "PIG"]
        )

    def act_oze_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.oze_path.filePath())

        match_rules = {
            "elektrownie wiatrowe%": "OZE_elektrownie_wiatrowe.gpkg",
            "fotowoltaika%": "OZE_fotowoltaika.gpkg",
            "biogazownie%": "OZE_biogazownie.gpkg",
        }

        fields_per_rule = {
            "elektrownie wiatrowe%": ["organ"],
            "fotowoltaika%": ["powierzchnia zabudowy [ha]", "powierzchnia zabudowy 2 [ha]", "RDOŚ"],
            "biogazownie%": ["RDOŚ"],
        }

        self.process_vector_files(
            input_paths=shp_list,
            match_rules=match_rules,
            fields_per_rule=fields_per_rule,
            target_crs="EPSG:2180",
            subfolder=["DANE_AKTUALIZOWANE", "OZE"]
        )        

    def act_adm_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.adm_path.filePath())

        match_rules = {
            "%Pas_ochronny%": "ADM_PasOchronny.gpkg",
            "%Pas_techniczny%": "ADM_PasTechniczny.gpkg",
            "%Morskie_linie_brzegowe%": "ADM_MorskieLinieBrzegowe.gpkg",
            "%Morskie_wody_wewnetrzne%": "ADM_MorskieWodyWewnetrzne.gpkg",
            "%Nadlesnictwo%": "ADM_Nadlesnictwa.gpkg",
            "%Zarzad_zlewni_PGWWP%": "ADM_ZarzadyZlewni.gpkg",
            "%Granice_wojewodztw%": "ADM_Wojewodztwa.gpkg",
            "%Granice_powiatow%": "ADM_Powiaty.gpkg",
            "%Granice_gmin%": "ADM_Gminy.gpkg",
            "%Granice_obrebow_ewidencyjnych%": "ADM_ObrebyEwidencyjne.gpkg",
        }

        fields_per_rule = {
            "%Pas_ochronny%": [
                "gml_id", "DOCUMENT_I", "COASTAL_ZO", "TERYT_NO", "COASTAL_Z0",
                "FULL_NAME", "SHORT_NAME", "DESCRIPTIO", "COMMENTS", "NOTES",
                "SYS_NODE_C", "SYS_VERSIO", "SYS_VERSI0", "SYS_DATE_A", "SYS_DATA_A",
                "SYS_DATA_E", "SYS_UUID", "IIP_PRZEST"
            ],
            "%Pas_techniczny%": [
                "gml_id", "DOCUMENT_I", "COASTAL_ZO", "TERYT_NO", "COASTAL_Z0",
                "FULL_NAME", "SHORT_NAME", "DESCRIPTIO", "COMMENTS", "NOTES",
                "SYS_NODE_C", "SYS_VERSIO", "SYS_VERSI0", "SYS_DATE_A", "SYS_DATA_A",
                "SYS_DATA_E", "SYS_UUID", "IIP_PRZEST"
            ],
            "%W06_Morskie_linie_brzegowe%": [
                "gml_id", "DOCUMENT_I", "COASTAL_ZO", "TERYT_NO", "COASTAL_Z0",
                "FULL_NAME", "SHORT_NAME", "DESCRIPTIO", "COMMENTS", "NOTES",
                "SYS_NODE_C", "SYS_VERSIO", "SYS_VERSI0", "SYS_DATE_A", "SYS_DATA_A",
                "SYS_DATA_E", "SYS_UUID", "IIP_PRZEST"
            ],
            "%Morskie_wody_wewnetrzne%": [
                "gml_id", "FID", "ID", "SHORT_NAME", "AREA", "WERSJA_OD", "IIP_PRZEST"
            ],
            "%Zarzad_zlewni_PGWWP%": [
                "gml_id", "RZGW_KOD", "REGON"
            ],
            "%Nadlesnictwo%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_ORGAN_", "JPT_JOR_ID",
                "WERSJA_OD", "WERSJA_DO", "WAZNY_OD", "WAZNY_DO", "JPT_KOD__1",
                "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "ID_BUFORA_", "ID_BUFORA1",
                "ID_TECHNIC", "IIP_PRZEST", "IIP_IDENTY", "IIP_WERSJA", "JPT_KJ_IIP",
                "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_OPIS", "JPT_SPS_KO", "ID_BUFOR_1",
                "JPT_ID", "JPT_POWI_1", "JPT_KJ_I_3", "JPT_GEOMET", "JPT_GEOM_1",
                "SHAPE_LENG", "SHAPE_AREA", "REGON", "JPT_POWIER"
            ],
            "%Granice_obrebow_ewidencyjnych%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_POWIER", "JPT_ORGAN_",
                "JPT_KOD__1", "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "IIP_PRZEST",
                "IIP_IDENTY", "JPT_KJ_IIP", "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_SPS_KO",
                "JPT_POWI_1", "JPT_KJ_I_3", "JPT_JOR_ID", "WERSJA_OD", "WERSJA_DO",
                "WAZNY_OD", "WAZNY_DO", "IIP_WERSJA", "JPT_OPIS", "JPT_ID",
                "SHAPE_LENG", "SHAPE_AREA"
            ],
            "%Granice_gmin%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_POWIER", "JPT_ORGAN_",
                "JPT_KOD__1", "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "IIP_PRZEST",
                "IIP_IDENTY", "JPT_KJ_IIP", "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_SPS_KO",
                "JPT_POWI_1", "JPT_KJ_I_3", "JPT_JOR_ID", "WERSJA_OD", "WERSJA_DO",
                "WAZNY_OD", "WAZNY_DO", "IIP_WERSJA", "JPT_OPIS", "JPT_ID", "REGON",
                "SHAPE_LENG", "SHAPE_AREA"
            ],
            "%Granice_powiatow%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_POWIER", "JPT_ORGAN_",
                "JPT_KOD__1", "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "IIP_PRZEST",
                "IIP_IDENTY", "JPT_KJ_IIP", "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_SPS_KO",
                "JPT_POWI_1", "JPT_KJ_I_3", "JPT_JOR_ID", "WERSJA_OD", "WERSJA_DO",
                "WAZNY_OD", "WAZNY_DO", "IIP_WERSJA", "JPT_OPIS", "JPT_ID", "REGON",
                "SHAPE_LENG", "SHAPE_AREA"
            ],
            "%Granice_wojewodztw%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_POWIER", "JPT_ORGAN_",
                "JPT_KOD__1", "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "IIP_PRZEST",
                "IIP_IDENTY", "JPT_KJ_IIP", "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_SPS_KO",
                "JPT_POWI_1", "JPT_KJ_I_3", "JPT_JOR_ID", "WERSJA_OD", "WERSJA_DO",
                "WAZNY_OD", "WAZNY_DO", "IIP_WERSJA", "JPT_OPIS", "JPT_ID", "REGON",
                "SHAPE_LENG", "SHAPE_AREA"
            ]
        }

        resource_base = self.resource_path.filePath()
        if not resource_base:
            self.tbConsole.append("Brak ścieżki zasobu (resource_path).")
            QtWidgets.QApplication.processEvents()
            return

        resource_dir = os.path.join(resource_base, "DANE_AKTUALIZOWANE", "ADMINISTRACYJNE")
        os.makedirs(resource_dir, exist_ok=True)

        total = len(shp_list)
        for i, gml_path in enumerate(shp_list):
            base = os.path.basename(gml_path)

            gpkg_name = None
            matched_pattern = None
            for pattern, target in match_rules.items():
                p = pattern.replace("%", "")
                if pattern.startswith("%") and pattern.endswith("%") and p in base:
                    gpkg_name = target
                    matched_pattern = pattern
                    break
                elif pattern.startswith("%") and base.endswith(p):
                    gpkg_name = target
                    matched_pattern = pattern
                    break
                elif pattern.endswith("%") and base.startswith(p):
                    gpkg_name = target
                    matched_pattern = pattern
                    break
                elif base == p:
                    gpkg_name = target
                    matched_pattern = pattern
                    break

            if not gpkg_name:
                self.tbConsole.append(f"Brak reguły dopasowania dla: {base}\n")
                QtWidgets.QApplication.processEvents()
                continue

            gpkg_path = os.path.join(resource_dir, gpkg_name)
            layer_name_in_gpkg = os.path.splitext(gpkg_name)[0]

            self.tbConsole.append(f"Przetwarzanie pliku: {base}")
            QtWidgets.QApplication.processEvents()
            self.tbConsole.append(f"Docelowy GPKG: {gpkg_path}")
            QtWidgets.QApplication.processEvents()

            if os.path.exists(gpkg_path):
                try:
                    os.remove(gpkg_path)
                    self.tbConsole.append(f"Usunięto istniejący plik: {gpkg_path}")
                    QtWidgets.QApplication.processEvents()
                except Exception as e:
                    self.tbConsole.append(f"Nie udało się usunąć GPKG:\n{e}\n")
                    QtWidgets.QApplication.processEvents()
                    continue

            layer = QgsVectorLayer(gml_path, "input", "ogr")
            if not layer.isValid():
                self.tbConsole.append(f"Nie można wczytać warstwy: {base}\n")
                QtWidgets.QApplication.processEvents()
                continue

            fields_to_delete = fields_per_rule.get(matched_pattern, [])
            all_fields = layer.fields().names()
            fields_to_keep = [f for f in all_fields if f not in fields_to_delete]

            geom_type = layer.wkbType()
            crs = layer.crs()
            mem_layer = QgsVectorLayer(f"{QgsWkbTypes.displayString(geom_type)}?crs={crs.authid()}", layer_name_in_gpkg, "memory")
            mem_provider = mem_layer.dataProvider()
            mem_provider.addAttributes([layer.fields()[layer.fields().indexFromName(f)] for f in fields_to_keep])
            mem_layer.updateFields()

            feats = []
            for feat in layer.getFeatures():
                new_feat = QgsFeature(mem_layer.fields())
                for f in fields_to_keep:
                    new_feat[f] = feat[f]
                new_feat.setGeometry(feat.geometry())
                feats.append(new_feat)
            mem_provider.addFeatures(feats)
            mem_layer.updateExtents()

            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "GPKG"
            options.layerName = layer_name_in_gpkg
            options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteFile
            options.encoding = "UTF-8"

            error = QgsVectorFileWriter.writeAsVectorFormatV2(
                mem_layer,
                gpkg_path,
                QgsProject.instance().transformContext(),
                options
            )

            if error[0] != QgsVectorFileWriter.NoError:
                self.tbConsole.append(f"Błąd zapisu GPKG: {error}\n")
                QtWidgets.QApplication.processEvents()
                continue

            self.tbConsole.append(f"Utworzono GPKG: {gpkg_path} z usuniętymi polami")
            QtWidgets.QApplication.processEvents()

            try:
                conn = sqlite3.connect(gpkg_path)
                conn.execute("VACUUM;")
                conn.close()
                self.tbConsole.append("GPKG zoptymalizowany (VACUUM).")
                QtWidgets.QApplication.processEvents()
            except Exception as e:
                self.tbConsole.append(f"Nie udało się wykonać VACUUM:\n{e}")
                QtWidgets.QApplication.processEvents()

            pct = int(((i + 1) / total) * 100)
            self.progressBar.setValue(pct)
            QtWidgets.QApplication.processEvents()

            self.tbConsole.append("Operacja zakończona.\n")
            QtWidgets.QApplication.processEvents()

    def build_filter_geometry(self) -> QgsGeometry | None:
        layer = self.layer_area_2180()
        if not layer or layer.featureCount() == 0:
            return None

        buffer_value = self.sbBufferValue.value()
        geoms = []

        for f in layer.getFeatures():
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            if buffer_value > 0:
                g = g.buffer(buffer_value, 5)
            geoms.append(g)

        if not geoms:
            return None

        return QgsGeometry.unaryUnion(geoms)

    def list_gpkg_layers_file(self, gpkg_path: str) -> set[str]:
        layers: set[str] = set()

        if not gpkg_path or not os.path.isfile(gpkg_path):
            return layers

        provider = QgsProviderRegistry.instance().providerMetadata("ogr")
        sublayers = provider.querySublayers(gpkg_path)

        for sub in sublayers:
            name = sub.name()
            if name:
                layers.add(name)

        return layers

    def import_layers(
        self,
        source_files: list[str],
        target_gpkg: str,
        layer_suffix: str,):
        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak geometrii filtrującej.")
            return

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        existing_layers = self.list_gpkg_layers_file(target_gpkg)

        total = len(source_files)
        if total == 0:
            self.tbConsole.append("Brak plików do importu.")
            return

        self.progressBar.setValue(0)

        for i, path in enumerate(source_files, start=1):
            base = os.path.basename(path)
            layer_name = os.path.splitext(base)[0] + layer_suffix

            if layer_name in existing_layers:
                self.tbConsole.append(f"Pominięto (istnieje): {layer_name}")
                continue

            layer = QgsVectorLayer(path, "src", "ogr")
            if not layer.isValid():
                self.tbConsole.append(f"Błąd wczytania: {base}")
                continue

            request = QgsFeatureRequest()
            request.setFilterRect(bbox)

            matching_features: list[QgsFeature] = []

            for f in layer.getFeatures(request):
                g = f.geometry()
                if g and engine.intersects(g.constGet()):
                    matching_features.append(f)

            if not matching_features:
                self.tbConsole.append(f"Pominięto (brak przecięć): {layer_name}. \n")
                continue

            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "GPKG"
            options.layerName = layer_name
            options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
            options.encoding = "UTF-8"

            writer = QgsVectorFileWriter.create(
                target_gpkg,
                layer.fields(),
                layer.wkbType(),
                layer.crs(),
                QgsProject.instance().transformContext(),
                options
            )

            for f in matching_features:
                writer.addFeature(f)

            del writer

            self.tbConsole.append(
                f"Dodano {len(matching_features)} obiektów → {layer_name}"
            )

            if i % 3 == 0:
                self.progressBar.setValue(int(i / total * 100))
                QtWidgets.QApplication.processEvents()

        self.progressBar.setValue(100)
        self.tbConsole.append("Import zakończony.\n")

    def import_filtered_layers(self, layers_config: dict):
        resource_base = self.resource_path.filePath()
        project_gpkg = self.project_path.filePath()

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        files: list[str] = []

        for src, subfolders in layers_config.items():
            if src.lower().endswith(".gpkg"):
                files.append(os.path.join(resource_base, *subfolders, src))
            else:
                folder = os.path.join(resource_base, *subfolders)
                if not os.path.exists(folder):
                    continue
                files.extend(
                    os.path.join(folder, f)
                    for f in os.listdir(folder)
                    if f.lower().endswith((".gpkg", ".shp"))
                )

        self.import_layers(files, project_gpkg, suffix)

    def import_all_updated_data(self):
        base = os.path.join(self.resource_path.filePath(), "DANE_AKTUALIZOWANE")
        files = [
            os.path.join(root, f)
            for root, _, fs in os.walk(base)
            for f in fs if f.lower().endswith((".gpkg", ".shp"))
        ]

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        self.import_layers(files, self.project_path.filePath(), suffix)

    def import_all_wody_data(self):
        base = os.path.join(self.resource_path.filePath(), "DANE_PGW_GZWP")
        files = [
            os.path.join(root, f)
            for root, _, fs in os.walk(base)
            for f in fs if f.lower().endswith((".gpkg", ".shp"))
        ]

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        self.import_layers(files, self.project_path.filePath(), suffix)

    def import_all_powodz_data(self):
        base = os.path.join(self.resource_path.filePath(), "DANE_POWODZ")
        files = [
            os.path.join(root, f)
            for root, _, fs in os.walk(base)
            for f in fs if f.lower().endswith((".gpkg", ".shp"))
        ]

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        self.import_layers(files, self.project_path.filePath(), suffix)

    def populate_bdot_table(self):
        table = self.table_bdot
        table.clear()
        table.setRowCount(0)
        table.setColumnCount(2)
        table.setHorizontalHeaderLabels(["Import", "Warstwa"])

        base_dir = os.path.join(
            self.resource_path.filePath(),
            "DANE_BDOT"
        )

        if not os.path.isdir(base_dir):
            self.tbConsole.append("Brak katalogu DANE_BDOT.")
            return

        row = 0

        for filename in sorted(os.listdir(base_dir)):
            if not filename.lower().endswith(".gpkg"):
                continue

            name = os.path.splitext(filename)[0]  # OT_BUHD_A
            parts = name.split("_")

            # base BDOT code (OT_BUHD)
            base_code = "_".join(parts[:2]) if len(parts) > 2 else parts[0]

            if base_code not in self.BDOT_LAYERS:
                continue

            # geometry suffix
            geom_suffix = ""
            if parts[-1] in ("A", "L", "P"):
                geom_suffix = f"_{parts[-1]}"

            display_name = self.BDOT_LAYERS[base_code] + geom_suffix

            table.insertRow(row)

            chk = QTableWidgetItem()
            chk.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
            chk.setCheckState(Qt.Unchecked)

            label = QTableWidgetItem(display_name)
            label.setData(Qt.UserRole, filename)

            table.setItem(row, 0, chk)
            table.setItem(row, 1, label)

            row += 1

        table.resizeColumnsToContents()
        table.horizontalHeader().setStretchLastSection(True)

        self.tbConsole.append(f"Załadowano {row} warstw BDOT.")

    def get_matching_teryt_codes(self) -> set[str]:
        area = self.layer_area_2180()
        if not area:
            return set()

        powiat_path = os.path.join(
            self.resource_path.filePath(),
            "DANE_BDOT/HELP",
            "POWIAT_TERYT.gpkg"
        )

        layer = QgsVectorLayer(powiat_path, "powiat", "ogr")
        if not layer.isValid():
            self.tbConsole.append("Nie można wczytać POWIAT_TERYT.")
            return set()

        geom = self.build_filter_geometry()
        bbox = geom.boundingBox()

        engine = QgsGeometry.createGeometryEngine(geom.constGet())
        engine.prepareGeometry()

        request = QgsFeatureRequest().setFilterRect(bbox)

        teryt = set()
        for f in layer.getFeatures(request):
            g = f.geometry()
            if g and engine.intersects(g.constGet()):
                teryt.add(str(f["JPT_KOD_JE"]))

        return teryt

    def import_selected_bdot_layers(self):
        project_gpkg = self.project_path.filePath()
        if not project_gpkg:
            self.tbConsole.append("Brak project_path.")
            return

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak geometrii filtrującej.")
            return

        teryt_codes = self.get_matching_teryt_codes()
        if not teryt_codes:
            self.tbConsole.append("Brak dopasowanych TERYT.")
            return

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        base = os.path.join(self.resource_path.filePath(), "DANE_BDOT")

        for row in range(self.table_bdot.rowCount()):
            if self.table_bdot.item(row, 0).checkState() != Qt.Checked:
                continue

            fn = self.table_bdot.item(row, 1).data(Qt.UserRole)
            src = os.path.join(base, fn)
            out_name = self.table_bdot.item(row, 1).text() + suffix

            layer = QgsVectorLayer(src, "src", "ogr")
            if not layer.isValid():
                self.tbConsole.append(f"Błąd: {fn}")
                continue

            req = QgsFeatureRequest()
            req.setFilterRect(bbox)
            req.setSubsetOfAttributes(layer.fields().names(), layer.fields())

            feats = []
            for f in layer.getFeatures(req):
                if str(f["TERYT"]) not in teryt_codes:
                    continue
                g = f.geometry()
                if g and engine.intersects(g.constGet()):
                    feats.append(f)

            if not feats:
                self.tbConsole.append(f"Pominięto {out_name} – brak obiektów.")
                continue

            opts = QgsVectorFileWriter.SaveVectorOptions()
            opts.driverName = "GPKG"
            opts.layerName = out_name
            opts.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
            opts.encoding = "UTF-8"

            writer = QgsVectorFileWriter.create(
                project_gpkg,
                layer.fields(),
                layer.wkbType(),
                layer.crs(),
                QgsProject.instance().transformContext(),
                opts
            )

            for f in feats:
                writer.addFeature(f)
            del writer

            self.tbConsole.append(f"Dodano {len(feats)} → {out_name}")

        self.tbConsole.append("BDOT import zakończony.\n")
    
    def uncheck_all_bdot(self):
        table = self.table_bdot

        for row in range(table.rowCount()):
            item = table.item(row, 0)
            if item is not None:
                item.setCheckState(Qt.Unchecked)

    def layout_area_gen(self):
        self.tbConsole.append("Rozpoczynam generowanie zasięgów układów...")

        target_crs = QgsCoordinateReferenceSystem("EPSG:2180")
        context = QgsProject.instance().transformContext()

        layout_manager = QgsProject.instance().layoutManager()
        layouts = layout_manager.printLayouts()

        if not layouts:
            self.tbConsole.append("Brak układów w projekcie. Nie dodano żadnych warstw.")
            if self.progressBar:
                self.progressBar.setValue(0)
            return

        total = len(layouts)
        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        unique_extents = []
        created_layers = 0

        for idx, layout in enumerate(layouts, start=1):

            layout_name = layout.name()
            self.tbConsole.append(f"Przetwarzanie układu: {layout_name}")

            map_item = None
            for item in layout.items():
                if isinstance(item, QgsLayoutItemMap) and item.id() in ['Mapa 1', 'Map 1']:
                    map_item = item
                    break

            if map_item is None:
                self.tbConsole.append(f"  Układ pominięty – brak elementu mapy 'Mapa 1' / 'Map 1'.")
                self.progressBar.setValue(idx)
                continue

            extent = map_item.extent()
            source_crs = map_item.crs()
            transform = QgsCoordinateTransform(source_crs, target_crs, context)

            try:
                transformed_extent = transform.transformBoundingBox(extent)
            except Exception as e:
                self.tbConsole.append(f"  Błąd transformacji zasięgu: {e}")
                self.progressBar.setValue(idx)
                continue

            if any(transformed_extent == existing for existing in unique_extents):
                self.tbConsole.append("  Pominięto — zasięg duplikat.")
                self.progressBar.setValue(idx)
                continue

            unique_extents.append(transformed_extent)

            polygon_geom = QgsGeometry.fromRect(transformed_extent)

            layer = QgsVectorLayer(
                "Polygon?crs=EPSG:2180",
                f"Zasięg - {layout_name}",
                "memory"
            )

            provider = layer.dataProvider()
            provider.addAttributes([QgsField("nazwa", QVariant.String)])
            layer.updateFields()

            feature = QgsFeature(layer.fields())
            feature.setGeometry(polygon_geom)
            feature.setAttribute("nazwa", layout_name)
            provider.addFeature(feature)

            QgsProject.instance().addMapLayer(layer)

            created_layers += 1
            self.tbConsole.append(f"Dodano warstwę: Zasięg - {layout_name}")

            self.progressBar.setValue(idx)

        if created_layers == 0:
            self.tbConsole.append("Nie dodano żadnych nowych warstw — brak unikalnych zasięgów.")
        else:
            self.tbConsole.append(f"Zakończono.")

    def pog_numeracja(self):
        self.tbConsole.append("Rozpoczynam numerację obiektów POG...")

        layer = self.iface.activeLayer()
        if not layer:
            self.tbConsole.append("Brak aktywnej warstwy. Wybierz warstwę i spróbuj ponownie.")
            if self.progressBar:
                self.progressBar.setValue(0)
            return

        symbol_field = "symbol"
        oznaczenie_field = "oznaczenie"
        lokalny_field = "lokalnyId"

        if symbol_field not in layer.fields().names():
            self.tbConsole.append(f"Brak wymaganej kolumny '{symbol_field}'.")
            return
        if oznaczenie_field not in layer.fields().names():
            self.tbConsole.append(f"Brak pola '{oznaczenie_field}' do zapisu numeracji.")
            return
        if lokalny_field not in layer.fields().names():
            self.tbConsole.append(f"Brak pola '{lokalny_field}' do zapisu ID lokalnego.")
            return

        unique_symbols = list(layer.uniqueValues(layer.fields().lookupField(symbol_field)))

        if not unique_symbols:
            self.tbConsole.append("Brak unikalnych wartości w kolumnie 'symbol'.")
            return

        self.tbConsole.append(f"Znaleziono {len(unique_symbols)} unikalnych symboli: {unique_symbols}")

        self.progressBar.setMaximum(len(unique_symbols))
        self.progressBar.setValue(0)

        layer.startEditing()

        processed_symbols = 0
        total_numbered = 0

        for idx, symbol in enumerate(unique_symbols, start=1):

            self.tbConsole.append(f"Przetwarzanie symbolu: {symbol}")

            request = QgsFeatureRequest(QgsExpression(f'"{symbol_field}" = \'{symbol}\''))
            features = [f for f in layer.getFeatures(request)
                        if f.geometry() and not f.geometry().isEmpty()]

            if not features:
                self.tbConsole.append("  Brak obiektów z tym symbolem – pomijam.")
                self.progressBar.setValue(idx)
                continue

            if len(features) < 2:
                self.tbConsole.append("  Za mało obiektów do wyznaczenia kolejności – pomijam.")
                self.progressBar.setValue(idx)
                continue

            start_feature = min(features, key=lambda f: (
                f.geometry().centroid().asPoint().x(),
                f.geometry().centroid().asPoint().y()
            ))

            visited = [start_feature]
            features.remove(start_feature)
            current_feature = start_feature

            while features:
                current_pt = current_feature.geometry().centroid().asPoint()
                next_feature = min(
                    features,
                    key=lambda f: current_pt.sqrDist(f.geometry().centroid().asPoint())
                )
                visited.append(next_feature)
                features.remove(next_feature)
                current_feature = next_feature

            for i, feature in enumerate(visited, start=1):
                oznaczenie_value = f"{i}{symbol}"
                lokalnyId_value = f"1POG-{oznaczenie_value}"

                feature.setAttribute(oznaczenie_field, oznaczenie_value)
                feature.setAttribute(lokalny_field, lokalnyId_value)
                layer.updateFeature(feature)

            processed_symbols += 1
            total_numbered += len(visited)

            self.tbConsole.append(
                f"  Znumerowano {len(visited)} obiektów dla symbolu {symbol}."
            )

            self.progressBar.setValue(idx)

        if processed_symbols == 0:
            self.tbConsole.append("Nie wykonano numeracji – żadna grupa nie spełniała wymagań.")
        else:
            self.tbConsole.append(
                f"Zakończono numerację. Przetworzono {processed_symbols} symboli, "
                f"znumerowano {total_numbered} obiektów."
            )

    def pog_korekta_profilu(self):
        self.tbConsole.append("Rozpoczynam korektę profilu podstawowego...")

        symbol_to_profile = {
            "SW": "teren zabudowy mieszkaniowej wielorodzinnej,teren usług,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SJ": "teren zabudowy mieszkaniowej jednorodzinnej,teren usług,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SZ": "teren zabudowy zagrodowej,teren produkcji w gospodarstwach rolnych,teren akwakultury i obsługi rybactwa,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SU": "teren usług,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SH": "teren handlu wielkopowierzchniowego,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SP": "teren produkcji,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SR": "teren produkcji w gospodarstwach rolnych,teren wielkotowarowej produkcji rolnej,teren akwakultury i obsługi rybactwa,teren komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SI": "teren infrastruktury technicznej,teren komunikacji,teren ogrodów działkowych",
            "SN": "teren zieleni urządzonej,teren plaży,teren wód,teren komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SC": "teren cmentarza,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SG": "teren górnictwa i wydobycia,teren komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SO": "teren rolnictwa z zakazem zabudowy,teren lasu,teren zieleni naturalnej,teren wód,teren komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SK": "teren autostrady,teren drogi ekspresowej,teren drogi głównej ruchu przyspieszonego,teren drogi głównej,teren komunikacji kolejowej i szynowej,teren komunikacji kolei linowej,teren komunikacji wodnej,teren komunikacji lotniczej,teren obsługi komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej"
        }

        layer = self.iface.activeLayer()
        if not layer:
            self.tbConsole.append("Brak aktywnej warstwy.")
            return

        fields = layer.fields()
        if "symbol" not in fields.names() or "profilPodstawowy" not in fields.names():
            self.tbConsole.append("Brak wymaganych pól.")
            return

        symbol_idx = fields.indexFromName("symbol")
        profile_idx = fields.indexFromName("profilPodstawowy")

        features = list(layer.getFeatures())
        total = len(features)
        if total == 0:
            self.tbConsole.append("Warstwa nie zawiera obiektów.")
            return

        changes = {}

        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        for i, f in enumerate(features, start=1):
            expected = symbol_to_profile.get(f[symbol_idx])
            if expected and f[profile_idx] != expected:
                changes[f.id()] = {profile_idx: expected}
            self.progressBar.setValue(i)

        if changes:
            layer.startEditing()
            layer.dataProvider().changeAttributeValues(changes)
            layer.commitChanges()
            self.tbConsole.append(f"Zaktualizowano {len(changes)} obiektów.")
        else:
            self.tbConsole.append("Nie dokonano żadnych zmian.")

    def pog_korekta_spacje(self):
        self.tbConsole.append("Rozpoczynam korektę spacji w kolumnach...")

        layer = self.iface.activeLayer()
        if not layer:
            self.tbConsole.append("Brak aktywnej warstwy. Wybierz warstwę i spróbuj ponownie.")
            self.progressBar.setValue(0)
            return

        columns_to_process = ["profilPodstawowy", "profilDodatkowy"]
        for col in columns_to_process:
            if col not in layer.fields().names():
                self.tbConsole.append(f"Brak wymaganego pola '{col}'. Operacja przerwana.")
                return

        features = list(layer.getFeatures())
        total = len(features)
        if total == 0:
            self.tbConsole.append("Warstwa nie zawiera obiektów – nic do korekty.")
            self.progressBar.setValue(0)
            return

        field_indexes = {c: layer.fields().indexFromName(c) for c in columns_to_process}
        changes = {}

        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        for idx, f in enumerate(features, start=1):
            fid = f.id()
            attr_changes = {}

            for col in columns_to_process:
                val = f[col]
                if isinstance(val, str):
                    new_val = val.replace(" ,", ",").replace(", ", ",").rstrip().replace("\xa0", " ").replace("\n", "")
                    if new_val != val:
                        attr_changes[field_indexes[col]] = new_val

            if attr_changes:
                changes[fid] = attr_changes

            self.progressBar.setValue(idx)

        if changes:
            layer.startEditing()
            layer.dataProvider().changeAttributeValues(changes)
            layer.commitChanges()
            self.tbConsole.append(f"Zakończono korektę spacji. Zaktualizowano {len(changes)} obiektów.")
        else:
            self.tbConsole.append("Nie dokonano żadnych zmian – wszystkie wartości były poprawne.")

    def pog_zgodnosc(self):
        self.tbConsole.append("Analiza zgodności POG z MPZP - start")
        mpzp_layer = self.mpzp_layer.currentLayer()
        pog_layer = self.pog_layer.currentLayer()
        symbol_col = self.cb_mpzp_symbol_col.currentText()

        if not mpzp_layer or not pog_layer or not symbol_col:
            self.tbConsole.append("Brak warstw lub kolumny symbolu MPZP")
            return

        if mpzp_layer.crs() != pog_layer.crs():
            context = QgsProject.instance().transformContext()
            transform = QgsCoordinateTransform(mpzp_layer.crs(), pog_layer.crs(), context)

            mpzp_mem = QgsVectorLayer(
                f"{QgsWkbTypes.displayString(mpzp_layer.wkbType())}?crs={pog_layer.crs().authid()}",
                f"{mpzp_layer.name()}_reproj",
                "memory"
            )
            prov = mpzp_mem.dataProvider()
            prov.addAttributes(mpzp_layer.fields())
            mpzp_mem.updateFields()

            feats = []
            for f in mpzp_layer.getFeatures():
                g = f.geometry()
                if not g or g.isEmpty():
                    continue
                g = QgsGeometry(g)
                g.transform(transform)

                nf = QgsFeature(mpzp_mem.fields())
                nf.setAttributes(f.attributes())
                nf.setGeometry(g)
                feats.append(nf)

            if not feats:
                self.tbConsole.append("Brak geometrii MPZP po transformacji")
                return

            prov.addFeatures(feats)
            mpzp_mem.updateExtents()
            mpzp_layer = mpzp_mem

        out_layer = QgsVectorLayer(
            "Polygon?crs=" + pog_layer.crs().authid(),
            "Niezgodności",
            "memory"
        )
        out_prov = out_layer.dataProvider()
        out_prov.addAttributes([
            QgsField(symbol_col, QVariant.String),
            QgsField("profilPodstawowy", QVariant.String),
            QgsField("profilDodatkowy", QVariant.String),
            QgsField("symbol", QVariant.String),
        ])
        out_layer.updateFields()

        pog_index = QgsSpatialIndex(pog_layer.getFeatures())

        total = mpzp_layer.featureCount()
        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        RULES = {
            "MN":  [("PP", "teren zabudowy mieszkaniowej jednorodzinnej"),
                    ("PD", "teren zabudowy mieszkaniowej jednorodzinnej")],
            "MNW": [("PP", "teren zabudowy mieszkaniowej jednorodzinnej"),
                    ("PD", "teren zabudowy mieszkaniowej jednorodzinnej")],
            "MNB": [("PP", "teren zabudowy mieszkaniowej jednorodzinnej"),
                    ("PD", "teren zabudowy mieszkaniowej jednorodzinnej")],
            "MNS": [("PP", "teren zabudowy mieszkaniowej jednorodzinnej"),
                    ("PD", "teren zabudowy mieszkaniowej jednorodzinnej")],
            "MW":  [("PP", "teren zabudowy mieszkaniowej wielorodzinnej")],
            "MWK": [("PP", "teren zabudowy mieszkaniowej wielorodzinnej")],
            "MWW": [("PP", "teren zabudowy mieszkaniowej wielorodzinnej")],
            "ML":  [("PD", "teren zabudowy letniskowej lub rekreacji indywidualnej")],
            
            "U":   [("PP", "teren usług"), ("PD", "teren usług")],
            "UH":  [("PP", "teren usług"), ("PD", "teren usług")],
            "UHD": [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług handlu detalicznego")],
            "UHH": [("PP", "teren usług"), ("PD", "teren usług")],
            "UW":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren handlu wielkopowierzchniowego"), ("PP", "teren handlu wielkopowierzchniowego")],
            "UL":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług rzemieślniczych")],
            "UT":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług turystyki")],
            "UG":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług gastronomii")],
            "UZ":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług zdrowia i pomocy społecznej")],
            "UN":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług nauki")],
            "UE":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług edukacji")],
            "UEP": [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług edukacji")],
            "UEO": [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług edukacji")],
            "US":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług sportu i rekreacji")],
            "UK":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług kultury i rozrywki")],
            "UR":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług kultu religijnego")],
            "UB":  [("PP", "teren usług"), ("PD", "teren usług")],
            "UA":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług biurowych i administracji")],
            "UAB": [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług biurowych i administracji")],
            "UAA": [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług biurowych i administracji")],

            "P":   [("PP", "teren produkcji"), ("PD", "teren produkcji")],
            "PP":  [("PP", "teren produkcji"), ("PD", "teren produkcji")],
            "PE":  [("PP", "teren produkcji"), ("PD", "teren produkcji"), 
                    ("PD", "teren elektrowni wiatrowej"), ("PD", "teren elektrowni słonecznej"),
                    ("PD", "teren elektrowni geotermalnej"), ("PD", "teren elektrowni wodnej"), 
                    ("PD", "teren biogazowni")],
            "PEW": [("PP", "teren produkcji"), ("PD", "teren produkcji"), ("PD", "teren elektrowni wiatrowej")],
            "PEF": [("PP", "teren produkcji"), ("PD", "teren produkcji"), ("PD", "teren elektrowni słonecznej")],
            "PS":  [("PP", "teren produkcji"), ("PD", "teren produkcji"), ("PD", "teren składów i magazynów")],
            "PR":  [("PP", "teren produkcji"), ("PD", "teren produkcji")],

            "G":   [("PP", "teren górnictwa i wydobycia")],

            "RN":  [("PP", "teren rolnictwa z zakazem zabudowy"), ("PD", "teren rolnictwa z zakazem zabudowy")],
            "RNR": [("PP", "teren rolnictwa z zakazem zabudowy"), ("PD", "teren rolnictwa z zakazem zabudowy")],
            "RNL": [("PP", "teren rolnictwa z zakazem zabudowy"), ("PD", "teren rolnictwa z zakazem zabudowy")],
            "RZ":  [("PP", "teren zabudowy zagrodowej"), ("PD", "teren wielkotowarowej produkcji rolnej")],
            "RZM": [("PP", "teren zabudowy zagrodowej")],
            "RZP": [("PP", "teren produkcji w gospodarstwach rolnych")],
            "RZW": [("PP", "teren wielkotowarowej produkcji rolnej"), ("PD", "teren wielkotowarowej produkcji rolnej")],
            "RA":  [("PP", "teren akwakultury i obsługi rybactwa")],

            "W":   [("PP", "teren wód"), ("PD", "teren wód")],
            "WM":  [("PP", "teren wód"), ("PD", "teren wód")],
            "WS":  [("PP", "teren wód"), ("PD", "teren wód")],

            "L":   [("PP", "teren lasu"), ("PD", "teren lasu")],

            "Z":   [("PP", "teren plaży")],
            "ZN":  [("PP", "teren zieleni naturalnej"), ("PD", "teren zieleni naturalnej")],
            "ZP":  [("PP", "teren zieleni urządzonej"), ("PD", "teren zieleni urządzonej")],
            "ZPW": [("PP", "teren zieleni urządzonej"), ("PD", "teren zieleni urządzonej")],
            "ZPN": [("PP", "teren zieleni urządzonej"), ("PD", "teren zieleni urządzonej")],
            "ZB":  [("PP", "teren plaży")],

            "C":   [("PP", "teren cmentarza")],
            "CC":  [("PP", "teren cmentarza")],
            "CZ":  [("PP", "teren cmentarza")],
        }

        def always_match(sym):
            return sym == "ZD" or sym.startswith("K") or sym.startswith("I")

        def never_match(sym):
            return sym == "M"

        def check_symbol(sym, pp, pd):
            if sym == "RZ":
                for where, txt in RULES[sym]:
                    if where == "PP" and (not pp or txt not in pp):
                        return False
                    if where == "PD" and (not pd or txt not in pd):
                        return False
                return True
            elif sym == "PE":
                if pp and "teren produkcji" in pp:
                    return True
                if pd and "teren produkcji" in pd:
                    return True
                energy_types = [
                    "teren elektrowni wiatrowej",
                    "teren elektrowni słonecznej",
                    "teren elektrowni geotermalnej",
                    "teren elektrowni wodnej",
                    "teren biogazowni"
                ]
                if pd:
                    if all(et in pd for et in energy_types):
                        return True
                return False

            if always_match(sym):
                return True
            if never_match(sym):
                return False
            if sym not in RULES:
                return False

            for where, txt in RULES[sym]:
                if where == "PP" and pp and txt in pp:
                    return True
                if where == "PD" and pd and txt in pd:
                    return True
            return False

        for i, mpzp_f in enumerate(mpzp_layer.getFeatures()):
            self.progressBar.setValue(i + 1)

            geom = mpzp_f.geometry()
            if not geom or geom.isEmpty():
                continue

            raw = mpzp_f[symbol_col]
            if not raw:
                continue

            raw = str(raw)
            raw = raw.lstrip("0123456789")
            symbols = raw.split("-")

            pog_ids = pog_index.intersects(geom.boundingBox())
            for pid in pog_ids:
                pog_f = pog_layer.getFeature(pid)
                pog_geom = pog_f.geometry()
                if not pog_geom or not geom.intersects(pog_geom):
                    continue

                inter = geom.intersection(pog_geom)
                if not inter or inter.isEmpty():
                    continue

                pp = pog_f["profilPodstawowy"]
                pd = pog_f["profilDodatkowy"]
                pog_sym = pog_f["symbol"] if "symbol" in pog_f.fields().names() else None

                failed = False
                for s in symbols:
                    if not check_symbol(s, pp, pd):
                        failed = True
                        break

                if failed:
                    nf = QgsFeature(out_layer.fields())
                    nf.setGeometry(inter)
                    nf.setAttributes([raw, pp, pd, pog_sym])
                    out_prov.addFeature(nf)

        out_layer.updateExtents()
        QgsProject.instance().addMapLayer(out_layer)

        self.tbConsole.append("Analiza zgodności POG z MPZP - koniec\n")

    def style_save_single(self):
        self.progressBar.reset()
        self.progressBar.setValue(0)
        self.tbConsole.append("Rozpoczynam zapisywanie stylu aktywnej warstwy...")

        layer = self.iface.activeLayer()

        if not layer:
            self.tbConsole.append("Brak aktywnej warstwy. Operacja przerwana.")
            self.progressBar.setValue(0)
            return

        if layer.type() != QgsMapLayerType.VectorLayer:
            self.tbConsole.append(f"Warstwa '{layer.name()}' nie jest warstwą wektorową.")
            self.progressBar.setValue(0)
            return

        layer_name = layer.name()

        try:
            layer.saveStyleToDatabase(
                layer_name,
                "",
                True,
                "",
                QgsMapLayer.AllStyleCategories
            )

            layer.triggerRepaint()

            self.progressBar.setValue(100)
            self.tbConsole.append(f"Zapisano styl warstwy '{layer_name}'.")

        except Exception as e:
            self.tbConsole.append(f"Błąd podczas zapisywania stylu: {str(e)}")
            self.progressBar.setValue(0)

    def style_save_all(self):
        reply = QMessageBox.question(
            self,
            "Potwierdzenie",
            "Czy na pewno chcesz zapisać style dla wszystkich warstw wektorowych?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply != QMessageBox.Yes:
            self.tbConsole.append("Operacja anulowana.")
            return

        self.tbConsole.append("Rozpoczynam zapisywanie stylów dla wszystkich warstw...")
        self.progressBar.reset()
        self.progressBar.setValue(0)

        project = QgsProject.instance()
        vector_layers = [
            layer for layer in project.mapLayers().values()
            if layer.type() == QgsMapLayerType.VectorLayer
        ]

        layer_count_total = len(vector_layers)

        if layer_count_total == 0:
            self.tbConsole.append("Brak warstw wektorowych w projekcie — nic do zapisania.")
            return

        self.tbConsole.append(f"Liczba warstw do zapisania: {layer_count_total}")

        self.progressBar.setMaximum(100)

        processed = 0

        for layer in vector_layers:
            layer_name = layer.name()

            try:
                layer.saveStyleToDatabase(
                    layer_name,
                    "",
                    True,
                    "",
                    QgsMapLayer.AllStyleCategories
                )

                layer.triggerRepaint()
                processed += 1

                progress = int((processed / layer_count_total) * 100)
                self.progressBar.setValue(progress)

                self.tbConsole.append(
                    f"[{processed}/{layer_count_total}] Zapisano styl dla: {layer_name}"
                )

            except Exception as e:
                self.tbConsole.append(f"Błąd przy zapisywaniu stylu warstwy '{layer_name}': {str(e)}")

        self.tbConsole.append("Zakończono zapisywanie stylów dla wszystkich warstw.")
        self.progressBar.setValue(100)

    def reset_fid_values(self):
        layer = self.iface.activeLayer()
        if not layer or "fid" not in layer.fields().names():
            self.tbConsole.append("Brak warstwy lub pola 'fid'.")
            return

        idx = layer.fields().indexFromName("fid")
        changes = {}

        for f in layer.getFeatures():
            changes[f.id()] = {idx: f.id()}

        layer.startEditing()
        layer.dataProvider().changeAttributeValues(changes)
        layer.commitChanges()

        self.tbConsole.append("Zresetowano kolumnę fid.")

    def numeracja_pol(self):
        self.tbConsole.append("Rozpoczynam numerację wszystkich obiektów...")

        layer = self.iface.activeLayer()
        if not layer:
            self.tbConsole.append("Brak aktywnej warstwy.")
            return

        field_name = "numeracja"
        if field_name not in layer.fields().names():
            layer.startEditing()
            layer.addAttribute(QgsField(field_name, QVariant.String))
            layer.commitChanges()
            layer.updateFields()

        idx = layer.fields().indexFromName(field_name)

        features = [f for f in layer.getFeatures() if f.geometry() and not f.geometry().isEmpty()]
        if not features:
            self.tbConsole.append("Brak obiektów z geometrią.")
            return

        centroids = {f.id(): f.geometry().centroid().asPoint() for f in features}
        features.sort(key=lambda f: (centroids[f.id()].x(), centroids[f.id()].y()))

        changes = {}
        total = len(features)
        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        for i, f in enumerate(features, start=1):
            changes[f.id()] = {idx: str(i)}
            self.progressBar.setValue(i)

        layer.startEditing()
        layer.dataProvider().changeAttributeValues(changes)
        layer.commitChanges()

        self.tbConsole.append(f"Zakończono numerację {total} obiektów.")

    def numeracja_unikalna(self):
        self.tbConsole.append("Rozpoczynam numerację grup obiektów...")

        layer = self.numeracja_layer.currentLayer()
        if not layer:
            self.tbConsole.append("Brak aktywnej warstwy.")
            return

        group_field = self.cb_numeracja_unikalna.currentText()
        if not group_field or group_field not in layer.fields().names():
            self.tbConsole.append("Nieprawidłowe pole grupujące.")
            return

        num_field = "numeracja"
        if num_field not in layer.fields().names():
            layer.startEditing()
            layer.addAttribute(QgsField(num_field, QVariant.String))
            layer.commitChanges()
            layer.updateFields()

        num_idx = layer.fields().indexFromName(num_field)
        groups = layer.uniqueValues(layer.fields().lookupField(group_field))

        self.progressBar.setMaximum(len(groups))
        self.progressBar.setValue(0)

        layer.startEditing()
        total_numbered = 0

        for i, gval in enumerate(groups, start=1):
            feats = [
                f for f in layer.getFeatures(QgsFeatureRequest(QgsExpression(f'"{group_field}" = \'{gval}\'')))
                if f.geometry() and not f.geometry().isEmpty()
            ]
            if not feats:
                self.progressBar.setValue(i)
                continue

            centroids = {f.id(): f.geometry().centroid().asPoint() for f in feats}
            feats.sort(key=lambda f: (centroids[f.id()].x(), centroids[f.id()].y()))

            changes = {f.id(): {num_idx: str(j)} for j, f in enumerate(feats, start=1)}
            layer.dataProvider().changeAttributeValues(changes)

            total_numbered += len(feats)
            self.progressBar.setValue(i)

        layer.commitChanges()
        self.tbConsole.append(f"Zakończono numerację. Zaktualizowano {total_numbered} obiektów.")

    def import_external(self):
        ref_layer = self.layer_area.currentLayer()
        if not ref_layer or not ref_layer.isValid():
            self.tbConsole.append("Nie wybrano warstwy referencyjnej.")
            return

        buffer_value = self.sbBufferValue.value()

        project_gpkg = self.project_path.filePath()
        if not project_gpkg:
            self.tbConsole.append("Nie ustawiono ścieżki do projektu.")
            return

        src_path = self.import_external_path.filePath()
        if not src_path or not os.path.exists(src_path):
            self.tbConsole.append("Nie wybrano poprawnej warstwy źródłowej.")
            return

        input_layer = QgsVectorLayer(src_path, "input", "ogr")
        if not input_layer.isValid():
            self.tbConsole.append("Nie można wczytać warstwy wejściowej.")
            return
        input_crs = input_layer.crs()

        if not input_crs.isValid():
            chosen_crs = self.crs_import_filter_widget.crs()
            if not chosen_crs.isValid():
                self.tbConsole.append(
                    "Warstwa importowana ma nieznany CRS. "
                    "Wybierz CRS i uruchom ponownie."
                )
                return

            input_layer.setCrs(chosen_crs)
            input_crs = chosen_crs
            self.tbConsole.append(f"Ustawiono CRS: {input_crs.authid()}")

        self.crs_import_filter_widget.setCrs(QgsCoordinateReferenceSystem())

        need_transform = ref_layer.crs() != input_crs
        if need_transform:
            xform = QgsCoordinateTransform(
                ref_layer.crs(),
                input_crs,
                QgsProject.instance()
            )
        self.tbConsole.append("Budowanie indeksu przestrzennego…")
        QtWidgets.QApplication.processEvents()

        index = QgsSpatialIndex()
        ref_geoms = {}

        for f in ref_layer.getFeatures():
            geom = f.geometry()
            if not geom:
                continue

            geom = QgsGeometry(geom)

            if need_transform:
                geom.transform(xform)

            if buffer_value > 0:
                geom = geom.buffer(buffer_value, 5)
            idx_feat = QgsFeature()
            idx_feat.setId(f.id())
            idx_feat.setGeometry(geom)

            index.addFeature(idx_feat)
            ref_geoms[f.id()] = geom

        if not ref_geoms:
            self.tbConsole.append("Warstwa referencyjna nie zawiera geometrii.")
            return

        custom_name = self.te_import_external_name.text().strip()
        base_name = os.path.splitext(os.path.basename(src_path))[0]
        layer_name = custom_name if custom_name else base_name

        if buffer_value > 0:
            layer_name += f"_bufor{buffer_value}"

        if self.cb_date_suffix.isChecked():
            layer_name += "_" + datetime.now().strftime("%Y_%m_%d")

        self.tbConsole.append(f"Import: {layer_name}")
        QtWidgets.QApplication.processEvents()
        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = "GPKG"
        options.layerName = layer_name
        options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
        options.encoding = "UTF-8"

        writer = QgsVectorFileWriter.create(
            project_gpkg,
            input_layer.fields(),
            input_layer.wkbType(),
            input_layer.crs(),
            QgsProject.instance().transformContext(),
            options
        )

        if writer.hasError() != QgsVectorFileWriter.NoError:
            self.tbConsole.append(writer.errorMessage())
            return

        added = 0

        for f in input_layer.getFeatures():
            geom = f.geometry()
            if not geom:
                continue

            candidate_ids = index.intersects(geom.boundingBox())
            if not candidate_ids:
                continue

            for fid in candidate_ids:
                if geom.intersects(ref_geoms[fid]):
                    writer.addFeature(f)
                    added += 1
                    break
        del writer
        if added == 0:
            self.tbConsole.append(f"Pominięto {layer_name} – brak przecięć.")
            return

        self.progressBar.setValue(100)
        self.tbConsole.append(f"Dodano {added} obiektów.")
        self.tbConsole.append("Operacja zakończona.\n")
        
    def import_external_filter(self):
        project_gpkg = self.project_path.filePath()
        if not project_gpkg:
            self.tbConsole.append("Nie ustawiono ścieżki do projektu.")
            return

        src_path = self.import_external_filter_path.filePath()
        if not src_path or not os.path.exists(src_path):
            self.tbConsole.append("Nie wybrano poprawnej warstwy źródłowej.")
            return

        field_name = self.cb_import_external_filter.currentText()
        if not field_name:
            self.tbConsole.append("Nie wybrano kolumny do filtrowania.")
            return

        filter_value = self.le_filter.text().strip()
        if filter_value == "":
            self.tbConsole.append("Nie podano wartości filtra.")
            return

        layer = QgsVectorLayer(src_path, "src", "ogr")
        if not layer.isValid():
            self.tbConsole.append("Nie można wczytać warstwy źródłowej.")
            return

        if field_name not in layer.fields().names():
            self.tbConsole.append(f"Kolumna '{field_name}' nie istnieje.")
            return

        # output name
        base_name = self.te_import_external_filter_name.text().strip()
        if not base_name:
            base_name = os.path.splitext(os.path.basename(src_path))[0]

        if self.cb_date__filter_suffix.isChecked():
            base_name += "_" + datetime.now().strftime("%Y_%m_%d")

        self.tbConsole.append(
            f"Importuję obiekty gdzie {field_name} = '{filter_value}' → {base_name}"
        )
        QtWidgets.QApplication.processEvents()

        safe_value = filter_value.replace("'", "''")
        expr = QgsExpression(f"\"{field_name}\" = '{safe_value}'")

        request = QgsFeatureRequest(expr)
        request.setNoAttributes()
        request.setFlags(QgsFeatureRequest.NoGeometry)

        count = 0
        for _ in layer.getFeatures(request):
            count += 1

        if count == 0:
            self.tbConsole.append("Brak obiektów spełniających warunek.")
            return

        request = QgsFeatureRequest(expr)

        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = "GPKG"
        options.layerName = base_name
        options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
        options.encoding = "UTF-8"

        writer = QgsVectorFileWriter.create(
            project_gpkg,
            layer.fields(),
            layer.wkbType(),
            layer.crs(),
            QgsProject.instance().transformContext(),
            options
        )

        processed = 0
        self.progressBar.setValue(0)

        for f in layer.getFeatures(request):
            writer.addFeature(f)
            processed += 1

            if processed % 200 == 0:
                self.progressBar.setValue(int(processed / count * 100))
                QtWidgets.QApplication.processEvents()

        del writer

        self.progressBar.setValue(100)
        self.tbConsole.append(f"Dodano {processed} obiektów.")
        self.tbConsole.append("Import zakończony.\n")

    def report_intersections(
        self,
        layer: QgsVectorLayer,
        filter_geom: QgsGeometry,
        fields: list[str] | None,
        existence_only: bool = False,) -> int:

        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()
        bbox = filter_geom.boundingBox()

        request = QgsFeatureRequest()
        request.setFilterRect(bbox)

        count = 0

        for f in layer.getFeatures(request):
            g = f.geometry()
            if not g or g.isEmpty():
                continue

            if engine.intersects(g.constGet()):
                count += 1

                if existence_only:
                    return 1

                if fields:
                    vals = []
                    for fld in fields:
                        v = f.attribute(fld)
                        vals.append("" if v is None else str(v))
                    self.tbConsole.append(" | ".join(vals))
                    QtWidgets.QApplication.processEvents()

        return count

    def anal_fop(self):
        self.tbConsole.append("Analiza FOP - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak funkcji w layer_area lub buforze.")
            return

        resource_base = self.resource_path.filePath()

        layers = {
            "DANE_AKTUALIZOWANE/FOP/FOP_ObszaryChronionegoKrajobrazu.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_ObszarySpecjalnejOchrony.gpkg": ["kod", "nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_SpecjalneObszaryOchrony.gpkg": ["kod", "nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_ParkiKrajobrazowe.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_ParkiNarodowe.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_Rezerwaty.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_UzytkiEkologiczne.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_ZespolyPrzyrodniczoKrajobrazowe.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_StanowiskaDokumentacyjne.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_PomnikiPrzyrody_powierzchniowe.gpkg": None,
            "DANE_AKTUALIZOWANE/FOP/FOP_PomnikiPrzyrody_punktowe.gpkg": None,
        }

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        for rel_path, fields in layers.items():
            abs_path = os.path.join(resource_base, rel_path)
            self.tbConsole.append(f"\nWarstwa: {rel_path}")

            if not os.path.exists(abs_path):
                self.tbConsole.append("Plik nie istnieje.")
                continue

            layer = QgsVectorLayer(abs_path, "src", "ogr")
            if not layer.isValid():
                self.tbConsole.append("Nie można wczytać warstwy.")
                continue

            request = QgsFeatureRequest().setFilterRect(bbox)

            matches = []
            for f in layer.getFeatures(request):
                g = f.geometry()
                if g and engine.intersects(g.constGet()):
                    matches.append(f)

            count = len(matches)
            if count == 0:
                self.tbConsole.append("Brak przecięć.")
                continue

            self.tbConsole.append(f"Liczba przecięć: {count}")

            if not fields:
                continue

            is_uzytki = rel_path.endswith("FOP_UzytkiEkologiczne.gpkg")
            if is_uzytki and count > 10:
                self.tbConsole.append("    > 10 obiektów – pominięto listę nazw.")
                continue

            for f in matches:
                vals = [str(f[fld]) for fld in fields if f[fld] is not None]
                if vals:
                    self.tbConsole.append(" | ".join(vals))

        self.tbConsole.append("Analiza FOP - koniec\n")

    def anal_fop_10km(self):
        import os
        from qgis.PyQt import QtWidgets

        self.tbConsole.append("Analiza FOP 10 km - start")
        QtWidgets.QApplication.processEvents()

        area_layer = self.layer_area_2180()
        if not area_layer or area_layer.featureCount() == 0:
            self.tbConsole.append("Brak warstwy obszaru odniesienia.")
            return

        area_geom = None
        for f in area_layer.getFeatures():
            g = f.geometry()
            if g and not g.isEmpty():
                area_geom = g if area_geom is None else area_geom.combine(g)

        if not area_geom:
            self.tbConsole.append("Nie udało się zbudować geometrii obszaru.")
            return

        buffer_geom = area_geom.buffer(10_000, 8)
        bbox = buffer_geom.boundingBox()

        engine_buf = QgsGeometry.createGeometryEngine(buffer_geom.constGet())
        engine_buf.prepareGeometry()

        engine_area = QgsGeometry.createGeometryEngine(area_geom.constGet())
        engine_area.prepareGeometry()

        resource_base = self.resource_path.filePath()
        if not resource_base:
            self.tbConsole.append("Brak ustawionej ścieżki do zasobów.")
            return

        layers = {
            "DANE_AKTUALIZOWANE/FOP/FOP_ObszaryChronionegoKrajobrazu.gpkg": ("Obszar Chronionego Krajobrazu", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_ObszarySpecjalnejOchrony.gpkg": ("Obszar Natura 2000", ["nazwa", "kod"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_SpecjalneObszaryOchrony.gpkg": ("Obszar Natura 2000", ["nazwa", "kod"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_ParkiKrajobrazowe.gpkg": ("Park Krajobrazowy", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_ParkiNarodowe.gpkg": ("Park Narodowy", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_Rezerwaty.gpkg": ("Rezerwat przyrody", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_UzytkiEkologiczne.gpkg": ("Użytek ekologiczny", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_ZespolyPrzyrodniczoKrajobrazowe.gpkg": ("Zespół przyrodniczo-krajobrazowy", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_StanowiskaDokumentacyjne.gpkg": ("Stanowisko dokumentacyjne", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_PomnikiPrzyrody_powierzchniowe.gpkg": ("Pomniki przyrody powierzchniowe", None),
            "DANE_AKTUALIZOWANE/FOP/FOP_PomnikiPrzyrody_punktowe.gpkg": ("Pomniki przyrody punktowe", None),
        }

        angle_ranges = [
            ((337.5, 360.0), "północ"),
            ((0.0, 22.5), "północ"),
            ((22.5, 67.5), "północny wschód"),
            ((67.5, 112.5), "wschód"),
            ((112.5, 157.5), "południowy wschód"),
            ((157.5, 202.5), "południe"),
            ((202.5, 247.5), "południowy zachód"),
            ((247.5, 292.5), "zachód"),
            ((292.5, 337.5), "północny zachód"),
        ]

        def azimuth_label(az):
            az = az % 360
            for (a, b), txt in angle_ranges:
                if a <= az < b:
                    return txt
            return "północ"

        for rel_path, (prefix, fields) in layers.items():
            abs_path = os.path.join(resource_base, rel_path)
            layer_name = os.path.basename(rel_path)

            if not os.path.exists(abs_path):
                continue

            layer = QgsVectorLayer(abs_path, layer_name, "ogr")
            if not layer.isValid():
                continue

            request = QgsFeatureRequest().setFilterRect(bbox)
            matches = []

            for f in layer.getFeatures(request):
                g = f.geometry()
                if g and engine_buf.intersects(g.constGet()):
                    matches.append(f)

            if not matches:
                continue

            if fields is None:
                self.tbConsole.append(f"{prefix}: {len(matches)}")
                continue

            if "UzytkiEkologiczne" in layer_name and len(matches) > 10:
                self.tbConsole.append(f"Użytki ekologiczne: {len(matches)}")
                continue

            for f in matches:
                parts = [prefix]

                for fld in fields:
                    val = f[fld]
                    if val:
                        parts.append(str(val))

                g = f.geometry()

                if engine_area.intersects(g.constGet()):
                    parts.append("- w obszarze")
                else:
                    try:
                        pt = g.centroid().asPoint()
                        # najpierw znajdź najbliższy punkt na granicy obszaru
                        _, p_area, _, _ = area_geom.closestSegmentWithContext(pt)
                        # potem najbliższy punkt na granicy obiektu względem tego punktu
                        _, p_obj, _, _ = g.closestSegmentWithContext(p_area)

                        if p_area and p_obj:
                            # azymut od granicy obszaru do obiektu
                            az = p_area.azimuth(p_obj)
                        else:
                            az = 0
                    except Exception:
                        az = 0

                    az = az % 360

                    dist_km = round(area_geom.distance(g) / 1000, 1)
                    dist_txt = f"{dist_km:.1f}".replace(".", ",")

                    parts.append(f"- {dist_txt} km na {azimuth_label(az)}")

                self.tbConsole.append(" ".join(parts))

        self.tbConsole.append("Analiza FOP 10 km - koniec\n")

    def anal_adm(self):
        self.tbConsole.append("Analiza ADMINISTRACYJNE - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        base = self.resource_path.filePath()

        if not filter_geom:
            self.tbConsole.append("Brak layer_area.")
            return

        layers = {
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_Gminy.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_MorskieLinieBrzegowe.gpkg": None,
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_MorskieWodyWewnetrzne.gpkg": None,
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_Nadlesnictwa.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_ObrebyEwidencyjne.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_PasOchronny.gpkg": None,
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_PasTechniczny.gpkg": None,
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_Powiaty.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_Wojewodztwa.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_ZarzadyZlewni.gpkg": ["ZZ_MIASTO", "RZGW"],
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if fields is None:
                self.tbConsole.append(
                    f"{name}: {'istnieje' if os.path.exists(path) else 'NIE istnieje'}."
                )
                self.progressBar.setValue(int(i / total * 100))
                continue

            if not os.path.exists(path):
                self.tbConsole.append(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.tbConsole.append(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.tbConsole.append(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.tbConsole.append("Analiza ADMINISTRACYJNE zakończona.\n")

    def anal_pig(self):
        self.tbConsole.append("Analiza PIG - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak funkcji w layer_area.")
            return

        base = self.resource_path.filePath()
        layers = {
            "DANE_AKTUALIZOWANE/PIG/PIG_ObszaryGornicze.gpkg": ["NAZWA_OG"],
            "DANE_AKTUALIZOWANE/PIG/PIG_TerenyGornicze.gpkg": ["NAZWA_TG"],
            "DANE_AKTUALIZOWANE/PIG/PIG_UdokumentowaneZloza.gpkg": ["SYMBOL_KOP", "NR_ZLOZA", "NAZWA_ZL"],
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if not os.path.exists(path):
                self.tbConsole.append(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.tbConsole.append(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.tbConsole.append(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.tbConsole.append("Analiza PIG zakończona.\n")

    def anal_wody(self):
        self.tbConsole.append("Analiza WODY - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak funkcji w layer_area.")
            return

        base = self.resource_path.filePath()
        layers = {
            "DANE_PGW_GZWP/WODY_GZWP.gpkg": ["NR_GZWP", "NAZWA"],
            "DANE_PGW_GZWP/WODY_JCWP_pozostale.gpkg": ["MS_KOD", "Nazwa_JCWP"],
            "DANE_PGW_GZWP/WODY_JCWPd.gpkg": ["kod_jcwpd"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_jeziorne.gpkg": ["MS_KOD"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_przejsciowe.gpkg": ["MS_KOD"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_przybrzezne.gpkg": ["MS_KOD"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_rzeczne.gpkg": ["MS_KOD"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_zbiornikowe.gpkg": ["MS_KOD"],
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if not os.path.exists(path):
                self.tbConsole.append(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.tbConsole.append(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.tbConsole.append(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.tbConsole.append("Analiza WODY zakończona.\n")

    def anal_powodz(self):
        self.tbConsole.append("Analiza POWODZ - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak funkcji w layer_area.")
            return

        base = self.resource_path.filePath()
        layers = {
            "DANE_POWODZ/POWODZ_rzeka_10.gpkg": None,
            "DANE_POWODZ/POWODZ_rzeka_100.gpkg": None,
            "DANE_POWODZ/POWODZ_rzeka_500.gpkg": None,
            "DANE_POWODZ/POWODZ_rzeka_WZ.gpkg": None,
            "DANE_POWODZ/POWODZ_morze_100.gpkg": None,
            "DANE_POWODZ/POWODZ_morze_500.gpkg": None,
            "DANE_POWODZ/POWODZ_morze_WZ.gpkg": None,
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if not os.path.exists(path):
                self.tbConsole.append(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.tbConsole.append(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.tbConsole.append(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.tbConsole.append("Analiza POWODZ zakończona.\n")

    def anal_inne(self):
        self.tbConsole.append("Analiza INNE - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak funkcji w layer_area lub buforze.")
            return

        resource_base = self.resource_path.filePath()

        layers = {
            "DANE_INNE/INNE_Mezoregiony.gpkg": ["k_MEZO", "n_MEZO"],
            "DANE_INNE/INNE_PKP_halas_imisja_LDWN.gpkg": ["CATEGORY"],
            "DANE_INNE/INNE_PKP_halas_imisja_LN.gpkg": ["CATEGORY"],
            "DANE_INNE/INNE_Potencjalna_roslinnosc_naturalna.gpkg": ["kod", "nazwa_PL"],
            "DANE_INNE/INNE_Torfowiska_alkaliczne.gpkg": None,
            "DANE_INNE/INNE_Wos_1999_regiony_klimatyczne.gpkg": ["numer", "nazwa"],
            "DANE_INNE/INNE_Korytarze_ekologiczne.gpkg": ["nazwa"],
        }

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        for rel_path, fields in layers.items():
            abs_path = os.path.join(resource_base, rel_path)
            self.tbConsole.append(f"\nWarstwa: {rel_path}")

            if not os.path.exists(abs_path):
                self.tbConsole.append("Plik nie istnieje.")
                continue

            layer = QgsVectorLayer(abs_path, "src", "ogr")
            if not layer.isValid():
                self.tbConsole.append("Nie można wczytać warstwy.")
                continue

            field_names = set(layer.fields().names())
            request = QgsFeatureRequest().setFilterRect(bbox)

            count = 0
            is_roslinnosc = rel_path.endswith("INNE_Potencjalna_roslinnosc_naturalna.gpkg")
            unique_rows = set()

            for f in layer.getFeatures(request):
                g = f.geometry()
                if not g or not engine.intersects(g.constGet()):
                    continue

                count += 1

                if not fields:
                    continue

                values = []
                for fld in fields:
                    if fld not in field_names:
                        values = []
                        break
                    val = f.attribute(fld)
                    values.append("" if val is None else str(val))

                if not values:
                    continue

                if is_roslinnosc:
                    unique_rows.add(tuple(values))
                else:
                    self.tbConsole.append(" | ".join(values))

            if count == 0:
                self.tbConsole.append("Brak przecięć.")
                continue

            self.tbConsole.append(f"Liczba przecięć: {count}")

            if is_roslinnosc and unique_rows:
                for row in sorted(unique_rows):
                    self.tbConsole.append(" | ".join(row))

        self.tbConsole.append("Analiza INNE zakończona.\n")

    def anal_oze(self):
        self.tbConsole.append("Analiza OZE - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.tbConsole.append("Brak funkcji w layer_area.")
            return

        base = self.resource_path.filePath()
        layers = {
            "DANE_AKTUALIZOWANE/OZE/OZE_elektrownie_wiatrowe.gpkg": None,
            "DANE_AKTUALIZOWANE/OZE/OZE_biogazownie.gpkg": None,
            "DANE_AKTUALIZOWANE/OZE/OZE_fotowoltaika.gpkg": None,
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if not os.path.exists(path):
                self.tbConsole.append(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.tbConsole.append(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.tbConsole.append(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.tbConsole.append("Analiza OZE zakończona.\n")

    def list_project_gpkg_layers(self) -> list[str]:
        gpkg = self.project_path.filePath()
        if not gpkg or not os.path.isfile(gpkg):
            return []

        try:
            conn = sqlite3.connect(gpkg)
            cur = conn.cursor()
            cur.execute(
                "SELECT table_name FROM gpkg_contents WHERE data_type = 'features'"
            )
            return [row[0] for row in cur.fetchall()]
        finally:
            conn.close()

    def load_layers(self):
        table = self.table_gpkg
        table.setRowCount(0)
        table.setColumnCount(2)
        table.setHorizontalHeaderLabels([" ", "Nazwa warstwy"])

        layers = self.list_project_gpkg_layers()

        for i, name in enumerate(layers):
            table.insertRow(i)

            chk = QTableWidgetItem()
            chk.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
            chk.setCheckState(Qt.Unchecked)
            table.setItem(i, 0, chk)

            table.setItem(i, 1, QTableWidgetItem(name))

        if table.rowCount() > 0:
            width = table.sizeHintForIndex(
                table.model().index(0, 0)
            ).width()
        else:
            width = 25

        table.setColumnWidth(0, width + 10)
        table.horizontalHeader().setStretchLastSection(True)

        self.tbConsole.append("Tabela zaktualizowana.")

    def delete_selected_layers(self):
        table = self.table_gpkg
        rows_to_delete = [r for r in range(table.rowCount()) if table.item(r, 0).checkState() == Qt.Checked]
        if not rows_to_delete:
            self.tbConsole.append("Brak wybranych warstw do usunięcia.")
            return

        from PyQt5.QtWidgets import QMessageBox
        confirm = QMessageBox.question(
            self,
            "Potwierdzenie usunięcia",
            f"Czy na pewno usunąć {len(rows_to_delete)} wybrane warstwy?",
            QMessageBox.Yes | QMessageBox.No
        )
        if confirm != QMessageBox.Yes:
            self.tbConsole.append("Operacja zabortowana przez użytkownika.")
            return

        self.tbConsole.append(f"Usuwanie {len(rows_to_delete)} wybranych warstw...")
        layers_to_delete = [table.item(r, 1).text() for r in rows_to_delete]
        try:
            conn = sqlite3.connect(self.project_path.filePath())
            cursor = conn.cursor()
            for layer in layers_to_delete:
                cursor.execute(f"DROP TABLE IF EXISTS '{layer}'")
                cursor.execute(f"DELETE FROM gpkg_contents WHERE table_name='{layer}'")
                cursor.execute(f"DELETE FROM gpkg_geometry_columns WHERE table_name='{layer}'")
                self.tbConsole.append(f"Usunięto warstwę: {layer}")
            conn.commit()
            conn.close()
            self.load_layers()
            self.tbConsole.append("Usuwanie zakończone, tabela zaktualizowana.")
        except Exception as e:
            self.tbConsole.append(f"Błąd usuwania warstw: {e}")

    def rename_selected_layer(self):
        table = self.table_gpkg
        rows_checked = [r for r in range(table.rowCount()) if table.item(r, 0).checkState() == Qt.Checked]
        if len(rows_checked) != 1:
            self.tbConsole.append("Zaznacz tylko jedną warstwę do zmiany nazwy.")
            return

        row = rows_checked[0]
        old_name = table.item(row, 1).text()
        new_name, ok = QInputDialog.getText(self, "Rename Layer", "New name:", text=old_name)
        if not ok or not new_name:
            self.tbConsole.append("Zmiana nazwy anulowana.")
            return

        try:
            conn = sqlite3.connect(self.project_path.filePath())
            cursor = conn.cursor()
            cursor.execute(f"ALTER TABLE '{old_name}' RENAME TO '{new_name}'")
            cursor.execute(f"UPDATE gpkg_contents SET table_name='{new_name}' WHERE table_name='{old_name}'")
            cursor.execute(f"UPDATE gpkg_geometry_columns SET table_name='{new_name}' WHERE table_name='{old_name}'")
            conn.commit()
            conn.close()
            self.load_layers()
            self.tbConsole.append(f"Nazwę warstwy '{old_name}' zmieniono na '{new_name}' i odświeżono tabelę.")
        except Exception as e:
            self.tbConsole.append(f"Błąd zmiany nazwy: {e}")

    def vacuum_gpkg(self):
        try:
            conn = sqlite3.connect(self.project_path.filePath())
            conn.execute("VACUUM")
            conn.close()
            self.tbConsole.append("Geopaczka odkurzona.")
        except Exception as e:
            self.tbConsole.append(f"Błąd odkurzania geopaczki: {e}")

    def wind_area_2180(self):
        layer = self.wind_area.currentLayer()
        if layer is None:
            self.tbConsole.append("Nie wybrano warstwy z elektrowniami.")
            return None

        if layer.featureCount() == 0:
            self.tbConsole.append("Wybrana warstwa jest pusta.")
            return None

        if layer.crs().authid() == "EPSG:2180":
            return layer

        disp = QgsWkbTypes.displayString(layer.wkbType())
        uri = f"{disp}?crs=EPSG:2180"
        mem = QgsVectorLayer(uri, "wind_area_2180_tmp", "memory")
        mem_dp = mem.dataProvider()
        mem_dp.addAttributes(layer.fields())
        mem.updateFields()

        transform = QgsCoordinateTransform(
            layer.crs(),
            QgsCoordinateReferenceSystem("EPSG:2180"),
            QgsProject.instance()
        )

        feats = []
        for f in layer.getFeatures():
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            g = QgsGeometry(g)
            g.transform(transform)
            nf = QgsFeature(mem.fields())
            nf.setGeometry(g)
            nf.setAttributes(f.attributes())
            feats.append(nf)

        if not feats:
            self.tbConsole.append("Nieudana transformacja warstwy z elektrowniami.")
            return None

        mem_dp.addFeatures(feats)
        return mem

    def wind_area_buffer_5000(self) -> QgsGeometry | None:
        area = self.wind_area_2180()
        if not area:
            return None

        geom = None
        for f in area.getFeatures():
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            g = g.buffer(5000, 8)
            geom = g if geom is None else geom.combine(g)

        return geom

    def get_matching_teryt_codes_wind(self) -> set[str]:
        buffer_geom = self.wind_area_buffer_5000()
        if not buffer_geom:
            self.tbConsole.append("Brak geometrii bufora 5000 m.")
            return set()

        powiat_path = os.path.join(
            self.resource_path.filePath(),
            "DANE_BDOT", "HELP", "POWIAT_TERYT.gpkg"
        )

        layer = QgsVectorLayer(powiat_path, "powiat", "ogr")
        if not layer.isValid():
            self.tbConsole.append("Nie można wczytać POWIAT_TERYT.")
            return set()

        bbox = buffer_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(buffer_geom.constGet())
        engine.prepareGeometry()

        teryt = set()
        req = QgsFeatureRequest().setFilterRect(bbox)

        for f in layer.getFeatures(req):
            g = f.geometry()
            if g and engine.intersects(g.constGet()):
                teryt.add(str(f["JPT_KOD_JE"]))
        return teryt

    def wind_spatial_filter(self):
        buffer_geom = self.wind_area_buffer_5000()
        if not buffer_geom:
            return None, None

        bbox = buffer_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(buffer_geom.constGet())
        engine.prepareGeometry()

        return bbox, engine

    def add_buffer_layer(self, geom: QgsGeometry, name: str):
        layer = QgsVectorLayer("Polygon?crs=EPSG:2180", name, "memory")
        pr = layer.dataProvider()
        pr.addAttributes([QgsField("typ", QVariant.String)])
        layer.updateFields()

        f = QgsFeature(layer.fields())
        f.setGeometry(geom)
        f["typ"] = "strefa"
        pr.addFeature(f)

        QgsProject.instance().addMapLayer(layer)

    def anal_wind_build_base(self, gpkg_name: str) -> list[QgsFeature]:
        teryt_codes = self.get_matching_teryt_codes_wind()
        if not teryt_codes:
            return []

        bbox, engine = self.wind_spatial_filter()
        if not bbox:
            return []

        src = os.path.join(self.resource_path.filePath(), "DANE_BDOT", gpkg_name)
        layer = QgsVectorLayer(src, "src", "ogr")
        if not layer.isValid():
            self.tbConsole.append(f"Błąd wczytania {gpkg_name}")
            return []

        req = QgsFeatureRequest()
        req.setFilterRect(bbox)
        req.setSubsetOfAttributes(layer.fields().names(), layer.fields())

        feats = []
        for f in layer.getFeatures(req):
            if str(f["TERYT"]) not in teryt_codes:
                continue

            g = f.geometry()
            if g and engine.intersects(g.constGet()):
                feats.append(f)

        self.tbConsole.append(f"{gpkg_name}: {len(feats)} obiektów po filtrach.")
        return feats

    def anal_wind_pobliska(self):
        layer = self.wind_area_2180()
        if not layer:
            self.tbConsole.append("Brak wybranej warstwy z elektrowniami wiatrowymi.")
            return

        buffer_dist = self.sbWindHeight.value() * 10

        geom = None
        for f in layer.getFeatures():
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            g = g.buffer(buffer_dist, 5)
            geom = g if geom is None else geom.combine(g)

        if geom is None:
            return

        bbox = geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(geom.constGet())
        engine.prepareGeometry()

        gminy_path = os.path.join(
            self.resource_path.filePath(),
            "DANE_AKTUALIZOWANE",
            "ADMINISTRACYJNE",
            "ADM_Gminy.gpkg"
        )

        gminy = QgsVectorLayer(gminy_path, "ADM_Gminy", "ogr")
        if not gminy.isValid():
            return

        names = set()
        req = QgsFeatureRequest().setFilterRect(bbox)

        for f in gminy.getFeatures(req):
            g = f.geometry()
            if g and engine.intersects(g.constGet()):
                names.add(str(f["JPT_NAZWA_"]))

        for n in sorted(names):
            self.tbConsole.append(f"Gmina pobliska: {n}")

    def anal_wind_build_700(self):
        feats = self.anal_wind_build_base("OT_BUBD_A.gpkg")
        feats = [f for f in feats if f["KODKST"] == "110"]

        if not feats:
            self.tbConsole.append("Brak budynków (KODKST=110).")
            return

        geom = None
        for f in feats:
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            g = g.buffer(700, 8)
            geom = g if geom is None else geom.combine(g)

        if not geom:
            return
        self.add_buffer_layer(geom, "Bufor_budynki_mieszkalne_700m")
        self.tbConsole.append(f"Dodano warstwę z buforem od budynków mieszkalnych.")

    def anal_wind_build_700_rad(self):
        feats = self.anal_wind_build_base("OT_BUBD_A.gpkg")
        feats = [f for f in feats if f["KODKST"] == "110"]

        if not feats:
            self.tbConsole.append("Brak budynków (KODKST=110).")
            return

        buffer_dist = 700 + self.sbWindRadius.value()

        geom = None
        for f in feats:
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            g = g.buffer(buffer_dist, 8)
            geom = g if geom is None else geom.combine(g)

        if not geom:
            return
        self.add_buffer_layer(geom, "Bufor_budynki_mieszkalne_700m_rotor")
        self.tbConsole.append(f"Dodano warstwę z buforem od budynków mieszkalnych + długość rotora.")

    def anal_wind_elect(self):
        allowed = {
            "linia elektroenergetyczna najwyższego napięcia",
            "linia elektroenergetyczna wysokiego napięcia"
        }

        feats = self.anal_wind_build_base("OT_SULN_L.gpkg")
        feats = [f for f in feats if f["RODZAJ"] in allowed]

        if not feats:
            self.tbConsole.append("Brak linii elektroenergetycznych wysokiego napięcia/najwyższych napięć w sąsiedztwie (5000 m).")
            return

        buffer_rad = 3 * self.sbWindRadius.value()
        buffer_h = 2 * self.sbWindHeight.value()

        geom_rad = None
        geom_h = None

        for f in feats:
            g = f.geometry()
            if not g or g.isEmpty():
                continue

            if buffer_rad > 0:
                g_rad = g.buffer(buffer_rad, 8)
                geom_rad = g_rad if geom_rad is None else geom_rad.combine(g_rad)

            if buffer_h > 0:
                g_h = g.buffer(buffer_h, 8)
                geom_h = g_h if geom_h is None else geom_h.combine(g_h)

        if geom_rad:
            self.add_buffer_layer(
                geom_rad,
                f"Bufor_linie_elektroenergetyczne_{buffer_rad}m"
            )
            self.tbConsole.append(f"Dodano warstwę z buforem od linii elektroenergetycznych {buffer_rad} m.")

        if geom_h:
            self.add_buffer_layer(
                geom_h,
                f"Bufor_linie_elektroenergetyczne_{buffer_h}m"
            )
            self.tbConsole.append(f"Dodano warstwę z buforem od linii elektroenergetycznych {buffer_h} m.")

    def anal_pog_building_core(self, use_flood: bool):

        def report(msg):
            self.tbConsole.append(msg)

        if use_flood:
            report("Rozpoczynam obliczanie wskaźników dla działek z budynkami zagrożonymi powodzią - wybór warstw")
        else:
            report("Rozpoczynam obliczanie wskaźników dla wszystkich działek z budynkami - wybór warstw")

        feedback = QgsProcessingFeedback()
        project = QgsProject.instance()

        def select_layer(msg):
            layers = [l for l in project.mapLayers().values() if isinstance(l, QgsVectorLayer)]
            if not layers:
                QMessageBox.critical(None, "Error", "Brak warstw wektorowych w projekcie")
                raise RuntimeError
            names = [l.name() for l in layers]
            name, ok = QInputDialog.getItem(None, "Wybór warstwy", msg, names, 0, False)
            if not ok:
                raise RuntimeError
            return project.mapLayersByName(name)[0]

        def fix_geoms(layer):
            return processing.run(
                "native:fixgeometries",
                {"INPUT": layer, "OUTPUT": "memory:"},
                feedback=feedback
            )["OUTPUT"]

        def ensure_epsg2180(layer):
            if layer.crs().authid() != "EPSG:2180":
                layer = processing.run(
                    "native:reprojectlayer",
                    {
                        "INPUT": layer,
                        "TARGET_CRS": "EPSG:2180",
                        "OUTPUT": "memory:"
                    },
                    feedback=feedback
                )["OUTPUT"]
            return fix_geoms(layer)

        try:
            budynki = ensure_epsg2180(select_layer("Wybierz warstwę z budynkami (BDOT10k)"))
            dzialki = ensure_epsg2180(select_layer("Wybierz warstwę z działkami (GML)"))
            powodz  = ensure_epsg2180(select_layer("Wybierz warstwę z zagrożeniem powodzią")) if use_flood else None
            strefy  = ensure_epsg2180(select_layer("Wybierz warstwę ze strefami planistycznymi"))
        except RuntimeError:
            report("Analiza przerwana na etapie wyboru warstw")
            return

        if use_flood:
            bud_touch = fix_geoms(processing.run(
                "native:extractbylocation",
                {"INPUT": budynki, "PREDICATE": [0, 1], "INTERSECT": powodz, "OUTPUT": "memory:"},
                feedback=feedback
            )["OUTPUT"])

            bud_flood = fix_geoms(processing.run(
                "native:intersection",
                {"INPUT": bud_touch, "OVERLAY": powodz, "OUTPUT": "memory:"},
                feedback=feedback
            )["OUTPUT"])

            bud_flood.startEditing()
            if bud_flood.fields().indexOf("flood_area") == -1:
                bud_flood.dataProvider().addAttributes([QgsField("flood_area", 6, "double")])
            bud_flood.updateFields()

            idx_fa = bud_flood.fields().indexOf("flood_area")
            fa_updates = {}
            for f in bud_flood.getFeatures():
                g = f.geometry()
                fa_updates[f.id()] = {idx_fa: g.area() if g and not g.isEmpty() else 0.0}
            bud_flood.dataProvider().changeAttributeValues(fa_updates)
            bud_flood.commitChanges()

            bud_flood_ok = fix_geoms(processing.run(
                "native:extractbyexpression",
                {"INPUT": bud_flood, "EXPRESSION": '"flood_area" >= 0.1', "OUTPUT": "memory:"},
                feedback=feedback
            )["OUTPUT"])

            dzialki_kwal = fix_geoms(processing.run(
                "native:extractbylocation",
                {"INPUT": dzialki, "PREDICATE": [0, 1], "INTERSECT": bud_flood_ok, "OUTPUT": "memory:"},
                feedback=feedback
            )["OUTPUT"])
        else:
            dzialki_kwal = dzialki

        bud_na_dzialkach = fix_geoms(processing.run(
            "native:extractbylocation",
            {"INPUT": budynki, "PREDICATE": [0, 1], "INTERSECT": dzialki_kwal, "OUTPUT": "memory:"},
            feedback=feedback
        )["OUTPUT"])

        split = fix_geoms(processing.run(
            "native:intersection",
            {"INPUT": bud_na_dzialkach, "OVERLAY": dzialki_kwal, "OUTPUT": "memory:"},
            feedback=feedback
        )["OUTPUT"])

        split.startEditing()
        if split.fields().indexOf("powbud") == -1:
            split.dataProvider().addAttributes([QgsField("powbud", 6, "double")])
        if split.fields().indexOf("powcalk") == -1:
            split.dataProvider().addAttributes([QgsField("powcalk", 6, "double")])
        split.updateFields()

        idx_pb = split.fields().indexOf("powbud")
        idx_pc = split.fields().indexOf("powcalk")
        idx_k  = split.fields().indexOf("LICZBAKONDYGNACJI")

        split_updates = {}
        for f in split.getFeatures():
            g = f.geometry()
            a = g.area() if g and not g.isEmpty() else 0.0
            k = f[idx_k] or 0
            split_updates[f.id()] = {idx_pb: a, idx_pc: a * k}
        split.dataProvider().changeAttributeValues(split_updates)
        split.commitChanges()

        agg = {}
        for f in split.getFeatures():
            pid = f["id_dzialki"]
            agg.setdefault(pid, [0.0, 0.0])
            agg[pid][0] += f["powbud"] or 0.0
            agg[pid][1] += f["powcalk"] or 0.0

        dzialki_kwal.startEditing()
        needed = []
        if dzialki_kwal.fields().indexOf("powbud_sum") == -1:
            needed.append(QgsField("powbud_sum", 6, "double"))
        if dzialki_kwal.fields().indexOf("powcalk_sum") == -1:
            needed.append(QgsField("powcalk_sum", 6, "double"))
        if dzialki_kwal.fields().indexOf("powdzialki") == -1:
            needed.append(QgsField("powdzialki", 6, "double"))
        if dzialki_kwal.fields().indexOf("symbol") == -1:
            needed.append(QgsField("symbol", 10, "string"))
        if dzialki_kwal.fields().indexOf("oznaczenie") == -1:
            needed.append(QgsField("oznaczenie", 10, "string"))
        if needed:
            dzialki_kwal.dataProvider().addAttributes(needed)
        dzialki_kwal.updateFields()

        dzialki_updates = {}
        idx_pb_sum = dzialki_kwal.fields().indexOf("powbud_sum")
        idx_pc_sum = dzialki_kwal.fields().indexOf("powcalk_sum")
        idx_pd     = dzialki_kwal.fields().indexOf("powdzialki")

        for f in dzialki_kwal.getFeatures():
            pid = f["id_dzialki"]
            s = agg.get(pid, [0.0, 0.0])
            g = f.geometry()
            dzialki_updates[f.id()] = {
                idx_pb_sum: s[0],
                idx_pc_sum: s[1],
                idx_pd: g.area() if g and not g.isEmpty() else 0.0
            }
        dzialki_kwal.dataProvider().changeAttributeValues(dzialki_updates)
        dzialki_kwal.commitChanges()

        dz_strefy = fix_geoms(processing.run(
            "native:intersection",
            {
                "INPUT": split,
                "OVERLAY": strefy,
                "OVERLAY_FIELDS": ["symbol", "oznaczenie"],
                "OVERLAY_PREFIX": "",
                "OUTPUT": "memory:"
            },
            feedback=feedback
        )["OUTPUT"])

        dz_strefy.startEditing()
        if dz_strefy.fields().indexOf("overlap") == -1:
            dz_strefy.dataProvider().addAttributes([QgsField("overlap", 6, "double")])
        dz_strefy.updateFields()

        idx_ov = dz_strefy.fields().indexOf("overlap")
        ov_updates = {}
        for f in dz_strefy.getFeatures():
            g = f.geometry()
            ov_updates[f.id()] = {idx_ov: g.area() if g and not g.isEmpty() else 0.0}
        dz_strefy.dataProvider().changeAttributeValues(ov_updates)
        dz_strefy.commitChanges()

        best = {}
        for f in dz_strefy.getFeatures():
            pid = f["id_dzialki"]
            area = f["overlap"] or 0.0
            sym = f["symbol"] or ""
            ozn = f["oznaczenie"] or ""
            if pid not in best or area > best[pid][0]:
                best[pid] = (area, sym, ozn)

        dzialki_kwal.startEditing()
        sym_updates = {}
        idx_sym = dzialki_kwal.fields().indexOf("symbol")
        idx_ozn = dzialki_kwal.fields().indexOf("oznaczenie")

        for f in dzialki_kwal.getFeatures():
            pid = f["id_dzialki"]
            if pid in best:
                sym_updates[f.id()] = {
                    idx_sym: best[pid][1],
                    idx_ozn: best[pid][2]
                }
            else:
                sym_updates[f.id()] = {
                    idx_sym: "",
                    idx_ozn: ""
                }

        dzialki_kwal.dataProvider().changeAttributeValues(sym_updates)
        dzialki_kwal.commitChanges()

        final_layer = fix_geoms(processing.run(
            "native:refactorfields",
            {
                "INPUT": dzialki_kwal,
                "FIELDS_MAPPING": [
                    {"name": "powbud_sum", "type": 6, "length": 20, "precision": 2, "expression": '"powbud_sum"'},
                    {"name": "powcalk_sum", "type": 6, "length": 20, "precision": 2, "expression": '"powcalk_sum"'},
                    {"name": "powdzialki", "type": 6, "length": 20, "precision": 2, "expression": '"powdzialki"'},
                    {"name": "maxpowzab", "type": 6, "length": 10, "precision": 2,
                     "expression": 'CASE WHEN "powdzialki" > 0 THEN ceil(("powbud_sum" / "powdzialki") * 100) / 100 ELSE 0 END'},
                    {"name": "intensywnosc", "type": 6, "length": 10, "precision": 2,
                     "expression": 'CASE WHEN "powdzialki" > 0 THEN ceil(("powcalk_sum" / "powdzialki") * 100) / 100 ELSE 0 END'},
                    {"name": "symbol", "type": 10, "length": 50, "precision": 0, "expression": '"symbol"'},
                    {"name": "oznaczenie", "type": 10, "length": 50, "precision": 0, "expression": '"oznaczenie"'},
                    {"name": "NUMER_DZIALKI", "type": 10, "length": 50, "precision": 0, "expression": '"NUMER_DZIALKI"'},
                    {"name": "NAZWA_OBREBU", "type": 10, "length": 50, "precision": 0, "expression": '"NAZWA_OBREBU"'},
                    {"name": "maksUdzialPowierzchniZabudowy", "type": 6, "length": 0, "precision": 2,
                     "expression": 'CASE WHEN "powdzialki" > 0 THEN ceil(("powbud_sum" / "powdzialki") * 100) / 100 ELSE 0 END'},
                    {"name": "maksNadziemnaIntensywnoscZabudowy", "type": 6, "length": 0, "precision": 1,
                    "expression": 'CASE WHEN "powdzialki" > 0 AND ceil(("powcalk_sum" / "powdzialki") * 100) / 100 > 0.1 THEN ceil(("powcalk_sum" / "powdzialki") * 100) / 100 ELSE 0.1 END'},
                ],
                "OUTPUT": "memory:"
            },
            feedback=feedback
        )["OUTPUT"])

        final_layer = fix_geoms(processing.run(
            "native:extractbyexpression",
            {
                "INPUT": final_layer,
                "EXPRESSION": '"powbud_sum" > 0.1',
                "OUTPUT": "memory:"
            },
            feedback=feedback
        )["OUTPUT"])

        final_layer.setName(
            "Działki ze wskaźnikami (powódź)" if use_flood else "Działki ze wskaźnikami (bez powodzi)"
        )
        project.addMapLayer(final_layer)

        report("Analiza zakończona")




    def anal_pog_all_buildings(self):
        self.anal_pog_building_core(use_flood=False)

    def anal_pog_flood_buildings(self):
        self.anal_pog_building_core(use_flood=True)



# xD