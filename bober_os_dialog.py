# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BoberOSDialog
 Plugin base generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-12-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Bartosz Łęczycki
        email                : bartosz.leczycki98@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import time
import re
import shutil
import sqlite3
import processing
import psycopg2
import subprocess
import tempfile
import ctypes
import sys
from ctypes import wintypes
from qgis.core import *
from qgis.core import QgsVectorLayer, QgsProject, QgsFeatureRequest, QgsVectorFileWriter, QgsGeometry, QgsReadWriteContext, QgsCoordinateTransformContext, QgsWkbTypes, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsFeature, QgsVectorLayerExporter, QgsExpressionContext, QgsExpressionContextUtils, QgsRectangle, QgsMapRendererCustomPainterJob
from qgis.PyQt import *
from qgis.PyQt import uic
from qgis.PyQt.QtCore import *
from PyQt5.QtGui import QStandardItemModel, QStandardItem, QPixmap, QPainter, QColor, QImage
from qgis.PyQt.QtWidgets import QMessageBox, QDialog, QColorDialog, QFileSystemModel, QFileDialog
from PyQt5.QtWidgets import QTableWidgetItem, QInputDialog, QMessageBox, QHeaderView
from PyQt5.QtCore import Qt, QVariant, QDir, QSize
from qgis.PyQt.QtXml import QDomDocument
from pathlib import Path
from qgis.gui import *
from datetime import datetime
from qgis.utils import iface



FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'bober_os_dialog_base.ui'))


class BoberOSDialog(QtWidgets.QDialog, FORM_CLASS):
    BDOT_LAYERS = {
        "OT_SWRS": "BDOT_siec_wod_rzeka_strumien",
        "OT_SWKN": "BDOT_siec_wod_kanal",
        "OT_SWRM": "BDOT_siec_wod_row_melioracyjny",

        "OT_SKJZ": "BDOT_siec_kom_jezdnia",
        "OT_SKDR": "BDOT_siec_kom_droga",
        "OT_SKRW": "BDOT_siec_kom_rondo_wezel",
        "OT_SKRP": "BDOT_siec_kom_ciag_pieszy_rower",
        "OT_SKTR": "BDOT_siec_kom_tory",
        "OT_SKPP": "BDOT_siec_kom_przeprawy",

        "OT_SULN": "BDOT_infra_linia_elektro",
        "OT_SUPR": "BDOT_infra_przewod_rurowy",

        "OT_PTWP": "BDOT_pokrycie_woda",
        "OT_PTZB": "BDOT_pokrycie_zabudowa",
        "OT_PTLZ": "BDOT_pokrycie_las_zadrzewienie",
        "OT_PTRK": "BDOT_pokrycie_rosl_krzewiasta",
        "OT_PTUT": "BDOT_pokrycie_uprawa_trwala",
        "OT_PTTR": "BDOT_pokrycie_rosl_trawiasta_upr_rolna",
        "OT_PTKM": "BDOT_pokrycie_teren_komunikacji",
        "OT_PTGN": "BDOT_pokrycie_grunt_nieuzytkowany",
        "OT_PTPL": "BDOT_pokrycie_plac",
        "OT_PTSO": "BDOT_pokrycie_skladowisko_odpadow",
        "OT_PTWZ": "BDOT_pokrycie_wyrobiska",
        "OT_PTNZ": "BDOT_pokrycie_inny_teren_niezab",

        "OT_BUBD": "BDOT_bud_budynek",
        "OT_BUIN": "BDOT_bud_budowla_inzynierska",
        "OT_BUHD": "BDOT_bud_budowla_hydrotechniczna",
        "OT_BUSP": "BDOT_bud_budowla_sportowa",
        "OT_BUWT": "BDOT_bud_wysoka_budowla_techniczna",
        "OT_BUZT": "BDOT_bud_zbiornik_techniczny",
        "OT_BUUO": "BDOT_bud_umocnienia",
        "OT_BUZM": "BDOT_bud_budowle_ziemne",
        "OT_BUTR": "BDOT_bud_urzadzenia_transportowe",
        "OT_BUIT": "BDOT_bud_inne_urzadzenia_techniczne",
        "OT_BUIB": "BDOT_bud_inne_budowle",

        "OT_ADMS": "BDOT_adm_miejscowosc",

        "OT_OIPR": "BDOT_inne_obiekt_przyr",
        "OT_OIKM": "BDOT_inne_obiekt_komunikacja",
        "OT_OIOR": "BDOT_inne_obiekt_orientacyjny",
        "OT_OIMK": "BDOT_inne_mokradlo",
        "OT_OISZ": "BDOT_inne_szuwary",
    }    
    
    def __init__(self, parent=None):
        if parent is None:
            parent = iface.mainWindow()
        super(BoberOSDialog, self).__init__(parent)
        self.iface = iface
        self.setupUi(self)
        self.init_ui_color_customization()
        
        self.setWindowFlags(Qt.Window | Qt.WindowMinMaxButtonsHint | Qt.WindowCloseButtonHint)
        
        for btn in self.findChildren(QtWidgets.QPushButton):
            btn.setDefault(False)
            btn.setAutoDefault(False)

        self.pbClearConsole.clicked.connect(self.run_clear_console)

        self.project_path.setStorageMode(QgsFileWidget.GetFile)
        self.project_path.setFilter("GeoPackage files (*.gpkg)")
        
        self.mpzp_layer.layerChanged.connect(self.populate_mpzp_symbol_columns)
        self.numeracja_layer.layerChanged.connect(self.populate_numeracja_unikalna_columns)
        
        
        self.project_path.fileChanged.connect(lambda path: self.save_setting("project_path", path))
        saved_path = self.load_setting("project_path")
        if saved_path:
            self.project_path.setFilePath(saved_path)
                
        self.layer_area.currentIndexChanged.connect(self.update_label_layer_area)
        
        saved_buffer = self.load_setting("buffer_value")
        if saved_buffer:
            self.sbBufferValue.setValue(int(saved_buffer))
        self.sbBufferValue.valueChanged.connect(self.update_buffer_value)
        self.update_buffer_value(self.sbBufferValue.value())
        
        self.wind_area.setFilters(
            QgsMapLayerProxyModel.PolygonLayer |
            QgsMapLayerProxyModel.PointLayer
        )
        self.mpzp_layer.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.pog_layer.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.numeracja_layer.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        
        
        self.pb_upgrade_plugin.clicked.connect(self.upgrade_plugin)
        #LAYER AREA
        self.layer_area.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.layer_area.setCurrentIndex(-1)
        #RESOURCE PATHS
        self.resource_path.setStorageMode(QgsFileWidget.GetDirectory)
        self.resource_path.setFilePath("")
        self.resource_path.fileChanged.connect(lambda path: self.save_setting("resource_path", path))
        saved_resource = self.load_setting("resource_path")
        if saved_resource:
            self.resource_path.setFilePath(saved_resource)

        if not saved_resource or not os.path.isdir(saved_resource):
            QMessageBox.warning(
                self.iface.mainWindow(),
                "Uwaga! Brak ścieżki do zasobu danych",
                "Wybierz ścieżkę do zasobu danych przed korzystaniem z wtyczki.")
        else:
            source_folder_date = Path(saved_resource).parent / "WTYCZKI" / "bober_os"
            resource_file = source_folder_date / "bober_os_dialog.py"

            if resource_file.exists() and resource_file.is_file():
                resource_mtime = resource_file.stat().st_mtime
                newest_date = datetime.fromtimestamp(resource_mtime)

                self.label_plugin_date.setText(
                    f"Ostatnia aktualizacja wtyczki: {newest_date.strftime('%Y-%m-%d %H:%M:%S')}"
                )

                plugin_file = Path(__file__).resolve()

                if plugin_file.stat().st_mtime < resource_mtime:
                    QMessageBox.warning(
                        self.iface.mainWindow(),
                        f"Uwaga! Nieaktualna wtyczka - ostatnia aktualizacja {newest_date.strftime('%Y-%m-%d %H:%M:%S')}",
                        "Zaktualizuj wtyczkę guzikiem, w pierwszej zakładce, żeby mieć fajne rzeczy. Dodane funkcjonalności widoczne są w konsoli (okienko po prawej stronie)."
                    )
            else:
                self.report("Nie wyznaczono ścieżki do zasobu.")
            
        #TREEVIEWS + MODELS
        self.fs_model = QFileSystemModel(self)
        self.fs_model.setRootPath(QDir.rootPath())
        map_path = os.path.join(self.resource_path.filePath(), "DANE_MAPY_ZASADNICZE")
        self.tv_pg_import.setModel(self.fs_model)
        self.tv_pg_import.setRootIndex(self.fs_model.index(map_path))
        self.pb_pg_tree_load.clicked.connect(self.load_pg_tree)
        self.pb_pg_refresh.clicked.connect(self.pg_refresh)
        self.pb_pg_import.clicked.connect(self.pg_import)
        self.pb_pg_load.clicked.connect(self.pg_load)
        self.pb_pg_delete.clicked.connect(self.pg_delete)
        self.pb_pg_split.clicked.connect(self.pg_split)
        self.pb_pg_pound_replace.clicked.connect(self.pg_pound_replace)
        self.tv_pg_import.header().setStretchLastSection(False)
        self.tv_pg_import.header().setSectionResizeMode(0, QHeaderView.ResizeToContents)
        #STYLE TREEVIEW + APPLY
        self.cb_style_layer.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.style_model = QFileSystemModel(self)
        self.style_root_path = os.path.join(self.resource_path.filePath(), "DANE_STYLE_QML")
        self.style_model.setRootPath(self.style_root_path)
        self.style_model.setFilter(QDir.AllDirs | QDir.Files | QDir.NoDotAndDotDot)
        self.style_model.setNameFilterDisables(False)
        self.style_model.setNameFilters([])
        self.tv_style.setModel(self.style_model)
        self.tv_style.setRootIndex(self.style_model.index(self.style_root_path))
        self.tv_style.setColumnHidden(1, True)
        self.tv_style.setColumnHidden(2, True)
        self.tv_style.setColumnHidden(3, True)
        self.tv_style.header().setStretchLastSection(False)
        self.tv_style.header().setSectionResizeMode(0, QHeaderView.ResizeToContents)
        self.cb_style_layer.layerChanged.connect(self.update_style_filter)
        self.tv_style.selectionModel().selectionChanged.connect(self.update_style_button)
        self.pb_style_layer.clicked.connect(self.apply_style_to_layer)
        self.pb_style_layer.setEnabled(False)
        self.style_model.setNameFilters(["__nothing__"])
        self._previous_layer_styles = {}
        self.pb_apply_previous_style_to_layer.clicked.connect(self.apply_previous_style_to_layer)
        self.pb_export_active_layer_style.clicked.connect(self.export_active_layer_style)
        #POSTGRES CREDENTIALS
        self.le_pg_username.textChanged.connect(lambda text: self.save_setting("pg_username", text))
        self.le_pg_password.textChanged.connect(lambda text: self.save_setting("pg_password", text))
        self.le_pg_port.textChanged.connect(lambda text: self.save_setting("pg_port", text))
        saved_username = self.load_setting("pg_username")
        if saved_username:
            self.le_pg_username.setText(saved_username)
        saved_password = self.load_setting("pg_password")
        if saved_password:
            self.le_pg_password.setText(saved_password)
        saved_port = self.load_setting("pg_port")
        if saved_port:
            self.le_pg_port.setText(saved_port)
        
        self.pb_act_fop.clicked.connect(self.act_fop_layers)
        self.pb_act_pomniki.clicked.connect(self.act_pomniki_layers)
        self.pb_act_pig.clicked.connect(self.act_pig_layers)
        self.pb_act_adm.clicked.connect(self.act_adm_layers)
        self.pb_act_oze.clicked.connect(self.act_oze_layers)
        self.fop_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.fop_path.setFilter("Shapefile (*.shp)")
        self.pomniki_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.pomniki_path.setFilter("GPKG (*.gpkg)")
        self.pig_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.pig_path.setFilter("Shapefile (*.shp)")
        self.adm_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.adm_path.setFilter("GML file (*.gml)")
        self.oze_path.setStorageMode(QgsFileWidget.GetMultipleFiles)
        self.oze_path.setFilter("GPKG file (*.gpkg)")
        #IMPORT BUTTONS
        button_configs = {
            self.pb_import_fop: {"": ["DANE_AKTUALIZOWANE", "FOP"]},
            self.pb_import_pig: {"": ["DANE_AKTUALIZOWANE", "PIG"]},
            self.pb_import_um: {"ADM_MorskieLinieBrzegowe.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"],
                "ADM_MorskieWodyWewnetrzne.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"],
                "ADM_PasOchronny.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"],
                "ADM_PasTechniczny.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_obreb: {"ADM_ObrebyEwidencyjne.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_gmina: {"ADM_Gminy.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_powiat: {"ADM_Powiaty.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_wojewodztwo: {"ADM_Wojewodztwa.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_nadlesnictwo: {"ADM_Nadlesnictwa.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_zz: {"ADM_ZarzadyZlewni.gpkg": ["DANE_AKTUALIZOWANE", "ADMINISTRACYJNE"]},
            self.pb_import_oze: {"": ["DANE_AKTUALIZOWANE", "OZE"]},
            self.pb_import_jcwpd: {"WODY_JCWPd.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_gzwp: {"WODY_GZWP.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwprz: {"WODY_Zlewnie_JCWP_rzeczne.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwpj: {"WODY_Zlewnie_JCWP_jeziorne.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwpprzej: {"WODY_Zlewnie_JCWP_przejsciowe.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwpprzyb: {"WODY_Zlewnie_JCWP_przybrzezne.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwpzbior: {"WODY_Zlewnie_JCWP_zbiornikowe.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_jcwppozos: {"WODY_JCWP_pozostale.gpkg": ["DANE_PGW_GZWP"]},
            self.pb_import_powodz_rzeka10: {"POWODZ_rzeka_10.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_rzeka100: {"POWODZ_rzeka_100.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_rzeka500: {"POWODZ_rzeka_500.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_rzekaWZ: {"POWODZ_rzeka_WZ.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_morze100: {"POWODZ_morze_100.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_morze500: {"POWODZ_morze_500.gpkg": ["DANE_POWODZ"]},
            self.pb_import_powodz_morzeWZ: {"POWODZ_morze_WZ.gpkg": ["DANE_POWODZ"]},
            self.pb_import_skorowidze: {"INNE_Skorowidz50k_92.gpkg": ["DANE_INNE"]},
            self.pb_import_fizgeo: {"INNE_Mezoregiony.gpkg": ["DANE_INNE"]},
            self.pb_import_roslinnosc: {"INNE_Potencjalna_roslinnosc_naturalna.gpkg": ["DANE_INNE"]},
            self.pb_import_reg_klim: {"INNE_Wos_1999_regiony_klimatyczne.gpkg": ["DANE_INNE"]},
            self.pb_import_pkp_halas_ldwn: {"INNE_PKP_halas_imisja_LDWN.gpkg": ["DANE_INNE"]},
            self.pb_import_pkp_halas_ln: {"INNE_PKP_halas_imisja_LN.gpkg": ["DANE_INNE"]},
            self.pb_import_torfowiska_alk: {"INNE_Torfowiska_alkaliczne.gpkg": ["DANE_INNE"]},
            self.pb_import_korytarze: {"INNE_Korytarze_ekologiczne.gpkg": ["DANE_INNE"]},
            self.pb_import_lasy: {"INNE_Lasy_BDL.gpkg": ["DANE_INNE"]}
        }
        for btn, config in button_configs.items():
            btn.clicked.connect(lambda _, c=config: self.import_filtered_layers(c))

        self.pb_import_act_all.clicked.connect(self.import_all_updated_data)
        self.pb_import_wody_all.clicked.connect(self.import_all_wody_data)
        self.pb_import_powodz_all.clicked.connect(self.import_all_powodz_data)
        self.pb_layout_area.clicked.connect(self.layout_area_gen)
        self.pb_pog_numeracja.clicked.connect(self.pog_numeracja)
        self.pb_pog_profil.clicked.connect(self.pog_korekta_profilu)
        self.pb_pog_spacje.clicked.connect(self.pog_korekta_spacje)
        self.pb_pog_zgodnosc.clicked.connect(self.pog_zgodnosc)
        self.pb_pog_to_xslx.clicked.connect(self.pog_to_xslx)
        #SAVE STYLES TO GPKG
        self.pb_style_save_single.clicked.connect(self.style_save_single)
        self.pb_style_save_all.clicked.connect(self.style_save_all)
        
        self.pb_reset_fid_values.clicked.connect(self.reset_fid_values)
        self.pb_numeracja_pol.clicked.connect(self.numeracja_pol)
        self.pb_numeracja_unikalna.clicked.connect(self.numeracja_unikalna)
        self.pb_import_external.clicked.connect(self.import_external)
        self.import_external_filter_path.fileChanged.connect(self.populate_import_external_filter_columns)
        self.pb_import_external_filter.clicked.connect(self.import_external_filter)
        #ANALYSIS BUTTONS
        self.pb_anal_fop.clicked.connect(self.anal_fop)
        self.pb_anal_adm.clicked.connect(self.anal_adm)
        self.pb_anal_pig.clicked.connect(self.anal_pig)
        self.pb_anal_wody.clicked.connect(self.anal_wody)
        self.pb_anal_powodz.clicked.connect(self.anal_powodz)
        self.pb_anal_inne.clicked.connect(self.anal_inne)
        self.pb_anal_oze.clicked.connect(self.anal_oze)
        self.pb_anal_fop_10km.clicked.connect(self.anal_fop_10km)
        self.pb_anal_lasy.clicked.connect(self.anal_lasy)
        self.pb_anal_wind_pobliska.clicked.connect(self.anal_wind_pobliska)
        self.pb_anal_wind_build_700.clicked.connect(self.anal_wind_build_700)
        self.pb_anal_wind_build_700_rad.clicked.connect(self.anal_wind_build_700_rad)
        self.pb_anal_wind_elect.clicked.connect(self.anal_wind_elect)        
        self.pb_anal_pog_flood_buildings.clicked.connect(self.anal_pog_flood_buildings)
        self.pb_anal_pog_all_buildings.clicked.connect(self.anal_pog_all_buildings)
        self.pb_report_crs.clicked.connect(self.report_crs)
        self.pb_report_encoding.clicked.connect(self.report_encoding)
        self.pb_report_unique_layer_sources.clicked.connect(self.report_unique_layer_sources)
        #MANAGE GPKG BUTTONS        
        self.pb_gpkg_load_layers.clicked.connect(self.load_layers)
        self.pb_gpkg_delete_layers.clicked.connect(self.delete_selected_layers)
        self.pb_gpkg_rename_layers.clicked.connect(self.rename_selected_layer)
        self.pb_gpkg_vacuum_layers.clicked.connect(self.vacuum_gpkg)
        #BDOT BUTTONS
        self.pb_bdot_refresh.clicked.connect(self.populate_bdot_table)
        self.pb_bdot_import.clicked.connect(self.import_selected_bdot_layers)
        self.pb_bdot_uncheck.clicked.connect(self.uncheck_all_bdot)

    def report(self, msg):
        self.tbConsole.append(msg)

    def save_setting(self, key: str, value: str):
        settings = QSettings()
        settings.setValue(f"bober_os/settings/{key}", value)
        if key == "project_path":
            self.report(f"Zapisano ścieżkę do paczki projektu: {value}")
        elif key == "resource_path":
            self.report(f"Zapisano ścieżkę do zasobu danych: {value}")
        elif key == "buffer_value":
            self.report(f"Zapisano wartość buforu: {value} m")

    def load_setting(self, key: str) -> str:
        settings = QSettings()
        return settings.value(f"bober_os/settings/{key}", "")

    def update_buffer_value(self, value):
        self.save_setting("buffer_value", str(value))
    
    def update_label_layer_area(self):
        layer = self.layer_area.currentLayer()
        if layer:
            self.labelLayerArea.setText(f"Wybrana warstwa: {layer.name()}")
        else:
            self.labelLayerArea.setText("Brak wybranej warstwy")

    def populate_mpzp_symbol_columns(self):
        self.cb_mpzp_symbol_col.blockSignals(True)
        self.cb_mpzp_symbol_col.clear()

        layer = self.mpzp_layer.currentLayer()
        if not layer or layer.type() != QgsMapLayerType.VectorLayer:
            self.cb_mpzp_symbol_col.blockSignals(False)
            return

        for f in layer.fields():
            self.cb_mpzp_symbol_col.addItem(f.name())

        self.cb_mpzp_symbol_col.blockSignals(False)

    def populate_import_external_filter_columns(self):
        self.cb_import_external_filter.clear()

        src_path = self.import_external_filter_path.filePath()
        if not src_path or not os.path.exists(src_path):
            return

        layer = QgsVectorLayer(src_path, "src", "ogr")
        if not layer.isValid():
            self.report("Nie można wczytać warstwy do filtrowania.")
            return

        for field in layer.fields():
            self.cb_import_external_filter.addItem(field.name())
    
    def populate_numeracja_unikalna_columns(self):
        self.cb_numeracja_unikalna.blockSignals(True)
        self.cb_numeracja_unikalna.clear()

        layer = self.numeracja_layer.currentLayer()
        if not layer:
            self.cb_numeracja_unikalna.blockSignals(False)
            return

        for f in layer.fields():
            self.cb_numeracja_unikalna.addItem(f.name())

        self.cb_numeracja_unikalna.blockSignals(False)    

    def init_ui_color_customization(self):
        self._ui_color_settings_key = "bober_os/settings/ui_bg_color"
        self._ui_color_default = "rgb(231, 255, 241)"
        self._base_stylesheet = self.styleSheet()
        settings = QSettings()
        color = settings.value(self._ui_color_settings_key, self._ui_color_default)
        self.apply_ui_bg_color(color)

        self.pbUiColor.clicked.connect(self.open_ui_color_slider)

    def apply_ui_bg_color(self, color_str: str):
        self.setStyleSheet(
            self._base_stylesheet +
            f"""
            QWidget {{
                background-color: {color_str};
            }}
            """
        )

    def open_ui_color_slider(self):
        dlg = QColorDialog(self)
        dlg.setOption(QColorDialog.DontUseNativeDialog, True)
        dlg.setOption(QColorDialog.ShowAlphaChannel, False)
        dlg.setWindowTitle("Wybierz kolor tła")

        if dlg.exec() != QColorDialog.Accepted:
            return

        color = dlg.currentColor()
        if not color.isValid():
            return

        color_str = f"rgb({color.red()}, {color.green()}, {color.blue()})"

        self.apply_ui_bg_color(color_str)
        QSettings().setValue(self._ui_color_settings_key, color_str)

        if hasattr(self, "tbConsole"):
            self.report(f"Ustawiono kolor tła: {color_str}")

    def layer_area_2180(self) -> QgsVectorLayer | None:
        src_layer = self.layer_area.currentLayer()
        if not src_layer:
            return None

        target_crs = QgsCoordinateReferenceSystem("EPSG:2180")
        if hasattr(self, "_layer_area_2180_cache"):
            cached_id, cached_layer = self._layer_area_2180_cache
            if cached_id == src_layer.id():
                return cached_layer
        if src_layer.crs() == target_crs:
            self._layer_area_2180_cache = (src_layer.id(), src_layer)
            return src_layer

        context = QgsProject.instance().transformContext()
        transform = QgsCoordinateTransform(
            src_layer.crs(),
            target_crs,
            context
        )

        mem_layer = QgsVectorLayer(
            f"{QgsWkbTypes.displayString(src_layer.wkbType())}?crs=EPSG:2180",
            f"{src_layer.name()}_2180",
            "memory"
        )

        provider = mem_layer.dataProvider()
        provider.addAttributes(src_layer.fields())
        mem_layer.updateFields()

        feats = []
        for f in src_layer.getFeatures():
            geom = f.geometry()
            if geom and not geom.isEmpty():
                geom = QgsGeometry(geom)
                geom.transform(transform)

                nf = QgsFeature(mem_layer.fields())
                nf.setAttributes(f.attributes())
                nf.setGeometry(geom)
                feats.append(nf)

        if not feats:
            return None

        provider.addFeatures(feats)
        mem_layer.updateExtents()
        self._layer_area_2180_cache = (src_layer.id(), mem_layer)

        return mem_layer

    def run_clear_console(self):
        self.tbConsole.setText("")
        self.progressBar.reset()   
    
    def process_vector_files(
        self,
        input_paths,
        match_rules,
        fields_per_rule,
        target_crs="EPSG:2180",
        subfolder="",
        force_cp1250=False):
        if isinstance(input_paths, str):
            input_paths = [input_paths]

        if not input_paths:
            self.report("No input files selected.")
            return

        base_dir = self.resource_path.filePath()
        if not base_dir:
            self.report("Resource path not set.")
            return

        out_dir = (
            os.path.join(base_dir, *subfolder)
            if isinstance(subfolder, (list, tuple))
            else os.path.join(base_dir, subfolder)
        )
        os.makedirs(out_dir, exist_ok=True)

        target_crs_obj = QgsCoordinateReferenceSystem(target_crs)
        context = QgsProject.instance().transformContext()

        total = len(input_paths)
        self.progressBar.setValue(0)

        for i, src_path in enumerate(input_paths, 1):
            base = os.path.basename(src_path)

            gpkg_name = None
            matched = None
            for pat, tgt in match_rules.items():
                p = pat.replace("%", "")
                if (
                    (pat.startswith("%") and pat.endswith("%") and p in base)
                    or (pat.startswith("%") and base.endswith(p))
                    or (pat.endswith("%") and base.startswith(p))
                    or base == p
                ):
                    gpkg_name = tgt
                    matched = pat
                    break

            if not gpkg_name:
                self.report(f"No rule for: {base}")
                self.progressBar.setValue(int(i / total * 100))
                continue

            gpkg_path = os.path.join(out_dir, gpkg_name)

            layer = QgsVectorLayer(src_path, "src", "ogr")
            if not layer.isValid():
                self.report(f"Failed to load layer: {base}")
                self.progressBar.setValue(int(i / total * 100))
                continue

            # THIS IS THE KEY LINE – ALWAYS FORCE CP1250 WHEN REQUESTED
            if force_cp1250:
                layer.dataProvider().setEncoding("CP1250")

            src_fields = layer.fields()
            drop = set(fields_per_rule.get(matched, []))
            keep_idx = [i for i, f in enumerate(src_fields) if f.name() not in drop]

            geom_type = layer.wkbType()
            need_tr = layer.crs().isValid() and layer.crs() != target_crs_obj
            if need_tr:
                tr = QgsCoordinateTransform(layer.crs(), target_crs_obj, context)

            mem = QgsVectorLayer(
                f"{QgsWkbTypes.displayString(geom_type)}?crs={target_crs}",
                "mem",
                "memory"
            )
            prov = mem.dataProvider()
            prov.addAttributes([src_fields[i] for i in keep_idx])
            mem.updateFields()

            feats = []
            for f in layer.getFeatures():
                g = f.geometry()
                if not g or g.isEmpty():
                    continue

                if need_tr:
                    g = QgsGeometry(g)
                    g.transform(tr)

                nf = QgsFeature(mem.fields())
                nf.setGeometry(g)
                nf.setAttributes([f[i] for i in keep_idx])
                feats.append(nf)

            if not feats:
                self.report(f"No valid features: {base}")
                self.progressBar.setValue(int(i / total * 100))
                continue

            prov.addFeatures(feats)
            mem.updateExtents()

            layer_name = os.path.splitext(gpkg_name)[0]

            if os.path.exists(gpkg_path):
                try:
                    os.remove(gpkg_path)
                except Exception:
                    self.report(f"Cannot overwrite file: {gpkg_path}")
                    self.progressBar.setValue(int(i / total * 100))
                    continue

            opts = QgsVectorFileWriter.SaveVectorOptions()
            opts.driverName = "GPKG"
            opts.layerName = layer_name
            opts.encoding = "UTF-8"
            opts.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteFile

            err, _ = QgsVectorFileWriter.writeAsVectorFormatV2(
                mem, gpkg_path, context, opts
            )

            if err != QgsVectorFileWriter.NoError:
                self.report(f"Write failed: {base}")

            self.progressBar.setValue(int(i / total * 100))
            QtWidgets.QApplication.processEvents()

        self.progressBar.setValue(100)
        self.report("Operation completed.")
 
    def act_fop_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.fop_path.filePath())

        match_rules = {
            "ParkiKrajobrazowe%": "FOP_ParkiKrajobrazowe.gpkg",
            "ParkiNarodowe%": "FOP_ParkiNarodowe.gpkg",
            "Rezerwaty%": "FOP_Rezerwaty.gpkg",
            "ObszaryChronionegoKrajobrazu%": "FOP_ObszaryChronionegoKrajobrazu.gpkg",
            "ObszarySpecjalnejOchrony%": "FOP_ObszarySpecjalnejOchrony.gpkg",
            "SpecjalneObszaryOchrony%": "FOP_SpecjalneObszaryOchrony.gpkg",
            "StanowiskaDokumentacyjne%": "FOP_StanowiskaDokumentacyjne.gpkg",
            "UzytkiEkologiczne%": "FOP_UzytkiEkologiczne.gpkg",
            "ZespolyPrzyrodniczoKrajobrazowe%": "FOP_ZespolyPrzyrodniczoKrajobrazowe.gpkg"
        }

        fields_per_rule = {k: ["gid", "kodinspire"] for k in match_rules.keys()}

        self.process_vector_files(
            input_paths=shp_list,
            match_rules=match_rules,
            fields_per_rule=fields_per_rule,
            target_crs="EPSG:2180",
            subfolder=["DANE_AKTUALIZOWANE", "FOP"],
            force_cp1250=True
        )
    
    def act_pomniki_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.pomniki_path.filePath())

        match_rules = {
            "PomnikiPrzyrodyPunktowe%": "FOP_PomnikiPrzyrody_punktowe.gpkg",
            "PomnikiPrzyrodyPowierzchniowe%": "FOP_PomnikiPrzyrody_powierzchniowe.gpkg",
        }

        fields_per_rule = {k: ["gid", "kodinspire"] for k in match_rules.keys()}

        self.process_vector_files(
            input_paths=shp_list,
            match_rules=match_rules,
            fields_per_rule=fields_per_rule,
            target_crs="EPSG:2180",
            subfolder=["DANE_AKTUALIZOWANE", "FOP"],
            force_cp1250=True
        )        

    def act_pig_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.pig_path.filePath())

        match_rules = {
            "cbdg_midas_zloza%": "PIG_UdokumentowaneZloza.gpkg",
            "cbdg_midas_tereny%": "PIG_TerenyGornicze.gpkg",
            "cbdg_midas_obszary%": "PIG_ObszaryGornicze.gpkg",
        }

        fields_per_rule = {
            "cbdg_midas_zloza%": ["UKL_WSP", "KOPALINA_A", "SHAPE_AREA", "SHAPE_LEN"],
            "cbdg_midas_tereny%": ["ID_KONTURU", "STATUS", "STATUS_EN", "KOMENTARZ",
                                    "UKLAD_WSP", "ARK_MAP_50", "SHAPE_AREA", "SHAPE_LEN"],
            "cbdg_midas_obszary%": ["ID_KONTURU", "STATUS", "STATUS_EN", "KOMENTARZ",
                                    "UKLAD_WSP", "ARK_MAP_50", "SHAPE_AREA", "SHAPE_LEN"],
        }

        self.process_vector_files(
            input_paths=shp_list,
            match_rules=match_rules,
            fields_per_rule=fields_per_rule,
            target_crs="EPSG:2180",
            subfolder=["DANE_AKTUALIZOWANE", "PIG"]
        )

    def act_oze_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.oze_path.filePath())

        match_rules = {
            "elektrownie wiatrowe%": "OZE_elektrownie_wiatrowe.gpkg",
            "fotowoltaika%": "OZE_fotowoltaika.gpkg",
            "biogazownie%": "OZE_biogazownie.gpkg",
        }

        fields_per_rule = {
            "elektrownie wiatrowe%": ["organ"],
            "fotowoltaika%": ["powierzchnia zabudowy [ha]", "powierzchnia zabudowy 2 [ha]", "RDOŚ"],
            "biogazownie%": ["RDOŚ"],
        }

        self.process_vector_files(
            input_paths=shp_list,
            match_rules=match_rules,
            fields_per_rule=fields_per_rule,
            target_crs="EPSG:2180",
            subfolder=["DANE_AKTUALIZOWANE", "OZE"]
        )        

    def act_adm_layers(self):
        shp_list = QgsFileWidget.splitFilePaths(self.adm_path.filePath())

        match_rules = {
            "%Pas_ochronny%": "ADM_PasOchronny.gpkg",
            "%Pas_techniczny%": "ADM_PasTechniczny.gpkg",
            "%Morskie_linie_brzegowe%": "ADM_MorskieLinieBrzegowe.gpkg",
            "%Morskie_wody_wewnetrzne%": "ADM_MorskieWodyWewnetrzne.gpkg",
            "%Nadlesnictwo%": "ADM_Nadlesnictwa.gpkg",
            "%Zarzad_zlewni_PGWWP%": "ADM_ZarzadyZlewni.gpkg",
            "%Granice_wojewodztw%": "ADM_Wojewodztwa.gpkg",
            "%Granice_powiatow%": "ADM_Powiaty.gpkg",
            "%Granice_gmin%": "ADM_Gminy.gpkg",
            "%Granice_obrebow_ewidencyjnych%": "ADM_ObrebyEwidencyjne.gpkg",
        }

        fields_per_rule = {
            "%Pas_ochronny%": [
                "gml_id", "DOCUMENT_I", "COASTAL_ZO", "TERYT_NO", "COASTAL_Z0",
                "FULL_NAME", "SHORT_NAME", "DESCRIPTIO", "COMMENTS", "NOTES",
                "SYS_NODE_C", "SYS_VERSIO", "SYS_VERSI0", "SYS_DATE_A", "SYS_DATA_A",
                "SYS_DATA_E", "SYS_UUID", "IIP_PRZEST"
            ],
            "%Pas_techniczny%": [
                "gml_id", "DOCUMENT_I", "COASTAL_ZO", "TERYT_NO", "COASTAL_Z0",
                "FULL_NAME", "SHORT_NAME", "DESCRIPTIO", "COMMENTS", "NOTES",
                "SYS_NODE_C", "SYS_VERSIO", "SYS_VERSI0", "SYS_DATE_A", "SYS_DATA_A",
                "SYS_DATA_E", "SYS_UUID", "IIP_PRZEST"
            ],
            "%W06_Morskie_linie_brzegowe%": [
                "gml_id", "DOCUMENT_I", "COASTAL_ZO", "TERYT_NO", "COASTAL_Z0",
                "FULL_NAME", "SHORT_NAME", "DESCRIPTIO", "COMMENTS", "NOTES",
                "SYS_NODE_C", "SYS_VERSIO", "SYS_VERSI0", "SYS_DATE_A", "SYS_DATA_A",
                "SYS_DATA_E", "SYS_UUID", "IIP_PRZEST"
            ],
            "%Morskie_wody_wewnetrzne%": [
                "gml_id", "FID", "ID", "SHORT_NAME", "AREA", "WERSJA_OD", "IIP_PRZEST"
            ],
            "%Zarzad_zlewni_PGWWP%": [
                "gml_id", "RZGW_KOD", "REGON"
            ],
            "%Nadlesnictwo%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_ORGAN_", "JPT_JOR_ID",
                "WERSJA_OD", "WERSJA_DO", "WAZNY_OD", "WAZNY_DO", "JPT_KOD__1",
                "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "ID_BUFORA_", "ID_BUFORA1",
                "ID_TECHNIC", "IIP_PRZEST", "IIP_IDENTY", "IIP_WERSJA", "JPT_KJ_IIP",
                "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_OPIS", "JPT_SPS_KO", "ID_BUFOR_1",
                "JPT_ID", "JPT_POWI_1", "JPT_KJ_I_3", "JPT_GEOMET", "JPT_GEOM_1",
                "SHAPE_LENG", "SHAPE_AREA", "REGON", "JPT_POWIER"
            ],
            "%Granice_obrebow_ewidencyjnych%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_POWIER", "JPT_ORGAN_",
                "JPT_KOD__1", "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "IIP_PRZEST",
                "IIP_IDENTY", "JPT_KJ_IIP", "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_SPS_KO",
                "JPT_POWI_1", "JPT_KJ_I_3", "JPT_JOR_ID", "WERSJA_OD", "WERSJA_DO",
                "WAZNY_OD", "WAZNY_DO", "IIP_WERSJA", "JPT_OPIS", "JPT_ID",
                "SHAPE_LENG", "SHAPE_AREA"
            ],
            "%Granice_gmin%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_POWIER", "JPT_ORGAN_",
                "JPT_KOD__1", "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "IIP_PRZEST",
                "IIP_IDENTY", "JPT_KJ_IIP", "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_SPS_KO",
                "JPT_POWI_1", "JPT_KJ_I_3", "JPT_JOR_ID", "WERSJA_OD", "WERSJA_DO",
                "WAZNY_OD", "WAZNY_DO", "IIP_WERSJA", "JPT_OPIS", "JPT_ID", "REGON",
                "SHAPE_LENG", "SHAPE_AREA"
            ],
            "%Granice_powiatow%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_POWIER", "JPT_ORGAN_",
                "JPT_KOD__1", "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "IIP_PRZEST",
                "IIP_IDENTY", "JPT_KJ_IIP", "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_SPS_KO",
                "JPT_POWI_1", "JPT_KJ_I_3", "JPT_JOR_ID", "WERSJA_OD", "WERSJA_DO",
                "WAZNY_OD", "WAZNY_DO", "IIP_WERSJA", "JPT_OPIS", "JPT_ID", "REGON",
                "SHAPE_LENG", "SHAPE_AREA"
            ],
            "%Granice_wojewodztw%": [
                "gml_id", "JPT_KOD_JE", "JPT_SJR_KO", "JPT_POWIER", "JPT_ORGAN_",
                "JPT_KOD__1", "JPT_NAZWA1", "JPT_ORGAN1", "JPT_WAZNA_", "IIP_PRZEST",
                "IIP_IDENTY", "JPT_KJ_IIP", "JPT_KJ_I_1", "JPT_KJ_I_2", "JPT_SPS_KO",
                "JPT_POWI_1", "JPT_KJ_I_3", "JPT_JOR_ID", "WERSJA_OD", "WERSJA_DO",
                "WAZNY_OD", "WAZNY_DO", "IIP_WERSJA", "JPT_OPIS", "JPT_ID", "REGON",
                "SHAPE_LENG", "SHAPE_AREA"
            ]
        }

        resource_base = self.resource_path.filePath()
        if not resource_base:
            self.report("Brak ścieżki zasobu (resource_path).")
            QtWidgets.QApplication.processEvents()
            return

        resource_dir = os.path.join(resource_base, "DANE_AKTUALIZOWANE", "ADMINISTRACYJNE")
        os.makedirs(resource_dir, exist_ok=True)

        total = len(shp_list)
        for i, gml_path in enumerate(shp_list):
            base = os.path.basename(gml_path)

            gpkg_name = None
            matched_pattern = None
            for pattern, target in match_rules.items():
                p = pattern.replace("%", "")
                if pattern.startswith("%") and pattern.endswith("%") and p in base:
                    gpkg_name = target
                    matched_pattern = pattern
                    break
                elif pattern.startswith("%") and base.endswith(p):
                    gpkg_name = target
                    matched_pattern = pattern
                    break
                elif pattern.endswith("%") and base.startswith(p):
                    gpkg_name = target
                    matched_pattern = pattern
                    break
                elif base == p:
                    gpkg_name = target
                    matched_pattern = pattern
                    break

            if not gpkg_name:
                self.report(f"Brak reguły dopasowania dla: {base}\n")
                QtWidgets.QApplication.processEvents()
                continue

            gpkg_path = os.path.join(resource_dir, gpkg_name)
            layer_name_in_gpkg = os.path.splitext(gpkg_name)[0]

            self.report(f"Przetwarzanie pliku: {base}")
            QtWidgets.QApplication.processEvents()
            self.report(f"Docelowy GPKG: {gpkg_path}")
            QtWidgets.QApplication.processEvents()

            if os.path.exists(gpkg_path):
                try:
                    os.remove(gpkg_path)
                    self.report(f"Usunięto istniejący plik: {gpkg_path}")
                    QtWidgets.QApplication.processEvents()
                except Exception as e:
                    self.report(f"Nie udało się usunąć GPKG:\n{e}\n")
                    QtWidgets.QApplication.processEvents()
                    continue

            layer = QgsVectorLayer(gml_path, "input", "ogr")
            if not layer.isValid():
                self.report(f"Nie można wczytać warstwy: {base}\n")
                QtWidgets.QApplication.processEvents()
                continue

            fields_to_delete = fields_per_rule.get(matched_pattern, [])
            all_fields = layer.fields().names()
            fields_to_keep = [f for f in all_fields if f not in fields_to_delete]

            geom_type = layer.wkbType()
            crs = layer.crs()
            mem_layer = QgsVectorLayer(f"{QgsWkbTypes.displayString(geom_type)}?crs={crs.authid()}", layer_name_in_gpkg, "memory")
            mem_provider = mem_layer.dataProvider()
            mem_provider.addAttributes([layer.fields()[layer.fields().indexFromName(f)] for f in fields_to_keep])
            mem_layer.updateFields()

            feats = []
            for feat in layer.getFeatures():
                new_feat = QgsFeature(mem_layer.fields())
                for f in fields_to_keep:
                    new_feat[f] = feat[f]
                new_feat.setGeometry(feat.geometry())
                feats.append(new_feat)
            mem_provider.addFeatures(feats)
            mem_layer.updateExtents()

            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "GPKG"
            options.layerName = layer_name_in_gpkg
            options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteFile
            options.encoding = "UTF-8"

            error = QgsVectorFileWriter.writeAsVectorFormatV2(
                mem_layer,
                gpkg_path,
                QgsProject.instance().transformContext(),
                options
            )

            if error[0] != QgsVectorFileWriter.NoError:
                self.report(f"Błąd zapisu GPKG: {error}\n")
                QtWidgets.QApplication.processEvents()
                continue

            self.report(f"Utworzono GPKG: {gpkg_path} z usuniętymi polami")
            QtWidgets.QApplication.processEvents()

            try:
                conn = sqlite3.connect(gpkg_path)
                conn.execute("VACUUM;")
                conn.close()
                self.report("GPKG zoptymalizowany (VACUUM).")
                QtWidgets.QApplication.processEvents()
            except Exception as e:
                self.report(f"Nie udało się wykonać VACUUM:\n{e}")
                QtWidgets.QApplication.processEvents()

            pct = int(((i + 1) / total) * 100)
            self.progressBar.setValue(pct)
            QtWidgets.QApplication.processEvents()

            self.report("Operacja zakończona.\n")
            QtWidgets.QApplication.processEvents()

    def build_filter_geometry(self) -> QgsGeometry | None:
        layer = self.layer_area_2180()
        if not layer or layer.featureCount() == 0:
            return None

        buffer_value = self.sbBufferValue.value()
        geoms = []

        for f in layer.getFeatures():
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            if buffer_value > 0:
                g = g.buffer(buffer_value, 5)
            geoms.append(g)

        if not geoms:
            return None

        return QgsGeometry.unaryUnion(geoms)

    def list_gpkg_layers_file(self, gpkg_path: str) -> set[str]:
        layers: set[str] = set()

        if not gpkg_path or not os.path.isfile(gpkg_path):
            return layers

        provider = QgsProviderRegistry.instance().providerMetadata("ogr")
        sublayers = provider.querySublayers(gpkg_path)

        for sub in sublayers:
            name = sub.name()
            if name:
                layers.add(name)

        return layers

    def import_layers(
        self,
        source_files: list[str],
        target_gpkg: str,
        layer_suffix: str,):
        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.report("Brak geometrii filtrującej.")
            return

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        existing_layers = self.list_gpkg_layers_file(target_gpkg)

        total = len(source_files)
        if total == 0:
            self.report("Brak plików do importu.")
            return

        self.progressBar.setValue(0)

        for i, path in enumerate(source_files, start=1):
            base = os.path.basename(path)
            layer_name = os.path.splitext(base)[0] + layer_suffix

            if layer_name in existing_layers:
                self.report(f"Pominięto (istnieje): {layer_name}")
                continue

            layer = QgsVectorLayer(path, "src", "ogr")
            if not layer.isValid():
                self.report(f"Błąd wczytania: {base}")
                continue

            request = QgsFeatureRequest()
            request.setFilterRect(bbox)

            matching_features: list[QgsFeature] = []

            for f in layer.getFeatures(request):
                g = f.geometry()
                if g and engine.intersects(g.constGet()):
                    matching_features.append(f)

            if not matching_features:
                self.report(f"Pominięto (brak przecięć): {layer_name}. \n")
                continue

            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "GPKG"
            options.layerName = layer_name
            options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
            options.encoding = "UTF-8"

            writer = QgsVectorFileWriter.create(
                target_gpkg,
                layer.fields(),
                layer.wkbType(),
                layer.crs(),
                QgsProject.instance().transformContext(),
                options
            )

            for f in matching_features:
                writer.addFeature(f)

            del writer

            self.report(
                f"Dodano {len(matching_features)} obiektów → {layer_name}"
            )

            if i % 3 == 0:
                self.progressBar.setValue(int(i / total * 100))
                QtWidgets.QApplication.processEvents()

        self.progressBar.setValue(100)
        self.report("Import zakończony.\n")

    def import_filtered_layers(self, layers_config: dict):
        resource_base = self.resource_path.filePath()
        project_gpkg = self.project_path.filePath()

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        files: list[str] = []

        for src, subfolders in layers_config.items():
            if src.lower().endswith(".gpkg"):
                files.append(os.path.join(resource_base, *subfolders, src))
            else:
                folder = os.path.join(resource_base, *subfolders)
                if not os.path.exists(folder):
                    continue
                files.extend(
                    os.path.join(folder, f)
                    for f in os.listdir(folder)
                    if f.lower().endswith((".gpkg", ".shp"))
                )

        self.import_layers(files, project_gpkg, suffix)

    def import_all_updated_data(self):
        base = os.path.join(self.resource_path.filePath(), "DANE_AKTUALIZOWANE")
        files = [
            os.path.join(root, f)
            for root, _, fs in os.walk(base)
            for f in fs if f.lower().endswith((".gpkg", ".shp"))
        ]

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        self.import_layers(files, self.project_path.filePath(), suffix)

    def import_all_wody_data(self):
        base = os.path.join(self.resource_path.filePath(), "DANE_PGW_GZWP")
        files = [
            os.path.join(root, f)
            for root, _, fs in os.walk(base)
            for f in fs if f.lower().endswith((".gpkg", ".shp"))
        ]

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        self.import_layers(files, self.project_path.filePath(), suffix)

    def import_all_powodz_data(self):
        base = os.path.join(self.resource_path.filePath(), "DANE_POWODZ")
        files = [
            os.path.join(root, f)
            for root, _, fs in os.walk(base)
            for f in fs if f.lower().endswith((".gpkg", ".shp"))
        ]

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        self.import_layers(files, self.project_path.filePath(), suffix)

    def populate_bdot_table(self):
        table = self.table_bdot
        table.clear()
        table.setRowCount(0)
        table.setColumnCount(2)
        table.setHorizontalHeaderLabels(["Import", "Warstwa"])

        base_dir = os.path.join(
            self.resource_path.filePath(),
            "DANE_BDOT"
        )

        if not os.path.isdir(base_dir):
            self.report("Brak katalogu DANE_BDOT.")
            return

        row = 0

        for filename in sorted(os.listdir(base_dir)):
            if not filename.lower().endswith(".gpkg"):
                continue

            name = os.path.splitext(filename)[0]  # OT_BUHD_A
            parts = name.split("_")

            # base BDOT code (OT_BUHD)
            base_code = "_".join(parts[:2]) if len(parts) > 2 else parts[0]

            if base_code not in self.BDOT_LAYERS:
                continue

            # geometry suffix
            geom_suffix = ""
            if parts[-1] in ("A", "L", "P"):
                geom_suffix = f"_{parts[-1]}"

            display_name = self.BDOT_LAYERS[base_code] + geom_suffix

            table.insertRow(row)

            chk = QTableWidgetItem()
            chk.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
            chk.setCheckState(Qt.Unchecked)

            label = QTableWidgetItem(display_name)
            label.setData(Qt.UserRole, filename)

            table.setItem(row, 0, chk)
            table.setItem(row, 1, label)

            row += 1

        table.resizeColumnsToContents()
        table.horizontalHeader().setStretchLastSection(True)

        self.report(f"Załadowano {row} warstw BDOT.")

    def get_matching_teryt_codes(self) -> set[str]:
        area = self.layer_area_2180()
        if not area:
            return set()

        powiat_path = os.path.join(
            self.resource_path.filePath(),
            "DANE_BDOT/HELP",
            "POWIAT_TERYT.gpkg"
        )

        layer = QgsVectorLayer(powiat_path, "powiat", "ogr")
        if not layer.isValid():
            self.report("Nie można wczytać POWIAT_TERYT.")
            return set()

        geom = self.build_filter_geometry()
        bbox = geom.boundingBox()

        engine = QgsGeometry.createGeometryEngine(geom.constGet())
        engine.prepareGeometry()

        request = QgsFeatureRequest().setFilterRect(bbox)

        teryt = set()
        for f in layer.getFeatures(request):
            g = f.geometry()
            if g and engine.intersects(g.constGet()):
                teryt.add(str(f["JPT_KOD_JE"]))

        return teryt

    def import_selected_bdot_layers(self):
        project_gpkg = self.project_path.filePath()
        if not project_gpkg:
            self.report("Brak project_path.")
            return

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.report("Brak geometrii filtrującej.")
            return

        teryt_codes = self.get_matching_teryt_codes()
        if not teryt_codes:
            self.report("Brak dopasowanych TERYT.")
            return

        date = datetime.now().strftime("_%Y_%m_%d")
        buffer = self.sbBufferValue.value()
        suffix = f"_bufor{buffer}{date}" if buffer > 0 else date

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        base = os.path.join(self.resource_path.filePath(), "DANE_BDOT")

        for row in range(self.table_bdot.rowCount()):
            if self.table_bdot.item(row, 0).checkState() != Qt.Checked:
                continue

            fn = self.table_bdot.item(row, 1).data(Qt.UserRole)
            src = os.path.join(base, fn)
            out_name = self.table_bdot.item(row, 1).text() + suffix

            layer = QgsVectorLayer(src, "src", "ogr")
            if not layer.isValid():
                self.report(f"Błąd: {fn}")
                continue

            req = QgsFeatureRequest()
            req.setFilterRect(bbox)
            req.setSubsetOfAttributes(layer.fields().names(), layer.fields())

            feats = []
            for f in layer.getFeatures(req):
                if str(f["TERYT"]) not in teryt_codes:
                    continue
                g = f.geometry()
                if g and engine.intersects(g.constGet()):
                    feats.append(f)

            if not feats:
                self.report(f"Pominięto {out_name} – brak obiektów.")
                continue

            opts = QgsVectorFileWriter.SaveVectorOptions()
            opts.driverName = "GPKG"
            opts.layerName = out_name
            opts.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
            opts.encoding = "UTF-8"

            writer = QgsVectorFileWriter.create(
                project_gpkg,
                layer.fields(),
                layer.wkbType(),
                layer.crs(),
                QgsProject.instance().transformContext(),
                opts
            )

            for f in feats:
                writer.addFeature(f)
            del writer

            self.report(f"Dodano {len(feats)} → {out_name}")

        self.report("BDOT import zakończony.\n")
    
    def uncheck_all_bdot(self):
        table = self.table_bdot

        for row in range(table.rowCount()):
            item = table.item(row, 0)
            if item is not None:
                item.setCheckState(Qt.Unchecked)

    def layout_area_gen(self):
        self.report("Rozpoczynam generowanie zasięgów układów...")

        target_crs = QgsCoordinateReferenceSystem("EPSG:2180")
        context = QgsProject.instance().transformContext()

        layout_manager = QgsProject.instance().layoutManager()
        layouts = layout_manager.printLayouts()

        if not layouts:
            self.report("Brak układów w projekcie. Nie dodano żadnych warstw.")
            if self.progressBar:
                self.progressBar.setValue(0)
            return

        total = len(layouts)
        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        unique_extents = []
        extent_sources = {}
        created_layers = 0

        for idx, layout in enumerate(layouts, start=1):

            layout_name = layout.name()
            self.report(f"Przetwarzanie układu: {layout_name}")

            map_items = [
                item for item in layout.items()
                if isinstance(item, QgsLayoutItemMap)
            ]

            if not map_items:
                self.report("  Układ pominięty – brak elementów mapy.")
                self.progressBar.setValue(idx)
                continue

            for map_item in map_items:

                extent = map_item.extent()
                source_crs = map_item.crs()
                transform = QgsCoordinateTransform(source_crs, target_crs, context)

                try:
                    transformed_extent = transform.transformBoundingBox(extent)
                except Exception as e:
                    self.report(f"  Błąd transformacji zasięgu: {e}")
                    continue

                extent_key = (
                    transformed_extent.xMinimum(),
                    transformed_extent.yMinimum(),
                    transformed_extent.xMaximum(),
                    transformed_extent.yMaximum()
                )

                for existing in unique_extents:
                    if transformed_extent == existing:
                        extent_sources[extent_key].append(layout_name)
                        break
                else:
                    unique_extents.append(transformed_extent)
                    extent_sources[extent_key] = [layout_name]

                    polygon_geom = QgsGeometry.fromRect(transformed_extent)

                    layer = QgsVectorLayer(
                        "Polygon?crs=EPSG:2180",
                        f"Zasięg - {layout_name}",
                        "memory"
                    )

                    provider = layer.dataProvider()
                    provider.addAttributes([QgsField("nazwa", QVariant.String)])
                    layer.updateFields()

                    feature = QgsFeature(layer.fields())
                    feature.setGeometry(polygon_geom)
                    feature.setAttribute("nazwa", layout_name)
                    provider.addFeature(feature)

                    QgsProject.instance().addMapLayer(layer)

                    created_layers += 1
                    self.report(f"Dodano warstwę: Zasięg - {layout_name}")

            self.progressBar.setValue(idx)

        shared = {k: v for k, v in extent_sources.items() if len(v) > 1}
        if shared:
            self.report("Układy współdzielące ten sam zasięg:")
            for layouts_list in shared.values():
                self.report("  " + ", ".join(layouts_list))

        if created_layers == 0:
            self.report("Nie dodano żadnych nowych warstw — brak unikalnych zasięgów.")
        else:
            self.report("Zakończono.")

    def pog_numeracja(self):
        self.report("Rozpoczynam numerację obiektów POG...")

        layer = self.iface.activeLayer()
        if not layer:
            self.report("Brak aktywnej warstwy. Wybierz warstwę i spróbuj ponownie.")
            if self.progressBar:
                self.progressBar.setValue(0)
            return

        symbol_field = "symbol"
        oznaczenie_field = "oznaczenie"
        lokalny_field = "lokalnyId"

        if symbol_field not in layer.fields().names():
            self.report(f"Brak wymaganej kolumny '{symbol_field}'.")
            return
        if oznaczenie_field not in layer.fields().names():
            self.report(f"Brak pola '{oznaczenie_field}' do zapisu numeracji.")
            return
        if lokalny_field not in layer.fields().names():
            self.report(f"Brak pola '{lokalny_field}' do zapisu ID lokalnego.")
            return

        unique_symbols = list(layer.uniqueValues(layer.fields().lookupField(symbol_field)))

        if not unique_symbols:
            self.report("Brak unikalnych wartości w kolumnie 'symbol'.")
            return

        self.report(f"Znaleziono {len(unique_symbols)} unikalnych symboli: {unique_symbols}")

        self.progressBar.setMaximum(len(unique_symbols))
        self.progressBar.setValue(0)

        layer.startEditing()

        processed_symbols = 0
        total_numbered = 0

        for idx, symbol in enumerate(unique_symbols, start=1):

            self.report(f"Przetwarzanie symbolu: {symbol}")

            request = QgsFeatureRequest(QgsExpression(f'"{symbol_field}" = \'{symbol}\''))
            features = [f for f in layer.getFeatures(request)
                        if f.geometry() and not f.geometry().isEmpty()]

            if not features:
                self.report("  Brak obiektów z tym symbolem – pomijam.")
                self.progressBar.setValue(idx)
                continue

            if len(features) < 2:
                self.report("  Za mało obiektów do wyznaczenia kolejności – pomijam.")
                self.progressBar.setValue(idx)
                continue

            start_feature = min(features, key=lambda f: (
                f.geometry().centroid().asPoint().x(),
                f.geometry().centroid().asPoint().y()
            ))

            visited = [start_feature]
            features.remove(start_feature)
            current_feature = start_feature

            while features:
                current_pt = current_feature.geometry().centroid().asPoint()
                next_feature = min(
                    features,
                    key=lambda f: current_pt.sqrDist(f.geometry().centroid().asPoint())
                )
                visited.append(next_feature)
                features.remove(next_feature)
                current_feature = next_feature

            for i, feature in enumerate(visited, start=1):
                oznaczenie_value = f"{i}{symbol}"
                lokalnyId_value = f"1POG-{oznaczenie_value}"

                feature.setAttribute(oznaczenie_field, oznaczenie_value)
                feature.setAttribute(lokalny_field, lokalnyId_value)
                layer.updateFeature(feature)

            processed_symbols += 1
            total_numbered += len(visited)

            self.report(
                f"  Znumerowano {len(visited)} obiektów dla symbolu {symbol}."
            )

            self.progressBar.setValue(idx)

        if processed_symbols == 0:
            self.report("Nie wykonano numeracji – żadna grupa nie spełniała wymagań.")
        else:
            self.report(
                f"Zakończono numerację. Przetworzono {processed_symbols} symboli, "
                f"znumerowano {total_numbered} obiektów."
            )

    def pog_korekta_profilu(self):
        self.report("Rozpoczynam korektę profilu podstawowego...")

        symbol_to_profile = {
            "SW": "teren zabudowy mieszkaniowej wielorodzinnej,teren usług,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SJ": "teren zabudowy mieszkaniowej jednorodzinnej,teren usług,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SZ": "teren zabudowy zagrodowej,teren produkcji w gospodarstwach rolnych,teren akwakultury i obsługi rybactwa,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SU": "teren usług,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SH": "teren handlu wielkopowierzchniowego,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SP": "teren produkcji,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SR": "teren produkcji w gospodarstwach rolnych,teren wielkotowarowej produkcji rolnej,teren akwakultury i obsługi rybactwa,teren komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SI": "teren infrastruktury technicznej,teren komunikacji,teren ogrodów działkowych",
            "SN": "teren zieleni urządzonej,teren plaży,teren wód,teren komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SC": "teren cmentarza,teren komunikacji,teren zieleni urządzonej,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SG": "teren górnictwa i wydobycia,teren komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SO": "teren rolnictwa z zakazem zabudowy,teren lasu,teren zieleni naturalnej,teren wód,teren komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej",
            "SK": "teren autostrady,teren drogi ekspresowej,teren drogi głównej ruchu przyspieszonego,teren drogi głównej,teren komunikacji kolejowej i szynowej,teren komunikacji kolei linowej,teren komunikacji wodnej,teren komunikacji lotniczej,teren obsługi komunikacji,teren ogrodów działkowych,teren infrastruktury technicznej"
        }

        layer = self.iface.activeLayer()
        if not layer:
            self.report("Brak aktywnej warstwy.")
            return

        fields = layer.fields()
        if "symbol" not in fields.names() or "profilPodstawowy" not in fields.names():
            self.report("Brak wymaganych pól.")
            return

        symbol_idx = fields.indexFromName("symbol")
        profile_idx = fields.indexFromName("profilPodstawowy")

        features = list(layer.getFeatures())
        total = len(features)
        if total == 0:
            self.report("Warstwa nie zawiera obiektów.")
            return

        changes = {}

        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        for i, f in enumerate(features, start=1):
            expected = symbol_to_profile.get(f[symbol_idx])
            if expected and f[profile_idx] != expected:
                changes[f.id()] = {profile_idx: expected}
            self.progressBar.setValue(i)

        if changes:
            layer.startEditing()
            layer.dataProvider().changeAttributeValues(changes)
            layer.commitChanges()
            self.report(f"Zaktualizowano {len(changes)} obiektów.")
        else:
            self.report("Nie dokonano żadnych zmian.")

    def pog_korekta_spacje(self):
        self.report("Rozpoczynam korektę spacji w kolumnach...")

        layer = self.iface.activeLayer()
        if not layer:
            self.report("Brak aktywnej warstwy. Wybierz warstwę i spróbuj ponownie.")
            self.progressBar.setValue(0)
            return

        columns_to_process = ["profilPodstawowy", "profilDodatkowy"]
        for col in columns_to_process:
            if col not in layer.fields().names():
                self.report(f"Brak wymaganego pola '{col}'. Operacja przerwana.")
                return

        features = list(layer.getFeatures())
        total = len(features)
        if total == 0:
            self.report("Warstwa nie zawiera obiektów – nic do korekty.")
            self.progressBar.setValue(0)
            return

        field_indexes = {c: layer.fields().indexFromName(c) for c in columns_to_process}
        changes = {}

        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        for idx, f in enumerate(features, start=1):
            fid = f.id()
            attr_changes = {}

            for col in columns_to_process:
                val = f[col]
                if isinstance(val, str):
                    new_val = val.replace(" ,", ",").replace(", ", ",").rstrip().replace("\xa0", " ").replace("\n", "")
                    if new_val != val:
                        attr_changes[field_indexes[col]] = new_val

            if attr_changes:
                changes[fid] = attr_changes

            self.progressBar.setValue(idx)

        if changes:
            layer.startEditing()
            layer.dataProvider().changeAttributeValues(changes)
            layer.commitChanges()
            self.report(f"Zakończono korektę spacji. Zaktualizowano {len(changes)} obiektów.")
        else:
            self.report("Nie dokonano żadnych zmian – wszystkie wartości były poprawne.")

    def pog_zgodnosc(self):
        self.report("Analiza zgodności POG z MPZP - start")
        mpzp_layer = self.mpzp_layer.currentLayer()
        pog_layer = self.pog_layer.currentLayer()
        symbol_col = self.cb_mpzp_symbol_col.currentText()

        if not mpzp_layer or not pog_layer or not symbol_col:
            self.report("Brak warstw lub kolumny symbolu MPZP")
            return

        if mpzp_layer.crs() != pog_layer.crs():
            context = QgsProject.instance().transformContext()
            transform = QgsCoordinateTransform(mpzp_layer.crs(), pog_layer.crs(), context)

            mpzp_mem = QgsVectorLayer(
                f"{QgsWkbTypes.displayString(mpzp_layer.wkbType())}?crs={pog_layer.crs().authid()}",
                f"{mpzp_layer.name()}_reproj",
                "memory"
            )
            prov = mpzp_mem.dataProvider()
            prov.addAttributes(mpzp_layer.fields())
            mpzp_mem.updateFields()

            feats = []
            for f in mpzp_layer.getFeatures():
                g = f.geometry()
                if not g or g.isEmpty():
                    continue
                g = QgsGeometry(g)
                g.transform(transform)

                nf = QgsFeature(mpzp_mem.fields())
                nf.setAttributes(f.attributes())
                nf.setGeometry(g)
                feats.append(nf)

            if not feats:
                self.report("Brak geometrii MPZP po transformacji")
                return

            prov.addFeatures(feats)
            mpzp_mem.updateExtents()
            mpzp_layer = mpzp_mem

        out_layer = QgsVectorLayer(
            "Polygon?crs=" + pog_layer.crs().authid(),
            "Niezgodności",
            "memory"
        )
        out_prov = out_layer.dataProvider()
        out_prov.addAttributes([
            QgsField(symbol_col, QVariant.String),
            QgsField("profilPodstawowy", QVariant.String),
            QgsField("profilDodatkowy", QVariant.String),
            QgsField("symbol", QVariant.String),
        ])
        out_layer.updateFields()

        pog_index = QgsSpatialIndex(pog_layer.getFeatures())

        total = mpzp_layer.featureCount()
        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        RULES = {
            "MN":  [("PP", "teren zabudowy mieszkaniowej jednorodzinnej"),
                    ("PD", "teren zabudowy mieszkaniowej jednorodzinnej")],
            "MNW": [("PP", "teren zabudowy mieszkaniowej jednorodzinnej"),
                    ("PD", "teren zabudowy mieszkaniowej jednorodzinnej")],
            "MNB": [("PP", "teren zabudowy mieszkaniowej jednorodzinnej"),
                    ("PD", "teren zabudowy mieszkaniowej jednorodzinnej")],
            "MNS": [("PP", "teren zabudowy mieszkaniowej jednorodzinnej"),
                    ("PD", "teren zabudowy mieszkaniowej jednorodzinnej")],
            "MW":  [("PP", "teren zabudowy mieszkaniowej wielorodzinnej")],
            "MWK": [("PP", "teren zabudowy mieszkaniowej wielorodzinnej")],
            "MWW": [("PP", "teren zabudowy mieszkaniowej wielorodzinnej")],
            "ML":  [("PD", "teren zabudowy letniskowej lub rekreacji indywidualnej")],
            
            "U":   [("PP", "teren usług"), ("PD", "teren usług")],
            "UH":  [("PP", "teren usług"), ("PD", "teren usług")],
            "UHD": [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług handlu detalicznego")],
            "UHH": [("PP", "teren usług"), ("PD", "teren usług")],
            "UW":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren handlu wielkopowierzchniowego"), ("PP", "teren handlu wielkopowierzchniowego")],
            "UL":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług rzemieślniczych")],
            "UT":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług turystyki")],
            "UG":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług gastronomii")],
            "UZ":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług zdrowia i pomocy społecznej")],
            "UN":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług nauki")],
            "UE":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług edukacji")],
            "UEP": [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług edukacji")],
            "UEO": [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług edukacji")],
            "US":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług sportu i rekreacji")],
            "UK":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług kultury i rozrywki")],
            "UR":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług kultu religijnego")],
            "UB":  [("PP", "teren usług"), ("PD", "teren usług")],
            "UA":  [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług biurowych i administracji")],
            "UAB": [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług biurowych i administracji")],
            "UAA": [("PP", "teren usług"), ("PD", "teren usług"), ("PD", "teren usług biurowych i administracji")],

            "P":   [("PP", "teren produkcji"), ("PD", "teren produkcji")],
            "PP":  [("PP", "teren produkcji"), ("PD", "teren produkcji")],
            "PE":  [("PP", "teren produkcji"), ("PD", "teren produkcji"), 
                    ("PD", "teren elektrowni wiatrowej"), ("PD", "teren elektrowni słonecznej"),
                    ("PD", "teren elektrowni geotermalnej"), ("PD", "teren elektrowni wodnej"), 
                    ("PD", "teren biogazowni")],
            "PEW": [("PP", "teren produkcji"), ("PD", "teren produkcji"), ("PD", "teren elektrowni wiatrowej")],
            "PEF": [("PP", "teren produkcji"), ("PD", "teren produkcji"), ("PD", "teren elektrowni słonecznej")],
            "PS":  [("PP", "teren produkcji"), ("PD", "teren produkcji"), ("PD", "teren składów i magazynów")],
            "PR":  [("PP", "teren produkcji"), ("PD", "teren produkcji")],

            "G":   [("PP", "teren górnictwa i wydobycia")],

            "RN":  [("PP", "teren rolnictwa z zakazem zabudowy"), ("PD", "teren rolnictwa z zakazem zabudowy")],
            "RNR": [("PP", "teren rolnictwa z zakazem zabudowy"), ("PD", "teren rolnictwa z zakazem zabudowy")],
            "RNL": [("PP", "teren rolnictwa z zakazem zabudowy"), ("PD", "teren rolnictwa z zakazem zabudowy")],
            "RZ":  [("PP", "teren zabudowy zagrodowej"), ("PD", "teren wielkotowarowej produkcji rolnej")],
            "RZM": [("PP", "teren zabudowy zagrodowej")],
            "RZP": [("PP", "teren produkcji w gospodarstwach rolnych")],
            "RZW": [("PP", "teren wielkotowarowej produkcji rolnej"), ("PD", "teren wielkotowarowej produkcji rolnej")],
            "RA":  [("PP", "teren akwakultury i obsługi rybactwa")],

            "W":   [("PP", "teren wód"), ("PD", "teren wód")],
            "WM":  [("PP", "teren wód"), ("PD", "teren wód")],
            "WS":  [("PP", "teren wód"), ("PD", "teren wód")],

            "L":   [("PP", "teren lasu"), ("PD", "teren lasu")],

            "Z":   [("PP", "teren plaży")],
            "ZN":  [("PP", "teren zieleni naturalnej"), ("PD", "teren zieleni naturalnej")],
            "ZP":  [("PP", "teren zieleni urządzonej"), ("PD", "teren zieleni urządzonej")],
            "ZPW": [("PP", "teren zieleni urządzonej"), ("PD", "teren zieleni urządzonej")],
            "ZPN": [("PP", "teren zieleni urządzonej"), ("PD", "teren zieleni urządzonej")],
            "ZB":  [("PP", "teren plaży")],

            "C":   [("PP", "teren cmentarza")],
            "CC":  [("PP", "teren cmentarza")],
            "CZ":  [("PP", "teren cmentarza")],
        }

        def always_match(sym):
            return sym == "ZD" or sym.startswith("K") or sym.startswith("I")

        def never_match(sym):
            return sym == "M"

        def check_symbol(sym, pp, pd):
            if sym == "RZ":
                for where, txt in RULES[sym]:
                    if where == "PP" and (not pp or txt not in pp):
                        return False
                    if where == "PD" and (not pd or txt not in pd):
                        return False
                return True
            elif sym == "PE":
                if pp and "teren produkcji" in pp:
                    return True
                if pd and "teren produkcji" in pd:
                    return True
                energy_types = [
                    "teren elektrowni wiatrowej",
                    "teren elektrowni słonecznej",
                    "teren elektrowni geotermalnej",
                    "teren elektrowni wodnej",
                    "teren biogazowni"
                ]
                if pd:
                    if all(et in pd for et in energy_types):
                        return True
                return False

            if always_match(sym):
                return True
            if never_match(sym):
                return False
            if sym not in RULES:
                return False

            for where, txt in RULES[sym]:
                if where == "PP" and pp and txt in pp:
                    return True
                if where == "PD" and pd and txt in pd:
                    return True
            return False

        for i, mpzp_f in enumerate(mpzp_layer.getFeatures()):
            self.progressBar.setValue(i + 1)

            geom = mpzp_f.geometry()
            if not geom or geom.isEmpty():
                continue

            raw = mpzp_f[symbol_col]
            if not raw:
                continue

            raw = str(raw)
            raw = raw.lstrip("0123456789")
            symbols = raw.split("-")

            pog_ids = pog_index.intersects(geom.boundingBox())
            for pid in pog_ids:
                pog_f = pog_layer.getFeature(pid)
                pog_geom = pog_f.geometry()
                if not pog_geom or not geom.intersects(pog_geom):
                    continue

                inter = geom.intersection(pog_geom)
                if not inter or inter.isEmpty():
                    continue

                pp = pog_f["profilPodstawowy"]
                pd = pog_f["profilDodatkowy"]
                pog_sym = pog_f["symbol"] if "symbol" in pog_f.fields().names() else None

                failed = False
                for s in symbols:
                    if not check_symbol(s, pp, pd):
                        failed = True
                        break

                if failed:
                    nf = QgsFeature(out_layer.fields())
                    nf.setGeometry(inter)
                    nf.setAttributes([raw, pp, pd, pog_sym])
                    out_prov.addFeature(nf)

        out_layer.updateExtents()
        QgsProject.instance().addMapLayer(out_layer)

        self.report("Analiza zgodności POG z MPZP - koniec\n")

    def reset_fid_values(self):
        layer = self.iface.activeLayer()
        if not layer or "fid" not in layer.fields().names():
            self.report("Brak warstwy lub pola 'fid'.")
            return

        idx = layer.fields().indexFromName("fid")
        changes = {}

        for f in layer.getFeatures():
            changes[f.id()] = {idx: f.id()}

        layer.startEditing()
        layer.dataProvider().changeAttributeValues(changes)
        layer.commitChanges()

        self.report("Zresetowano kolumnę fid.")

    def numeracja_pol(self):
        self.report("Rozpoczynam numerację wszystkich obiektów...")

        layer = self.iface.activeLayer()
        if not layer:
            self.report("Brak aktywnej warstwy.")
            return

        field_name = "numeracja"
        if field_name not in layer.fields().names():
            layer.startEditing()
            layer.addAttribute(QgsField(field_name, QVariant.String))
            layer.commitChanges()
            layer.updateFields()

        idx = layer.fields().indexFromName(field_name)

        features = [f for f in layer.getFeatures() if f.geometry() and not f.geometry().isEmpty()]
        if not features:
            self.report("Brak obiektów z geometrią.")
            return

        centroids = {f.id(): f.geometry().centroid().asPoint() for f in features}
        features.sort(key=lambda f: (centroids[f.id()].x(), centroids[f.id()].y()))

        changes = {}
        total = len(features)
        self.progressBar.setMaximum(total)
        self.progressBar.setValue(0)

        for i, f in enumerate(features, start=1):
            changes[f.id()] = {idx: str(i)}
            self.progressBar.setValue(i)

        layer.startEditing()
        layer.dataProvider().changeAttributeValues(changes)
        layer.commitChanges()

        self.report(f"Zakończono numerację {total} obiektów.")

    def numeracja_unikalna(self):
        self.report("Rozpoczynam numerację grup obiektów...")

        layer = self.numeracja_layer.currentLayer()
        if not layer:
            self.report("Brak aktywnej warstwy.")
            return

        group_field = self.cb_numeracja_unikalna.currentText()
        if not group_field or group_field not in layer.fields().names():
            self.report("Nieprawidłowe pole grupujące.")
            return

        num_field = "numeracja"
        if num_field not in layer.fields().names():
            layer.startEditing()
            layer.addAttribute(QgsField(num_field, QVariant.String))
            layer.commitChanges()
            layer.updateFields()

        num_idx = layer.fields().indexFromName(num_field)
        groups = layer.uniqueValues(layer.fields().lookupField(group_field))

        self.progressBar.setMaximum(len(groups))
        self.progressBar.setValue(0)

        layer.startEditing()
        total_numbered = 0

        for i, gval in enumerate(groups, start=1):
            feats = [
                f for f in layer.getFeatures(QgsFeatureRequest(QgsExpression(f'"{group_field}" = \'{gval}\'')))
                if f.geometry() and not f.geometry().isEmpty()
            ]
            if not feats:
                self.progressBar.setValue(i)
                continue

            centroids = {f.id(): f.geometry().centroid().asPoint() for f in feats}
            feats.sort(key=lambda f: (centroids[f.id()].x(), centroids[f.id()].y()))

            changes = {f.id(): {num_idx: str(j)} for j, f in enumerate(feats, start=1)}
            layer.dataProvider().changeAttributeValues(changes)

            total_numbered += len(feats)
            self.progressBar.setValue(i)

        layer.commitChanges()
        self.report(f"Zakończono numerację. Zaktualizowano {total_numbered} obiektów.")

    def import_external(self):
        ref_layer = self.layer_area.currentLayer()
        if not ref_layer or not ref_layer.isValid():
            self.report("Nie wybrano warstwy referencyjnej.")
            return

        buffer_value = self.sbBufferValue.value()

        project_gpkg = self.project_path.filePath()
        if not project_gpkg:
            self.report("Nie ustawiono ścieżki do projektu.")
            return

        src_path = self.import_external_path.filePath()
        if not src_path or not os.path.exists(src_path):
            self.report("Nie wybrano poprawnej warstwy źródłowej.")
            return

        input_layer = QgsVectorLayer(src_path, "input", "ogr")
        if not input_layer.isValid():
            self.report("Nie można wczytać warstwy wejściowej.")
            return
        input_crs = input_layer.crs()

        if not input_crs.isValid():
            chosen_crs = self.crs_import_filter_widget.crs()
            if not chosen_crs.isValid():
                self.report(
                    "Warstwa importowana ma nieznany CRS. "
                    "Wybierz CRS i uruchom ponownie."
                )
                return

            input_layer.setCrs(chosen_crs)
            input_crs = chosen_crs
            self.report(f"Ustawiono CRS: {input_crs.authid()}")

        self.crs_import_filter_widget.setCrs(QgsCoordinateReferenceSystem())

        need_transform = ref_layer.crs() != input_crs
        if need_transform:
            xform = QgsCoordinateTransform(
                ref_layer.crs(),
                input_crs,
                QgsProject.instance()
            )
        self.report("Budowanie indeksu przestrzennego…")
        QtWidgets.QApplication.processEvents()

        index = QgsSpatialIndex()
        ref_geoms = {}

        for f in ref_layer.getFeatures():
            geom = f.geometry()
            if not geom:
                continue

            geom = QgsGeometry(geom)

            if need_transform:
                geom.transform(xform)

            if buffer_value > 0:
                geom = geom.buffer(buffer_value, 5)
            idx_feat = QgsFeature()
            idx_feat.setId(f.id())
            idx_feat.setGeometry(geom)

            index.addFeature(idx_feat)
            ref_geoms[f.id()] = geom

        if not ref_geoms:
            self.report("Warstwa referencyjna nie zawiera geometrii.")
            return

        custom_name = self.te_import_external_name.text().strip()
        base_name = os.path.splitext(os.path.basename(src_path))[0]
        layer_name = custom_name if custom_name else base_name

        if buffer_value > 0:
            layer_name += f"_bufor{buffer_value}"

        if self.cb_date_suffix.isChecked():
            layer_name += "_" + datetime.now().strftime("%Y_%m_%d")

        self.report(f"Import: {layer_name}")
        QtWidgets.QApplication.processEvents()
        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = "GPKG"
        options.layerName = layer_name
        options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
        options.encoding = "UTF-8"

        writer = QgsVectorFileWriter.create(
            project_gpkg,
            input_layer.fields(),
            input_layer.wkbType(),
            input_layer.crs(),
            QgsProject.instance().transformContext(),
            options
        )

        if writer.hasError() != QgsVectorFileWriter.NoError:
            self.report(writer.errorMessage())
            return

        added = 0

        for f in input_layer.getFeatures():
            geom = f.geometry()
            if not geom:
                continue

            candidate_ids = index.intersects(geom.boundingBox())
            if not candidate_ids:
                continue

            for fid in candidate_ids:
                if geom.intersects(ref_geoms[fid]):
                    writer.addFeature(f)
                    added += 1
                    break
        del writer
        if added == 0:
            self.report(f"Pominięto {layer_name} – brak przecięć.")
            return

        self.progressBar.setValue(100)
        self.report(f"Dodano {added} obiektów.")
        self.report("Operacja zakończona.\n")
        
    def import_external_filter(self):
        project_gpkg = self.project_path.filePath()
        if not project_gpkg:
            self.report("Nie ustawiono ścieżki do projektu.")
            return

        src_path = self.import_external_filter_path.filePath()
        if not src_path or not os.path.exists(src_path):
            self.report("Nie wybrano poprawnej warstwy źródłowej.")
            return

        field_name = self.cb_import_external_filter.currentText()
        if not field_name:
            self.report("Nie wybrano kolumny do filtrowania.")
            return

        filter_value = self.le_filter.text().strip()
        if filter_value == "":
            self.report("Nie podano wartości filtra.")
            return

        layer = QgsVectorLayer(src_path, "src", "ogr")
        if not layer.isValid():
            self.report("Nie można wczytać warstwy źródłowej.")
            return

        if field_name not in layer.fields().names():
            self.report(f"Kolumna '{field_name}' nie istnieje.")
            return

        # output name
        base_name = self.te_import_external_filter_name.text().strip()
        if not base_name:
            base_name = os.path.splitext(os.path.basename(src_path))[0]

        if self.cb_date__filter_suffix.isChecked():
            base_name += "_" + datetime.now().strftime("%Y_%m_%d")

        self.report(
            f"Importuję obiekty gdzie {field_name} = '{filter_value}' → {base_name}"
        )
        QtWidgets.QApplication.processEvents()

        safe_value = filter_value.replace("'", "''")
        expr = QgsExpression(f"\"{field_name}\" = '{safe_value}'")

        request = QgsFeatureRequest(expr)
        request.setNoAttributes()
        request.setFlags(QgsFeatureRequest.NoGeometry)

        count = 0
        for _ in layer.getFeatures(request):
            count += 1

        if count == 0:
            self.report("Brak obiektów spełniających warunek.")
            return

        request = QgsFeatureRequest(expr)

        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = "GPKG"
        options.layerName = base_name
        options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
        options.encoding = "UTF-8"

        writer = QgsVectorFileWriter.create(
            project_gpkg,
            layer.fields(),
            layer.wkbType(),
            layer.crs(),
            QgsProject.instance().transformContext(),
            options
        )

        processed = 0
        self.progressBar.setValue(0)

        for f in layer.getFeatures(request):
            writer.addFeature(f)
            processed += 1

            if processed % 200 == 0:
                self.progressBar.setValue(int(processed / count * 100))
                QtWidgets.QApplication.processEvents()

        del writer

        self.progressBar.setValue(100)
        self.report(f"Dodano {processed} obiektów.")
        self.report("Import zakończony.\n")

    def report_intersections(
        self,
        layer: QgsVectorLayer,
        filter_geom: QgsGeometry,
        fields: list[str] | None,
        existence_only: bool = False,) -> int:

        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()
        bbox = filter_geom.boundingBox()

        request = QgsFeatureRequest()
        request.setFilterRect(bbox)

        count = 0

        for f in layer.getFeatures(request):
            g = f.geometry()
            if not g or g.isEmpty():
                continue

            if engine.intersects(g.constGet()):
                count += 1

                if existence_only:
                    return 1

                if fields:
                    vals = []
                    for fld in fields:
                        v = f.attribute(fld)
                        vals.append("" if v is None else str(v))
                    self.report(" | ".join(vals))
                    QtWidgets.QApplication.processEvents()

        return count

    def anal_fop(self):
        self.report("Analiza FOP - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.report("Brak funkcji w layer_area lub buforze.")
            return

        resource_base = self.resource_path.filePath()

        layers = {
            "DANE_AKTUALIZOWANE/FOP/FOP_ObszaryChronionegoKrajobrazu.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_ObszarySpecjalnejOchrony.gpkg": ["kod", "nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_SpecjalneObszaryOchrony.gpkg": ["kod", "nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_ParkiKrajobrazowe.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_ParkiNarodowe.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_Rezerwaty.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_UzytkiEkologiczne.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_ZespolyPrzyrodniczoKrajobrazowe.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_StanowiskaDokumentacyjne.gpkg": ["nazwa"],
            "DANE_AKTUALIZOWANE/FOP/FOP_PomnikiPrzyrody_powierzchniowe.gpkg": None,
            "DANE_AKTUALIZOWANE/FOP/FOP_PomnikiPrzyrody_punktowe.gpkg": None,
        }

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        for rel_path, fields in layers.items():
            abs_path = os.path.join(resource_base, rel_path)
            self.report(f"\nWarstwa: {rel_path}")

            if not os.path.exists(abs_path):
                self.report("Plik nie istnieje.")
                continue

            layer = QgsVectorLayer(abs_path, "src", "ogr")
            if not layer.isValid():
                self.report("Nie można wczytać warstwy.")
                continue

            request = QgsFeatureRequest().setFilterRect(bbox)

            matches = []
            for f in layer.getFeatures(request):
                g = f.geometry()
                if g and engine.intersects(g.constGet()):
                    matches.append(f)

            count = len(matches)
            if count == 0:
                self.report("Brak przecięć.")
                continue

            self.report(f"Liczba przecięć: {count}")

            if not fields:
                continue

            is_uzytki = rel_path.endswith("FOP_UzytkiEkologiczne.gpkg")
            if is_uzytki and count > 10:
                self.report("    > 10 obiektów – pominięto listę nazw.")
                continue

            for f in matches:
                vals = [str(f[fld]) for fld in fields if f[fld] is not None]
                if vals:
                    self.report(" | ".join(vals))

        self.report("Analiza FOP - koniec\n")

    def anal_fop_10km(self):
        import os
        from qgis.PyQt import QtWidgets

        self.report("Analiza FOP 10 km - start")
        QtWidgets.QApplication.processEvents()

        area_layer = self.layer_area_2180()
        if not area_layer or area_layer.featureCount() == 0:
            self.report("Brak warstwy obszaru odniesienia.")
            return

        area_geom = None
        for f in area_layer.getFeatures():
            g = f.geometry()
            if g and not g.isEmpty():
                area_geom = g if area_geom is None else area_geom.combine(g)

        if not area_geom:
            self.report("Nie udało się zbudować geometrii obszaru.")
            return

        buffer_geom = area_geom.buffer(10_000, 8)
        bbox = buffer_geom.boundingBox()

        engine_buf = QgsGeometry.createGeometryEngine(buffer_geom.constGet())
        engine_buf.prepareGeometry()

        engine_area = QgsGeometry.createGeometryEngine(area_geom.constGet())
        engine_area.prepareGeometry()

        resource_base = self.resource_path.filePath()
        if not resource_base:
            self.report("Brak ustawionej ścieżki do zasobów.")
            return

        layers = {
            "DANE_AKTUALIZOWANE/FOP/FOP_ObszaryChronionegoKrajobrazu.gpkg": ("Obszar Chronionego Krajobrazu", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_ObszarySpecjalnejOchrony.gpkg": ("Obszar Natura 2000", ["nazwa", "kod"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_SpecjalneObszaryOchrony.gpkg": ("Obszar Natura 2000", ["nazwa", "kod"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_ParkiKrajobrazowe.gpkg": ("Park Krajobrazowy", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_ParkiNarodowe.gpkg": ("Park Narodowy", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_Rezerwaty.gpkg": ("Rezerwat przyrody", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_UzytkiEkologiczne.gpkg": ("Użytek ekologiczny", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_ZespolyPrzyrodniczoKrajobrazowe.gpkg": ("Zespół przyrodniczo-krajobrazowy", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_StanowiskaDokumentacyjne.gpkg": ("Stanowisko dokumentacyjne", ["nazwa"]),
            "DANE_AKTUALIZOWANE/FOP/FOP_PomnikiPrzyrody_powierzchniowe.gpkg": ("Pomniki przyrody powierzchniowe", None),
            "DANE_AKTUALIZOWANE/FOP/FOP_PomnikiPrzyrody_punktowe.gpkg": ("Pomniki przyrody punktowe", None),
        }

        angle_ranges = [
            ((337.5, 360.0), "północ"),
            ((0.0, 22.5), "północ"),
            ((22.5, 67.5), "północny wschód"),
            ((67.5, 112.5), "wschód"),
            ((112.5, 157.5), "południowy wschód"),
            ((157.5, 202.5), "południe"),
            ((202.5, 247.5), "południowy zachód"),
            ((247.5, 292.5), "zachód"),
            ((292.5, 337.5), "północny zachód"),
        ]

        def azimuth_label(az):
            az = az % 360
            for (a, b), txt in angle_ranges:
                if a <= az < b:
                    return txt
            return "północ"

        for rel_path, (prefix, fields) in layers.items():
            abs_path = os.path.join(resource_base, rel_path)
            layer_name = os.path.basename(rel_path)

            if not os.path.exists(abs_path):
                continue

            layer = QgsVectorLayer(abs_path, layer_name, "ogr")
            if not layer.isValid():
                continue

            request = QgsFeatureRequest().setFilterRect(bbox)
            matches = []

            for f in layer.getFeatures(request):
                g = f.geometry()
                if g and engine_buf.intersects(g.constGet()):
                    matches.append(f)

            if not matches:
                continue

            if fields is None:
                self.report(f"{prefix}: {len(matches)}")
                continue

            if "UzytkiEkologiczne" in layer_name and len(matches) > 10:
                self.report(f"Użytki ekologiczne: {len(matches)}")
                continue

            for f in matches:
                parts = [prefix]

                for fld in fields:
                    val = f[fld]
                    if val:
                        parts.append(str(val))

                g = f.geometry()

                if engine_area.intersects(g.constGet()):
                    parts.append("- w obszarze")
                else:
                    try:
                        pt = g.centroid().asPoint()
                        # najpierw znajdź najbliższy punkt na granicy obszaru
                        _, p_area, _, _ = area_geom.closestSegmentWithContext(pt)
                        # potem najbliższy punkt na granicy obiektu względem tego punktu
                        _, p_obj, _, _ = g.closestSegmentWithContext(p_area)

                        if p_area and p_obj:
                            # azymut od granicy obszaru do obiektu
                            az = p_area.azimuth(p_obj)
                        else:
                            az = 0
                    except Exception:
                        az = 0

                    az = az % 360

                    dist_km = round(area_geom.distance(g) / 1000, 1)
                    dist_txt = f"{dist_km:.1f}".replace(".", ",")

                    parts.append(f"- {dist_txt} km na {azimuth_label(az)}")

                self.report(" ".join(parts))

        self.report("Analiza FOP 10 km - koniec\n")

    def anal_adm(self):
        self.report("Analiza ADMINISTRACYJNE - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        base = self.resource_path.filePath()

        if not filter_geom:
            self.report("Brak layer_area.")
            return

        layers = {
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_Gminy.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_MorskieLinieBrzegowe.gpkg": None,
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_MorskieWodyWewnetrzne.gpkg": None,
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_Nadlesnictwa.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_ObrebyEwidencyjne.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_PasOchronny.gpkg": None,
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_PasTechniczny.gpkg": None,
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_Powiaty.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_Wojewodztwa.gpkg": ["JPT_NAZWA_"],
            "DANE_AKTUALIZOWANE/ADMINISTRACYJNE/ADM_ZarzadyZlewni.gpkg": ["ZZ_MIASTO", "RZGW"],
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if fields is None:
                self.report(
                    f"{name}: {'istnieje' if os.path.exists(path) else 'NIE istnieje'}."
                )
                self.progressBar.setValue(int(i / total * 100))
                continue

            if not os.path.exists(path):
                self.report(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.report(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.report(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.report("Analiza ADMINISTRACYJNE zakończona.\n")

    def anal_pig(self):
        self.report("Analiza PIG - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.report("Brak funkcji w layer_area.")
            return

        base = self.resource_path.filePath()
        layers = {
            "DANE_AKTUALIZOWANE/PIG/PIG_ObszaryGornicze.gpkg": ["NAZWA_OG"],
            "DANE_AKTUALIZOWANE/PIG/PIG_TerenyGornicze.gpkg": ["NAZWA_TG"],
            "DANE_AKTUALIZOWANE/PIG/PIG_UdokumentowaneZloza.gpkg": ["SYMBOL_KOP", "NR_ZLOZA", "NAZWA_ZL"],
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if not os.path.exists(path):
                self.report(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.report(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.report(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.report("Analiza PIG zakończona.\n")

    def anal_wody(self):
        self.report("Analiza WODY - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.report("Brak funkcji w layer_area.")
            return

        base = self.resource_path.filePath()
        layers = {
            "DANE_PGW_GZWP/WODY_GZWP.gpkg": ["NR_GZWP", "NAZWA"],
            "DANE_PGW_GZWP/WODY_JCWP_pozostale.gpkg": ["MS_KOD", "Nazwa_JCWP"],
            "DANE_PGW_GZWP/WODY_JCWPd.gpkg": ["kod_jcwpd"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_jeziorne.gpkg": ["MS_KOD"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_przejsciowe.gpkg": ["MS_KOD"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_przybrzezne.gpkg": ["MS_KOD"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_rzeczne.gpkg": ["MS_KOD"],
            "DANE_PGW_GZWP/WODY_Zlewnie_JCWP_zbiornikowe.gpkg": ["MS_KOD"],
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if not os.path.exists(path):
                self.report(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.report(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.report(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.report("Analiza WODY zakończona.\n")

    def anal_powodz(self):
        self.report("Analiza POWODZ - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.report("Brak funkcji w layer_area.")
            return

        base = self.resource_path.filePath()
        layers = {
            "DANE_POWODZ/POWODZ_rzeka_10.gpkg": None,
            "DANE_POWODZ/POWODZ_rzeka_100.gpkg": None,
            "DANE_POWODZ/POWODZ_rzeka_500.gpkg": None,
            "DANE_POWODZ/POWODZ_rzeka_WZ.gpkg": None,
            "DANE_POWODZ/POWODZ_morze_100.gpkg": None,
            "DANE_POWODZ/POWODZ_morze_500.gpkg": None,
            "DANE_POWODZ/POWODZ_morze_WZ.gpkg": None,
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if not os.path.exists(path):
                self.report(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.report(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.report(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.report("Analiza POWODZ zakończona.\n")

    def anal_inne(self):
        self.report("Analiza INNE - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.report("Brak funkcji w layer_area lub buforze.")
            return

        resource_base = self.resource_path.filePath()

        layers = {
            "DANE_INNE/INNE_Mezoregiony.gpkg": ["k_MEZO", "n_MEZO"],
            "DANE_INNE/INNE_PKP_halas_imisja_LDWN.gpkg": ["CATEGORY"],
            "DANE_INNE/INNE_PKP_halas_imisja_LN.gpkg": ["CATEGORY"],
            "DANE_INNE/INNE_Potencjalna_roslinnosc_naturalna.gpkg": ["kod", "nazwa_PL"],
            "DANE_INNE/INNE_Torfowiska_alkaliczne.gpkg": None,
            "DANE_INNE/INNE_Wos_1999_regiony_klimatyczne.gpkg": ["numer", "nazwa"],
            "DANE_INNE/INNE_Korytarze_ekologiczne.gpkg": ["nazwa"],
        }

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        for rel_path, fields in layers.items():
            abs_path = os.path.join(resource_base, rel_path)
            self.report(f"\nWarstwa: {rel_path}")

            if not os.path.exists(abs_path):
                self.report("Plik nie istnieje.")
                continue

            layer = QgsVectorLayer(abs_path, "src", "ogr")
            if not layer.isValid():
                self.report("Nie można wczytać warstwy.")
                continue

            field_names = set(layer.fields().names())
            request = QgsFeatureRequest().setFilterRect(bbox)

            count = 0
            is_roslinnosc = rel_path.endswith("INNE_Potencjalna_roslinnosc_naturalna.gpkg")
            unique_rows = set()

            for f in layer.getFeatures(request):
                g = f.geometry()
                if not g or not engine.intersects(g.constGet()):
                    continue

                count += 1

                if not fields:
                    continue

                values = []
                for fld in fields:
                    if fld not in field_names:
                        values = []
                        break
                    val = f.attribute(fld)
                    values.append("" if val is None else str(val))

                if not values:
                    continue

                if is_roslinnosc:
                    unique_rows.add(tuple(values))
                else:
                    self.report(" | ".join(values))

            if count == 0:
                self.report("Brak przecięć.")
                continue

            self.report(f"Liczba przecięć: {count}")

            if is_roslinnosc and unique_rows:
                for row in sorted(unique_rows):
                    self.report(" | ".join(row))

        self.report("Analiza INNE zakończona.\n")

    def anal_oze(self):
        self.report("Analiza OZE - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.report("Brak funkcji w layer_area.")
            return

        base = self.resource_path.filePath()
        layers = {
            "DANE_AKTUALIZOWANE/OZE/OZE_elektrownie_wiatrowe.gpkg": None,
            "DANE_AKTUALIZOWANE/OZE/OZE_biogazownie.gpkg": None,
            "DANE_AKTUALIZOWANE/OZE/OZE_fotowoltaika.gpkg": None,
        }

        total = len(layers)
        for i, (rel, fields) in enumerate(layers.items(), 1):
            path = os.path.join(base, rel)
            name = os.path.basename(path)

            if not os.path.exists(path):
                self.report(f"{name}: brak pliku.")
                continue

            layer = QgsVectorLayer(path, name, "ogr")
            self.report(f"{name}:")
            count = self.report_intersections(layer, filter_geom, fields)
            self.report(f"Liczba: {count}\n")

            self.progressBar.setValue(int(i / total * 100))

        self.report("Analiza OZE zakończona.\n")

    def anal_lasy(self):
        self.report("Analiza LASY - start")
        QtWidgets.QApplication.processEvents()

        filter_geom = self.build_filter_geometry()
        if not filter_geom:
            self.report("Brak funkcji w layer_area lub buforze.")
            return

        resource_base = self.resource_path.filePath()
        rel_path = "DANE_INNE/INNE_Lasy_BDL.gpkg"
        abs_path = os.path.join(resource_base, rel_path)

        self.progressBar.setValue(0)

        if not os.path.exists(abs_path):
            self.report("Plik nie istnieje.")
            return

        layer = QgsVectorLayer(abs_path, "src", "ogr")
        if not layer.isValid():
            self.report("Nie można wczytać warstwy.")
            return

        bbox = filter_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(filter_geom.constGet())
        engine.prepareGeometry()

        field_names = set(layer.fields().names())
        required_fields = ["site_type", "forest_fun", "prot_categ"]

        missing_fields = [f for f in required_fields if f not in field_names]
        if missing_fields:
            self.report(
                "Brak kolumn: " + ", ".join(missing_fields)
            )

        request = QgsFeatureRequest().setFilterRect(bbox)

        matches = []
        for f in layer.getFeatures(request):
            g = f.geometry()
            if not g or g.isEmpty():
                continue

            if engine.intersects(g.constGet()):
                try:
                    inter = g.intersection(filter_geom)
                except Exception:
                    continue

                if not inter or inter.isEmpty():
                    continue

                matches.append((f, inter))

        if not matches:
            self.report("Brak przecięć.")
            return

        total_area = 0.0
        for _, g in matches:
            total_area += g.area()

        analysis_area = total_area / 10000.0
        self.report(f"Powierzchnia wszystkich wydzieleń [ha]: {analysis_area:.2f}")

        QtWidgets.QApplication.processEvents()
        self.progressBar.setValue(25)

        def dissolve_by_field(field_name: str):
            if field_name not in field_names:
                self.report(f"Brak kolumny: {field_name}")
                return

            groups: dict[str, float] = {}

            for f, g in matches:
                val = f.attribute(field_name)
                key = "" if val is None else str(val).strip()

                if not key:
                    key = "(puste)"

                groups.setdefault(key, 0.0)
                groups[key] += g.area()

            if not groups:
                self.report(f"Brak danych w kolumnie: {field_name}")
                return

            self.report(f"\nAnaliza: {field_name}")

            for key, area_m2 in sorted(groups.items(), key=lambda x: -x[1]):
                area_ha = area_m2 / 10000.0
                pct = (area_ha / analysis_area * 100.0) if analysis_area > 0 else 0.0
                self.report(
                    f"{key}: {area_ha:.2f} ha ({pct:.2f} %)"
                )
                QtWidgets.QApplication.processEvents()

        dissolve_by_field("site_type")
        self.progressBar.setValue(50)

        dissolve_by_field("forest_fun")
        self.progressBar.setValue(75)

        dissolve_by_field("prot_categ")
        self.progressBar.setValue(100)

        self.report("Analiza LASY zakończona.\n")
        QtWidgets.QApplication.processEvents()

    def list_project_gpkg_layers(self) -> list[str]:
        gpkg = self.project_path.filePath()
        if not gpkg or not os.path.isfile(gpkg):
            return []

        try:
            conn = sqlite3.connect(gpkg)
            cur = conn.cursor()
            cur.execute(
                "SELECT table_name FROM gpkg_contents WHERE data_type = 'features'"
            )
            return [row[0] for row in cur.fetchall()]
        finally:
            conn.close()

    def load_layers(self):
        table = self.table_gpkg
        table.setRowCount(0)
        table.setColumnCount(2)
        table.setHorizontalHeaderLabels([" ", "Nazwa warstwy"])

        layers = self.list_project_gpkg_layers()

        for i, name in enumerate(layers):
            table.insertRow(i)

            chk = QTableWidgetItem()
            chk.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
            chk.setCheckState(Qt.Unchecked)
            table.setItem(i, 0, chk)

            table.setItem(i, 1, QTableWidgetItem(name))

        if table.rowCount() > 0:
            width = table.sizeHintForIndex(
                table.model().index(0, 0)
            ).width()
        else:
            width = 25

        table.setColumnWidth(0, width + 10)
        table.horizontalHeader().setStretchLastSection(True)

        self.report("Tabela zaktualizowana.")

    def delete_selected_layers(self):
        table = self.table_gpkg
        rows_to_delete = [r for r in range(table.rowCount()) if table.item(r, 0).checkState() == Qt.Checked]
        if not rows_to_delete:
            self.report("Brak wybranych warstw do usunięcia.")
            return

        from PyQt5.QtWidgets import QMessageBox
        confirm = QMessageBox.question(
            self,
            "Potwierdzenie usunięcia",
            f"Czy na pewno usunąć {len(rows_to_delete)} wybrane warstwy?",
            QMessageBox.Yes | QMessageBox.No
        )
        if confirm != QMessageBox.Yes:
            self.report("Operacja zabortowana przez użytkownika.")
            return

        self.report(f"Usuwanie {len(rows_to_delete)} wybranych warstw...")
        layers_to_delete = [table.item(r, 1).text() for r in rows_to_delete]
        try:
            conn = sqlite3.connect(self.project_path.filePath())
            cursor = conn.cursor()
            for layer in layers_to_delete:
                cursor.execute(f"DROP TABLE IF EXISTS '{layer}'")
                cursor.execute(f"DELETE FROM gpkg_contents WHERE table_name='{layer}'")
                cursor.execute(f"DELETE FROM gpkg_geometry_columns WHERE table_name='{layer}'")
                self.report(f"Usunięto warstwę: {layer}")
            conn.commit()
            conn.close()
            self.load_layers()
            self.report("Usuwanie zakończone, tabela zaktualizowana.")
        except Exception as e:
            self.report(f"Błąd usuwania warstw: {e}")

    def rename_selected_layer(self):
        table = self.table_gpkg
        rows_checked = [r for r in range(table.rowCount()) if table.item(r, 0).checkState() == Qt.Checked]
        if len(rows_checked) != 1:
            self.report("Zaznacz tylko jedną warstwę do zmiany nazwy.")
            return

        row = rows_checked[0]
        old_name = table.item(row, 1).text()
        new_name, ok = QInputDialog.getText(self, "Rename Layer", "New name:", text=old_name)
        if not ok or not new_name:
            self.report("Zmiana nazwy anulowana.")
            return

        try:
            conn = sqlite3.connect(self.project_path.filePath())
            cursor = conn.cursor()
            cursor.execute(f"ALTER TABLE '{old_name}' RENAME TO '{new_name}'")
            cursor.execute(f"UPDATE gpkg_contents SET table_name='{new_name}' WHERE table_name='{old_name}'")
            cursor.execute(f"UPDATE gpkg_geometry_columns SET table_name='{new_name}' WHERE table_name='{old_name}'")
            conn.commit()
            conn.close()
            self.load_layers()
            self.report(f"Nazwę warstwy '{old_name}' zmieniono na '{new_name}' i odświeżono tabelę.")
        except Exception as e:
            self.report(f"Błąd zmiany nazwy: {e}")

    def vacuum_gpkg(self):
        try:
            conn = sqlite3.connect(self.project_path.filePath())
            conn.execute("VACUUM")
            conn.close()
            self.report("Geopaczka odkurzona.")
        except Exception as e:
            self.report(f"Błąd odkurzania geopaczki: {e}")

    def wind_area_2180(self):
        layer = self.wind_area.currentLayer()
        if layer is None:
            self.report("Nie wybrano warstwy z elektrowniami.")
            return None

        if layer.featureCount() == 0:
            self.report("Wybrana warstwa jest pusta.")
            return None

        if layer.crs().authid() == "EPSG:2180":
            return layer

        disp = QgsWkbTypes.displayString(layer.wkbType())
        uri = f"{disp}?crs=EPSG:2180"
        mem = QgsVectorLayer(uri, "wind_area_2180_tmp", "memory")
        mem_dp = mem.dataProvider()
        mem_dp.addAttributes(layer.fields())
        mem.updateFields()

        transform = QgsCoordinateTransform(
            layer.crs(),
            QgsCoordinateReferenceSystem("EPSG:2180"),
            QgsProject.instance()
        )

        feats = []
        for f in layer.getFeatures():
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            g = QgsGeometry(g)
            g.transform(transform)
            nf = QgsFeature(mem.fields())
            nf.setGeometry(g)
            nf.setAttributes(f.attributes())
            feats.append(nf)

        if not feats:
            self.report("Nieudana transformacja warstwy z elektrowniami.")
            return None

        mem_dp.addFeatures(feats)
        return mem

    def wind_area_buffer_5000(self) -> QgsGeometry | None:
        area = self.wind_area_2180()
        if not area:
            return None

        geom = None
        for f in area.getFeatures():
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            g = g.buffer(5000, 8)
            geom = g if geom is None else geom.combine(g)

        return geom

    def get_matching_teryt_codes_wind(self) -> set[str]:
        buffer_geom = self.wind_area_buffer_5000()
        if not buffer_geom:
            self.report("Brak geometrii bufora 5000 m.")
            return set()

        powiat_path = os.path.join(
            self.resource_path.filePath(),
            "DANE_BDOT", "HELP", "POWIAT_TERYT.gpkg"
        )

        layer = QgsVectorLayer(powiat_path, "powiat", "ogr")
        if not layer.isValid():
            self.report("Nie można wczytać POWIAT_TERYT.")
            return set()

        bbox = buffer_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(buffer_geom.constGet())
        engine.prepareGeometry()

        teryt = set()
        req = QgsFeatureRequest().setFilterRect(bbox)

        for f in layer.getFeatures(req):
            g = f.geometry()
            if g and engine.intersects(g.constGet()):
                teryt.add(str(f["JPT_KOD_JE"]))
        return teryt

    def wind_spatial_filter(self):
        buffer_geom = self.wind_area_buffer_5000()
        if not buffer_geom:
            return None, None

        bbox = buffer_geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(buffer_geom.constGet())
        engine.prepareGeometry()

        return bbox, engine

    def add_buffer_layer(self, geom: QgsGeometry, name: str):
        layer = QgsVectorLayer("Polygon?crs=EPSG:2180", name, "memory")
        pr = layer.dataProvider()
        pr.addAttributes([QgsField("typ", QVariant.String)])
        layer.updateFields()

        f = QgsFeature(layer.fields())
        f.setGeometry(geom)
        f["typ"] = "strefa"
        pr.addFeature(f)

        QgsProject.instance().addMapLayer(layer)

    def anal_wind_build_base(self, gpkg_name: str) -> list[QgsFeature]:
        teryt_codes = self.get_matching_teryt_codes_wind()
        if not teryt_codes:
            return []

        bbox, engine = self.wind_spatial_filter()
        if not bbox:
            return []

        src = os.path.join(self.resource_path.filePath(), "DANE_BDOT", gpkg_name)
        layer = QgsVectorLayer(src, "src", "ogr")
        if not layer.isValid():
            self.report(f"Błąd wczytania {gpkg_name}")
            return []

        req = QgsFeatureRequest()
        req.setFilterRect(bbox)
        req.setSubsetOfAttributes(layer.fields().names(), layer.fields())

        feats = []
        for f in layer.getFeatures(req):
            if str(f["TERYT"]) not in teryt_codes:
                continue

            g = f.geometry()
            if g and engine.intersects(g.constGet()):
                feats.append(f)

        self.report(f"{gpkg_name}: {len(feats)} obiektów po filtrach.")
        return feats

    def anal_wind_pobliska(self):
        layer = self.wind_area_2180()
        if not layer:
            self.report("Brak wybranej warstwy z elektrowniami wiatrowymi.")
            return

        buffer_dist = self.sbWindHeight.value() * 10

        geom = None
        for f in layer.getFeatures():
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            g = g.buffer(buffer_dist, 5)
            geom = g if geom is None else geom.combine(g)

        if geom is None:
            return

        bbox = geom.boundingBox()
        engine = QgsGeometry.createGeometryEngine(geom.constGet())
        engine.prepareGeometry()

        gminy_path = os.path.join(
            self.resource_path.filePath(),
            "DANE_AKTUALIZOWANE",
            "ADMINISTRACYJNE",
            "ADM_Gminy.gpkg"
        )

        gminy = QgsVectorLayer(gminy_path, "ADM_Gminy", "ogr")
        if not gminy.isValid():
            return

        names = set()
        req = QgsFeatureRequest().setFilterRect(bbox)

        for f in gminy.getFeatures(req):
            g = f.geometry()
            if g and engine.intersects(g.constGet()):
                names.add(str(f["JPT_NAZWA_"]))

        for n in sorted(names):
            self.report(f"Gmina pobliska: {n}")

    def anal_wind_build_700(self):
        feats = self.anal_wind_build_base("OT_BUBD_A.gpkg")
        feats = [f for f in feats if f["KODKST"] == "110"]

        if not feats:
            self.report("Brak budynków (KODKST=110).")
            return

        geom = None
        for f in feats:
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            g = g.buffer(700, 8)
            geom = g if geom is None else geom.combine(g)

        if not geom:
            return
        self.add_buffer_layer(geom, "Bufor_budynki_mieszkalne_700m")
        self.report(f"Dodano warstwę z buforem od budynków mieszkalnych.")

    def anal_wind_build_700_rad(self):
        feats = self.anal_wind_build_base("OT_BUBD_A.gpkg")
        feats = [f for f in feats if f["KODKST"] == "110"]

        if not feats:
            self.report("Brak budynków (KODKST=110).")
            return

        buffer_dist = 700 + self.sbWindRadius.value()

        geom = None
        for f in feats:
            g = f.geometry()
            if not g or g.isEmpty():
                continue
            g = g.buffer(buffer_dist, 8)
            geom = g if geom is None else geom.combine(g)

        if not geom:
            return
        self.add_buffer_layer(geom, "Bufor_budynki_mieszkalne_700m_rotor")
        self.report(f"Dodano warstwę z buforem od budynków mieszkalnych + długość rotora.")

    def anal_wind_elect(self):
        allowed = {
            "linia elektroenergetyczna najwyższego napięcia",
            "linia elektroenergetyczna wysokiego napięcia"
        }

        feats = self.anal_wind_build_base("OT_SULN_L.gpkg")
        feats = [f for f in feats if f["RODZAJ"] in allowed]

        if not feats:
            self.report("Brak linii elektroenergetycznych wysokiego napięcia/najwyższych napięć w sąsiedztwie (5000 m).")
            return

        buffer_rad = 3 * self.sbWindRadius.value()
        buffer_h = 2 * self.sbWindHeight.value()

        geom_rad = None
        geom_h = None

        for f in feats:
            g = f.geometry()
            if not g or g.isEmpty():
                continue

            if buffer_rad > 0:
                g_rad = g.buffer(buffer_rad, 8)
                geom_rad = g_rad if geom_rad is None else geom_rad.combine(g_rad)

            if buffer_h > 0:
                g_h = g.buffer(buffer_h, 8)
                geom_h = g_h if geom_h is None else geom_h.combine(g_h)

        if geom_rad:
            self.add_buffer_layer(
                geom_rad,
                f"Bufor_linie_elektroenergetyczne_{buffer_rad}m"
            )
            self.report(f"Dodano warstwę z buforem od linii elektroenergetycznych {buffer_rad} m.")

        if geom_h:
            self.add_buffer_layer(
                geom_h,
                f"Bufor_linie_elektroenergetyczne_{buffer_h}m"
            )
            self.report(f"Dodano warstwę z buforem od linii elektroenergetycznych {buffer_h} m.")

    def anal_pog_building_core(self, use_flood: bool):

        use_strefy = self.cb_use_pog_strefa.isChecked()

        if use_flood:
            self.report("Rozpoczynam obliczanie wskaźników dla działek z budynkami zagrożonymi powodzią - wybór warstw")
        else:
            self.report("Rozpoczynam obliczanie wskaźników dla wszystkich działek z budynkami - wybór warstw")

        feedback = QgsProcessingFeedback()
        project = QgsProject.instance()

        def select_layer(msg):
            layers = [l for l in project.mapLayers().values() if isinstance(l, QgsVectorLayer)]
            if not layers:
                QMessageBox.critical(None, "Error", "Brak warstw wektorowych w projekcie")
                raise RuntimeError
            names = [l.name() for l in layers]
            name, ok = QInputDialog.getItem(None, "Wybór warstwy", msg, names, 0, False)
            if not ok:
                raise RuntimeError
            return project.mapLayersByName(name)[0]

        def fix_geoms(layer):
            return processing.run(
                "native:fixgeometries",
                {"INPUT": layer, "OUTPUT": "memory:"},
                feedback=feedback
            )["OUTPUT"]

        def ensure_epsg2180(layer):
            if layer.crs().authid() != "EPSG:2180":
                layer = processing.run(
                    "native:reprojectlayer",
                    {
                        "INPUT": layer,
                        "TARGET_CRS": "EPSG:2180",
                        "OUTPUT": "memory:"
                    },
                    feedback=feedback
                )["OUTPUT"]
            return fix_geoms(layer)

        try:
            budynki = ensure_epsg2180(select_layer("Wybierz warstwę z budynkami (BDOT10k)"))
            dzialki = ensure_epsg2180(select_layer("Wybierz warstwę z działkami (GML)"))
            powodz = ensure_epsg2180(select_layer("Wybierz warstwę z zagrożeniem powodzią")) if use_flood else None
            strefy = ensure_epsg2180(select_layer("Wybierz warstwę ze strefami planistycznymi")) if use_strefy else None
        except RuntimeError:
            self.report("Analiza przerwana na etapie wyboru warstw")
            return

        if use_flood:
            bud_touch = fix_geoms(processing.run(
                "native:extractbylocation",
                {"INPUT": budynki, "PREDICATE": [0, 1], "INTERSECT": powodz, "OUTPUT": "memory:"},
                feedback=feedback
            )["OUTPUT"])

            bud_flood = fix_geoms(processing.run(
                "native:intersection",
                {"INPUT": bud_touch, "OVERLAY": powodz, "OUTPUT": "memory:"},
                feedback=feedback
            )["OUTPUT"])

            bud_flood.startEditing()
            if bud_flood.fields().indexOf("flood_area") == -1:
                bud_flood.dataProvider().addAttributes([QgsField("flood_area", 6, "double")])
            bud_flood.updateFields()

            idx_fa = bud_flood.fields().indexOf("flood_area")
            fa_updates = {}
            for f in bud_flood.getFeatures():
                g = f.geometry()
                fa_updates[f.id()] = {idx_fa: g.area() if g and not g.isEmpty() else 0.0}
            bud_flood.dataProvider().changeAttributeValues(fa_updates)
            bud_flood.commitChanges()

            bud_flood_ok = fix_geoms(processing.run(
                "native:extractbyexpression",
                {"INPUT": bud_flood, "EXPRESSION": '"flood_area" >= 0.1', "OUTPUT": "memory:"},
                feedback=feedback
            )["OUTPUT"])

            dzialki_kwal = fix_geoms(processing.run(
                "native:extractbylocation",
                {"INPUT": dzialki, "PREDICATE": [0, 1], "INTERSECT": bud_flood_ok, "OUTPUT": "memory:"},
                feedback=feedback
            )["OUTPUT"])
        else:
            dzialki_kwal = dzialki

        bud_na_dzialkach = fix_geoms(processing.run(
            "native:extractbylocation",
            {"INPUT": budynki, "PREDICATE": [0, 1], "INTERSECT": dzialki_kwal, "OUTPUT": "memory:"},
            feedback=feedback
        )["OUTPUT"])

        split = fix_geoms(processing.run(
            "native:intersection",
            {"INPUT": bud_na_dzialkach, "OVERLAY": dzialki_kwal, "OUTPUT": "memory:"},
            feedback=feedback
        )["OUTPUT"])

        split.startEditing()
        if split.fields().indexOf("powbud") == -1:
            split.dataProvider().addAttributes([QgsField("powbud", 6, "double")])
        if split.fields().indexOf("powcalk") == -1:
            split.dataProvider().addAttributes([QgsField("powcalk", 6, "double")])
        split.updateFields()

        idx_pb = split.fields().indexOf("powbud")
        idx_pc = split.fields().indexOf("powcalk")
        idx_k = split.fields().indexOf("LICZBAKONDYGNACJI")

        updates = {}
        for f in split.getFeatures():
            g = f.geometry()
            a = g.area() if g and not g.isEmpty() else 0.0
            k = f[idx_k] or 0
            updates[f.id()] = {idx_pb: a, idx_pc: a * k}
        split.dataProvider().changeAttributeValues(updates)
        split.commitChanges()

        agg = {}
        for f in split.getFeatures():
            pid = f["id_dzialki"]
            agg.setdefault(pid, [0.0, 0.0])
            agg[pid][0] += f["powbud"] or 0.0
            agg[pid][1] += f["powcalk"] or 0.0

        dzialki_kwal.startEditing()
        needed = []
        if dzialki_kwal.fields().indexOf("powbud_sum") == -1:
            needed.append(QgsField("powbud_sum", 6, "double"))
        if dzialki_kwal.fields().indexOf("powcalk_sum") == -1:
            needed.append(QgsField("powcalk_sum", 6, "double"))
        if dzialki_kwal.fields().indexOf("powdzialki") == -1:
            needed.append(QgsField("powdzialki", 6, "double"))
        if dzialki_kwal.fields().indexOf("symbol") == -1:
            needed.append(QgsField("symbol", 10, "string"))
        if dzialki_kwal.fields().indexOf("oznaczenie") == -1:
            needed.append(QgsField("oznaczenie", 10, "string"))
        if needed:
            dzialki_kwal.dataProvider().addAttributes(needed)
        dzialki_kwal.updateFields()

        idx_pb_sum = dzialki_kwal.fields().indexOf("powbud_sum")
        idx_pc_sum = dzialki_kwal.fields().indexOf("powcalk_sum")
        idx_pd = dzialki_kwal.fields().indexOf("powdzialki")

        updates = {}
        for f in dzialki_kwal.getFeatures():
            pid = f["id_dzialki"]
            s = agg.get(pid, [0.0, 0.0])
            g = f.geometry()
            updates[f.id()] = {
                idx_pb_sum: s[0],
                idx_pc_sum: s[1],
                idx_pd: g.area() if g and not g.isEmpty() else 0.0
            }
        dzialki_kwal.dataProvider().changeAttributeValues(updates)
        dzialki_kwal.commitChanges()

        best = {}

        if use_strefy:
            dz_strefy = fix_geoms(processing.run(
                "native:intersection",
                {
                    "INPUT": split,
                    "OVERLAY": strefy,
                    "OVERLAY_FIELDS": ["symbol", "oznaczenie"],
                    "OVERLAY_PREFIX": "",
                    "OUTPUT": "memory:"
                },
                feedback=feedback
            )["OUTPUT"])

            dz_strefy.startEditing()
            if dz_strefy.fields().indexOf("overlap") == -1:
                dz_strefy.dataProvider().addAttributes([QgsField("overlap", 6, "double")])
            dz_strefy.updateFields()

            idx_ov = dz_strefy.fields().indexOf("overlap")
            updates = {}
            for f in dz_strefy.getFeatures():
                g = f.geometry()
                updates[f.id()] = {idx_ov: g.area() if g and not g.isEmpty() else 0.0}
            dz_strefy.dataProvider().changeAttributeValues(updates)
            dz_strefy.commitChanges()

            for f in dz_strefy.getFeatures():
                pid = f["id_dzialki"]
                area = f["overlap"] or 0.0
                sym = f["symbol"] or ""
                ozn = f["oznaczenie"] or ""
                if pid not in best or area > best[pid][0]:
                    best[pid] = (area, sym, ozn)

        dzialki_kwal.startEditing()
        idx_sym = dzialki_kwal.fields().indexOf("symbol")
        idx_ozn = dzialki_kwal.fields().indexOf("oznaczenie")

        updates = {}
        for f in dzialki_kwal.getFeatures():
            pid = f["id_dzialki"]
            if pid in best:
                updates[f.id()] = {idx_sym: best[pid][1], idx_ozn: best[pid][2]}
            else:
                updates[f.id()] = {idx_sym: "", idx_ozn: ""}
        dzialki_kwal.dataProvider().changeAttributeValues(updates)
        dzialki_kwal.commitChanges()

        final_layer = fix_geoms(processing.run(
            "native:refactorfields",
            {
                "INPUT": dzialki_kwal,
                "FIELDS_MAPPING": [
                    {"name": "powbud_sum", "type": 6, "length": 20, "precision": 2, "expression": '"powbud_sum"'},
                    {"name": "powcalk_sum", "type": 6, "length": 20, "precision": 2, "expression": '"powcalk_sum"'},
                    {"name": "powdzialki", "type": 6, "length": 20, "precision": 2, "expression": '"powdzialki"'},
                    {"name": "maxpowzab", "type": 6, "length": 10, "precision": 2,
                     "expression": 'CASE WHEN "powdzialki" > 0 THEN ceil(("powbud_sum" / "powdzialki") * 100) / 100 ELSE 0 END'},
                    {"name": "intensywnosc", "type": 6, "length": 10, "precision": 2,
                     "expression": 'CASE WHEN "powdzialki" > 0 THEN ceil(("powcalk_sum" / "powdzialki") * 100) / 100 ELSE 0 END'},
                    {"name": "symbol", "type": 10, "length": 50, "precision": 0, "expression": '"symbol"'},
                    {"name": "oznaczenie", "type": 10, "length": 50, "precision": 0, "expression": '"oznaczenie"'},
                    {"name": "NUMER_DZIALKI", "type": 10, "length": 50, "precision": 0, "expression": '"NUMER_DZIALKI"'},
                    {"name": "NAZWA_OBREBU", "type": 10, "length": 50, "precision": 0, "expression": '"NAZWA_OBREBU"'},
                    {"name": "maksUdzialPowierzchniZabudowy", "type": 6, "length": 0, "precision": 2,
                     "expression": 'CASE WHEN "powdzialki" > 0 THEN ceil(("powbud_sum" / "powdzialki") * 100) / 100 ELSE 0 END'},
                    {"name": "maksNadziemnaIntensywnoscZabudowy", "type": 6, "length": 0, "precision": 1,
                     "expression": 'CASE WHEN "powdzialki" > 0 AND ceil(("powcalk_sum" / "powdzialki") * 100) / 100 > 0.1 THEN ceil(("powcalk_sum" / "powdzialki") * 100) / 100 ELSE 0.1 END'},
                ],
                "OUTPUT": "memory:"
            },
            feedback=feedback
        )["OUTPUT"])

        final_layer = fix_geoms(processing.run(
            "native:extractbyexpression",
            {
                "INPUT": final_layer,
                "EXPRESSION": '"powbud_sum" > 0.1',
                "OUTPUT": "memory:"
            },
            feedback=feedback
        )["OUTPUT"])

        final_layer.setName(
            "Działki ze wskaźnikami (powódź)" if use_flood else "Działki ze wskaźnikami (bez powodzi)"
        )
        project.addMapLayer(final_layer)

        self.report("Analiza zakończona")

    def anal_pog_all_buildings(self):
        self.anal_pog_building_core(use_flood=False)

    def anal_pog_flood_buildings(self):
        self.anal_pog_building_core(use_flood=True)

    def load_pg_tree(self):
        user = self.le_pg_username.text()
        password = self.le_pg_password.text()
        host = "localhost"
        port = self.le_pg_port.text() or "5432"

        try:
            conn = psycopg2.connect(
                dbname="postgres",
                user=user,
                password=password,
                host=host,
                port=port
            )
            cur = conn.cursor()
            cur.execute("SELECT datname FROM pg_database WHERE datistemplate = false;")
            db_list = [row[0] for row in cur.fetchall()]
            cur.close()
            conn.close()
        except Exception as e:
            QMessageBox.critical(self, "Connection Error", str(e))
            return

        model = QStandardItemModel(self.tv_pg_load)
        model.setHorizontalHeaderLabels(["PostgreSQL"])

        for db_name in db_list:
            db_item = QStandardItem(db_name)
            db_item.setEditable(False)

            try:
                conn_db = psycopg2.connect(
                    dbname=db_name,
                    user=user,
                    password=password,
                    host=host,
                    port=port
                )
                cur_db = conn_db.cursor()
                cur_db.execute("""
                    SELECT schema_name
                    FROM information_schema.schemata
                    WHERE schema_name NOT IN ('pg_catalog','information_schema');
                """)
                schemas = [r[0] for r in cur_db.fetchall()]

                for schema in schemas:
                    schema_item = QStandardItem(schema)
                    schema_item.setEditable(False)

                    cur_db.execute("""
                        SELECT table_name
                        FROM information_schema.tables
                        WHERE table_schema = %s;
                    """, (schema,))
                    tables = [t[0] for t in cur_db.fetchall()]

                    for table in tables:
                        table_item = QStandardItem(table)
                        table_item.setEditable(False)
                        schema_item.appendRow(table_item)

                    db_item.appendRow(schema_item)

                cur_db.close()
                conn_db.close()

            except Exception as e:
                db_item.appendRow(QStandardItem(f"Error: {str(e)}"))

            model.appendRow(db_item)

        self.tv_pg_load.setModel(model)
        self.report("Przeładowano strukturę bazy danych")

    def pg_refresh(self, host='localhost', port='5432'):
        project = QgsProject.instance()
        root = project.layerTreeRoot()

        layers_to_replace = []
        for layer in project.mapLayers().values():
            if layer.type() != QgsVectorLayer.VectorLayer:
                continue
            if layer.dataProvider().name().lower() != 'postgres':
                continue
            layers_to_replace.append(layer)

        for old_layer in layers_to_replace:

            old_uri = QgsDataSourceUri(old_layer.dataProvider().dataSourceUri())

            dbname = str(old_uri.database() or '')
            username = str(self.le_pg_username.text() or '')
            password = str(self.le_pg_password.text() or '')
            host_str = str(host or 'localhost')
            port_str = str(port or '5432')
            sslmode = QgsDataSourceUri.SslPrefer
            auth_config = ''

            new_uri = QgsDataSourceUri()
            new_uri.setConnection(
                host_str,
                port_str,
                dbname,
                username,
                password,
                sslmode,
                auth_config
            )

            new_uri.setDataSource(
                old_uri.schema(),
                old_uri.table(),
                old_uri.geometryColumn(),
                old_uri.sql(),
                old_uri.keyColumn()
            )

            new_layer = QgsVectorLayer(new_uri.uri(), old_layer.name(), 'postgres')
            if not new_layer.isValid():
                self.report(f"Failed to reload layer: {old_layer.name()}")
                continue

            new_layer.setRenderer(old_layer.renderer().clone())
            new_layer.setSubsetString(old_layer.subsetString())
            new_layer.setCrs(old_layer.crs())

            if old_layer.labelsEnabled():
                new_layer.setLabeling(old_layer.labeling().clone())
                new_layer.setLabelsEnabled(True)

            for join in old_layer.vectorJoins():
                new_layer.addJoin(join.clone())

            for action in old_layer.actions().actions():
                new_layer.addAction(action.clone())

            project.addMapLayer(new_layer, False)

            old_node = root.findLayer(old_layer.id())
            if old_node:
                parent = old_node.parent()
                index = parent.children().index(old_node)
                parent.insertChildNode(index, QgsLayerTreeLayer(new_layer))
                project.removeMapLayer(old_layer.id())
            else:
                project.removeMapLayer(old_layer.id())
                project.addMapLayer(new_layer)

            self.report(f"Odświeżono źródło warstwy: {new_layer.name()}")

    def pg_import(self):
        idx = self.tv_pg_import.currentIndex()
        if not idx.isValid():
            self.report("Nie wybrano pliku.")
            return

        path = self.fs_model.filePath(idx)

        if not path.lower().endswith(".shp"):
            base = os.path.splitext(path)[0]
            shp = base + ".shp"
            if not os.path.exists(shp):
                self.report("Wybrany plik nie jest warstwą SHP.")
                return
            path = shp

        root = os.path.join(self.resource_path.filePath(), "DANE_MAPY_ZASADNICZE")
        try:
            rel = os.path.relpath(path, root)
            db_name, schema_name, fname = rel.split(os.sep)
            raw_table = os.path.splitext(fname)[0]
        except Exception:
            self.report("Błędna struktura katalogów.")
            return

        table_name = re.sub(r"[^a-zA-Z0-9_]", "_", raw_table).lower()[:60]
        if table_name != raw_table:
            self.report(f"Zmieniono nazwę tabeli: {raw_table} → {table_name}")

        user = self.le_pg_username.text()
        password = self.le_pg_password.text()
        port = self.le_pg_port.text()

        try:
            conn = psycopg2.connect(
                host="localhost",
                port=port,
                user=user,
                password=password,
                dbname="postgres"
            )
            conn.autocommit = True
            cur = conn.cursor()

            cur.execute("SELECT 1 FROM pg_database WHERE datname = %s", (db_name,))
            if cur.fetchone():
                self.report(f"Baza istnieje: {db_name}")
            else:
                cur.execute(f'CREATE DATABASE "{db_name}"')
                self.report(f"Utworzono bazę: {db_name}")

            cur.close()
            conn.close()
        except Exception as e:
            self.report(str(e))
            return

        try:
            conn = psycopg2.connect(
                host="localhost",
                port=port,
                user=user,
                password=password,
                dbname=db_name
            )
            conn.autocommit = True
            cur = conn.cursor()

            cur.execute("CREATE EXTENSION IF NOT EXISTS postgis")
            self.report("PostGIS włączony")

            cur.execute(
                "SELECT 1 FROM information_schema.schemata WHERE schema_name = %s",
                (schema_name,)
            )
            if cur.fetchone():
                self.report(f"Schemat istnieje: {schema_name}")
            else:
                cur.execute(f'CREATE SCHEMA "{schema_name}"')
                self.report(f"Utworzono schemat: {schema_name}")

            cur.execute(
                """
                SELECT 1 FROM information_schema.tables
                WHERE table_schema = %s AND table_name = %s
                """,
                (schema_name, table_name)
            )
            if cur.fetchone():
                self.report(f"Pominięto import – tabela istnieje: {schema_name}.{table_name}")
                cur.close()
                conn.close()
                return

            cur.close()
            conn.close()
        except Exception as e:
            self.report(str(e))
            return

        layer = QgsVectorLayer(path, table_name, "ogr")
        if not layer.isValid():
            self.report("Nie można wczytać warstwy SHP.")
            return

        uri = QgsDataSourceUri()
        uri.setConnection("localhost", port, db_name, user, password)
        uri.setDataSource(schema_name, table_name, "geom")

        res = QgsVectorLayerExporter.exportLayer(
            layer,
            uri.uri(),
            "postgres",
            layer.crs(),
            False,
            {"schema": schema_name, "table": table_name, "overwrite": False, "createSpatialIndex": True}
        )

        if res[0] != QgsVectorLayerExporter.NoError:
            self.report(res[1])
            return

        self.report(f"Zaimportowano: {db_name}.{schema_name}.{table_name}")

    def pg_load(self):
        idx = self.tv_pg_load.currentIndex()
        if not idx.isValid():
            self.report("Nie wybrano warstwy.")
            return

        model = self.tv_pg_load.model()
        item = model.itemFromIndex(idx)

        parent_schema = item.parent()
        if parent_schema is None:
            self.report("Wybierz tabelę.")
            return

        parent_db = parent_schema.parent()
        if parent_db is None:
            self.report("Wybierz tabelę.")
            return

        table_name = item.text()
        schema_name = parent_schema.text()
        db_name = parent_db.text()

        user = self.le_pg_username.text()
        password = self.le_pg_password.text()
        port = self.le_pg_port.text() or "5432"

        uri = QgsDataSourceUri()
        uri.setConnection("localhost", port, db_name, user, password)
        uri.setDataSource(schema_name, table_name, "geom")

        crs = self.crs_pg_load_widget.crs()
        if crs.isValid():
            layer = QgsVectorLayer(uri.uri(), table_name, "postgres")
            layer.setCrs(crs)
        else:
            layer = QgsVectorLayer(uri.uri(), table_name, "postgres")

        if not layer.isValid():
            self.report("Nie udało się wczytać warstwy z PostGIS.")
            return

        QgsProject.instance().addMapLayer(layer)
        self.report(f"Wczytano warstwę: {db_name}.{schema_name}.{table_name}")

        qml_dir = os.path.join(
            self.resource_path.filePath(),
            "DANE_MAPY_ZASADNICZE",
            db_name,
            schema_name
        )

        matched_qml = None
        for fname in os.listdir(qml_dir):
            if not fname.lower().endswith(".qml"):
                continue
            base = os.path.splitext(fname)[0]
            sanitized = re.sub(r"[^a-zA-Z0-9_]", "_", base).lower()[:60]
            if sanitized == table_name:
                matched_qml = os.path.join(qml_dir, fname)
                break

        if matched_qml and os.path.exists(matched_qml):
            layer.loadNamedStyle(matched_qml)
            layer.triggerRepaint()
            self.report(f"Zastosowano styl: {os.path.basename(matched_qml)}")
        else:
            self.report("Nie znaleziono pasującego pliku QML.")

    def pg_delete(self):
        idx = self.tv_pg_load.currentIndex()
        if not idx.isValid():
            self.report("Nie wybrano warstwy.")
            return

        model = self.tv_pg_load.model()
        item = model.itemFromIndex(idx)

        parent_schema = item.parent()
        if parent_schema is None:
            self.report("Wybierz tabelę.")
            return

        parent_db = parent_schema.parent()
        if parent_db is None:
            self.report("Wybierz tabelę.")
            return

        table_name = item.text()
        schema_name = parent_schema.text()
        db_name = parent_db.text()

        confirm = QMessageBox.question(
            self,
            "Potwierdź usunięcie",
            f"Czy na pewno chcesz usunąć tabelę {db_name}.{schema_name}.{table_name} z bazy?",
            QMessageBox.Yes | QMessageBox.No
        )

        if confirm != QMessageBox.Yes:
            self.report("Usuwanie anulowane.")
            return

        user = self.le_pg_username.text()
        password = self.le_pg_password.text()
        port = self.le_pg_port.text() or "5432"
        host = "localhost"

        try:
            import psycopg2
            conn = psycopg2.connect(
                host=host,
                port=port,
                dbname=db_name,
                user=user,
                password=password
            )
            conn.autocommit = True
            cur = conn.cursor()
            cur.execute(f'DROP TABLE IF EXISTS "{schema_name}"."{table_name}" CASCADE;')
            cur.close()
            conn.close()
            self.report(f"Tabela {db_name}.{schema_name}.{table_name} została usunięta.")
        except Exception as e:
            self.report(f"Błąd przy usuwaniu tabeli: {str(e)}")
        self.load_pg_tree()

    def pg_split(self):
        import tempfile

        layer = iface.activeLayer()
        if not layer:
            self.report("Brak aktywnej warstwy.")
            return

        if not isinstance(layer, QgsVectorLayer):
            self.report("Aktywna warstwa nie jest wektorowa.")
            return

        if layer.dataProvider().name().lower() != "postgres":
            self.report("Warstwa nie pochodzi z bazy Postgres.")
            return

        field_name = "Layer"
        if field_name not in [f.name() for f in layer.fields()]:
            self.report(f"Kolumna '{field_name}' nie istnieje w warstwie.")
            return

        base_layer_name = layer.name()
        group = QgsProject.instance().layerTreeRoot().addGroup(base_layer_name)

        uri = QgsDataSourceUri(layer.source())
        schema = uri.schema()
        table = uri.table()
        geom_col = uri.geometryColumn()
        db_name = uri.database()
        host = uri.host()
        port = uri.port()
        user = uri.username()
        password = uri.password()

        try:
            import psycopg2
            conn = psycopg2.connect(
                host=host,
                port=port,
                dbname=db_name,
                user=user,
                password=password
            )
            cur = conn.cursor()
            cur.execute(f'SELECT DISTINCT "{field_name}" FROM "{schema}"."{table}";')
            unique_values = [row[0] for row in cur.fetchall()]
            cur.close()
            conn.close()
        except Exception as e:
            self.report(f"Błąd przy pobieraniu unikalnych wartości: {str(e)}")
            return

        self.report(f"Rozpoczynam dzielenie warstwy '{base_layer_name}' na {len(unique_values)} podwarstw...")

        tmp_qml = tempfile.NamedTemporaryFile(suffix=".qml", delete=False).name
        layer.saveNamedStyle(tmp_qml)

        for val in unique_values:
            val_str = str(val).replace("'", "''")
            sql_filter = f'"{field_name}" = \'{val_str}\''
            filtered_layer_name = str(val)

            uri.setDataSource(schema, table, geom_col, sql_filter)
            split_layer = QgsVectorLayer(uri.uri(), filtered_layer_name, "postgres")
            if split_layer.isValid():
                split_layer.setCrs(layer.crs())
                split_layer.loadNamedStyle(tmp_qml)
                split_layer.triggerRepaint()

                QgsProject.instance().addMapLayer(split_layer, False)
                group.addLayer(split_layer)
                self.report(f"Utworzono warstwę: {filtered_layer_name}")
            else:
                self.report(f"Nie udało się utworzyć warstwy dla: {filtered_layer_name}")

        self.report(f"Zakończono dzielenie warstwy '{base_layer_name}'.")

    def pg_pound_replace(self):
        layer = iface.activeLayer()
        if not layer:
            self.report("Brak aktywnej warstwy.")
            return

        if not isinstance(layer, QgsVectorLayer):
            self.report("Aktywna warstwa nie jest wektorowa.")
            return

        if layer.dataProvider().name().lower() != "postgres":
            self.report("Warstwa nie pochodzi z bazy Postgres.")
            return

        field_name = "Text"
        if field_name not in [f.name() for f in layer.fields()]:
            self.report(f"Kolumna '{field_name}' nie istnieje w warstwie.")
            return

        uri = QgsDataSourceUri(layer.source())
        schema = uri.schema()
        table = uri.table()
        db_name = uri.database()
        host = uri.host()
        port = uri.port()
        user = uri.username()
        password = uri.password()

        try:
            import psycopg2
            conn = psycopg2.connect(
                host=host,
                port=port,
                dbname=db_name,
                user=user,
                password=password
            )
            conn.autocommit = True
            cur = conn.cursor()
            cur.execute(f"""
                UPDATE "{schema}"."{table}"
                SET "{field_name}" = REPLACE("{field_name}", '£', 'Ł')
                WHERE "{field_name}" LIKE '%£%';
            """)
            affected = cur.rowcount
            cur.close()
            conn.close()
            self.report(f"Zaktualizowano {affected} rekordów w kolumnie '{field_name}'.")
        except Exception as e:
            self.report(f"Błąd przy aktualizacji kolumny '{field_name}': {str(e)}")

    def update_style_filter(self, layer):
        if not layer:
            self.style_model.setNameFilters(["__nothing__"])
            self.tv_style.setRootIndex(self.style_model.index(self.style_root_path))
            self.pb_style_layer.setEnabled(False)
            return

        g = layer.geometryType()
        if g == QgsWkbTypes.PointGeometry:
            filters = ["*_point.qml"]
        elif g == QgsWkbTypes.LineGeometry:
            filters = ["*_line.qml"]
        elif g == QgsWkbTypes.PolygonGeometry:
            filters = ["*_polygon.qml"]
        else:
            filters = ["__nothing__"]

        self.style_model.setNameFilters(filters)
        self.tv_style.setRootIndex(self.style_model.index(self.style_root_path))
        self.pb_style_layer.setEnabled(False)

    def update_style_button(self):
        indexes = self.tv_style.selectionModel().selectedIndexes()
        if not indexes:
            self.pb_style_layer.setEnabled(False)
            return

        index = indexes[0]
        path = self.style_model.filePath(index)
        self.pb_style_layer.setEnabled(path.lower().endswith(".qml"))

    def apply_style_to_layer(self):
        layer = self.cb_style_layer.currentLayer()
        if layer is None:
            self.report("Nie wybrano warstwy do wczytania stylu.")
            return

        indexes = self.tv_style.selectionModel().selectedIndexes()
        if not indexes:
            self.report(f"Nie wybrano stylu do wczytania.")
            return

        index = indexes[0]
        path = self.style_model.filePath(index)
        if not path.lower().endswith(".qml"):
            self.report(f"Wybrany plik nie jest stylem .qml: '{path}'.")
            return

        mgr = layer.styleManager()
        current_name = mgr.currentStyle()
        backup_name = f"_backup_{layer.id()}_{current_name}"
        if backup_name in mgr.styles():
            mgr.removeStyle(backup_name)
        mgr.addStyleFromLayer(backup_name)
        self._previous_layer_styles[layer.id()] = backup_name

        layer.loadNamedStyle(path)
        layer.triggerRepaint()

        style_name = path.split("/")[-1] if "/" in path else path.split("\\")[-1]
        self.report(f"Wczytano styl '{style_name}' dla warstwy -> '{layer.name()}'.")

    def apply_previous_style_to_layer(self):
        layer = self.cb_style_layer.currentLayer()
        if layer is None:
            self.report("Nie wybrano warstwy do wczytania ostatnio zmienionego stylu.")
            return

        backup_name = self._previous_layer_styles.get(layer.id())
        if not backup_name:
            self.report(f"Nie zapisano poprzedniego stylu dla warstwy '{layer.name()}'.")
            return
        mgr: QgsMapLayerStyleManager = layer.styleManager()
        if backup_name not in mgr.styles():
            self.report(f"Nie znaleziono zapisanego poprzedniego stylu '{backup_name}' w warstwie '{layer.name()}'.")
            return

        mgr.setCurrentStyle(backup_name)
        layer.triggerRepaint()
        self.report(f"Wczytano ostatnio zmieniony styl dla warstwy '{layer.name()}'.")

    def export_active_layer_style(self):
        layer = self.iface.activeLayer()
        if layer is None:
            self.report("Nie wybrano aktywnej warstwy.")
            return

        if not isinstance(layer, QgsVectorLayer):
            self.report(f"Aktywna warstwa '{layer.name()}' nie jest warstwą wektorową.")
            return

        g = layer.geometryType()
        if g == QgsWkbTypes.PointGeometry:
            suffix = "_point.qml"
        elif g == QgsWkbTypes.LineGeometry:
            suffix = "_line.qml"
        elif g == QgsWkbTypes.PolygonGeometry:
            suffix = "_polygon.qml"
        else:
            self.report(f"Nieobsługiwany typ geometrii dla warstwy '{layer.name()}'.")
            return

        base_name = self.le_export_active_layer_style.text().strip()
        if not base_name:
            self.report("Nie podano nazwy dla eksportu stylu.")
            return

        file_name = f"{base_name}{suffix}"
        export_path = os.path.join(self.style_root_path, file_name)

        success, error_message = layer.saveNamedStyle(export_path)
        if success:
            self.report(f"Styl warstwy '{layer.name()}' został wyeksportowany jako '{file_name}'.")
            self.tv_style.setRootIndex(self.style_model.index(self.style_root_path))
        else:
            self.report(f"Błąd podczas eksportu stylu: {error_message}")

    def style_save_single(self):
        self.progressBar.reset()
        self.progressBar.setValue(0)
        self.report("Rozpoczynam zapisywanie stylu aktywnej warstwy...")

        layer = self.iface.activeLayer()

        if not layer:
            self.report("Brak aktywnej warstwy. Operacja przerwana.")
            self.progressBar.setValue(0)
            return

        if layer.type() != QgsMapLayerType.VectorLayer:
            self.report(f"Warstwa '{layer.name()}' nie jest warstwą wektorową.")
            self.progressBar.setValue(0)
            return

        if not layer.source().lower().endswith(".gpkg"):
            self.report(f"Warstwa '{layer.name()}' nie pochodzi z GeoPackage. Pomijam.")
            self.progressBar.setValue(0)
            return

        layer_name = layer.name()

        try:
            layer.saveStyleToDatabase(
                layer_name,
                "",
                True,
                "",
                QgsMapLayer.AllStyleCategories
            )

            layer.triggerRepaint()
            self.progressBar.setValue(100)
            self.report(f"Zapisano styl warstwy '{layer_name}'.")

        except Exception as e:
            self.report(f"Błąd podczas zapisywania stylu: {str(e)}")
            self.progressBar.setValue(0)

    def style_save_all(self):
        reply = QMessageBox.question(
            self,
            "Potwierdzenie",
            "Czy na pewno chcesz zapisać style dla wszystkich warstw wektorowych z GeoPackage?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply != QMessageBox.Yes:
            self.report("Operacja anulowana.")
            return

        self.report("Rozpoczynam zapisywanie stylów dla wszystkich warstw z GeoPackage...")
        self.progressBar.reset()
        self.progressBar.setValue(0)

        project = QgsProject.instance()
        vector_layers = [
            layer for layer in project.mapLayers().values()
            if layer.type() == QgsMapLayerType.VectorLayer and layer.source().lower().endswith(".gpkg")
        ]

        layer_count_total = len(vector_layers)

        if layer_count_total == 0:
            self.report("Brak warstw wektorowych z GeoPackage w projekcie — nic do zapisania.")
            return

        self.report(f"Liczba warstw do zapisania: {layer_count_total}")

        self.progressBar.setMaximum(100)
        processed = 0

        for layer in vector_layers:
            layer_name = layer.name()

            try:
                layer.saveStyleToDatabase(
                    layer_name,
                    "",
                    True,
                    "",
                    QgsMapLayer.AllStyleCategories
                )

                layer.triggerRepaint()
                processed += 1

                progress = int((processed / layer_count_total) * 100)
                self.progressBar.setValue(progress)

                self.report(
                    f"[{processed}/{layer_count_total}] Zapisano styl dla: {layer_name}"
                )

            except Exception as e:
                self.report(f"Błąd przy zapisywaniu stylu warstwy '{layer_name}': {str(e)}")

        self.report("Zakończono zapisywanie stylów dla wszystkich warstw z GeoPackage.")
        self.progressBar.setValue(100)

    def report_crs(self):
        project = QgsProject.instance()

        for layer in project.mapLayers().values():
            crs = layer.crs()
            
            layer_name = layer.name()
            authid = crs.authid() if crs.isValid() else "Brak CRS"
            description = crs.description() if crs.isValid() else "Nieznany CRS"

            self.report(f"Warstwa: {layer_name}")
            self.report(f"  CRS ID: {authid}")
            self.report(f"  CRS Opis: {description}")
            self.report("-" * 15)        

    def report_encoding(self):
        project = QgsProject.instance()
        for layer in project.mapLayers().values():
            if isinstance(layer, QgsVectorLayer):
                layer_name = layer.name()
                encoding = layer.dataProvider().encoding()
                self.report(f"Nazwa warstwy: {layer_name}")
                self.report(f" Kodowanie: {encoding}")
                self.report("-" * 15)        

    def upgrade_plugin(self, *args):
        try:
            resource_path = Path(self.resource_path.filePath())
            source_folder = resource_path.parent / "WTYCZKI" / "bober_os"
            if not source_folder.exists():
                QMessageBox.critical(
                    iface.mainWindow(),
                    "Upgrade Error",
                    f"Source folder not found:\n{str(source_folder)}",
                    buttons=QMessageBox.Ok
                )
                return

            target_plugin_dir = Path(__file__).resolve().parent

            FO_COPY = 0x0002

            class SHFILEOPSTRUCT(ctypes.Structure):
                _fields_ = [
                    ("hwnd", wintypes.HWND),
                    ("wFunc", ctypes.c_uint),
                    ("pFrom", wintypes.LPCWSTR),
                    ("pTo", wintypes.LPCWSTR),
                    ("fFlags", ctypes.c_uint),
                    ("fAnyOperationsAborted", wintypes.BOOL),
                    ("hNameMappings", ctypes.c_void_p),
                    ("lpszProgressTitle", wintypes.LPCWSTR),
                ]

            src = str(source_folder) + "\0"
            dst = str(target_plugin_dir.parent) + "\0"

            op = SHFILEOPSTRUCT()
            op.hwnd = 0
            op.wFunc = FO_COPY
            op.pFrom = src
            op.pTo = dst
            op.fFlags = 0
            ctypes.windll.shell32.SHFileOperationW(ctypes.byref(op))


            QMessageBox.information(
                iface.mainWindow(),
                "Pliki wtyczki zostały nadpisane.\n",
                "Użyj wtyczki plugin reloader w celu przeładowania wtyczki.",
                buttons=QMessageBox.Ok
            )

        except Exception as e:
            iface.messageBar().pushMessage(
                "BŁĄD PYTONA XD", str(e), level=3
            )
            QMessageBox.critical(
                iface.mainWindow(),
                "BŁĄD PYTONA XD",
                f"Nie udało się skopiować folderu:\n{str(e)}"
            )

    def report_unique_layer_sources(self):
        unique_sources = set()
        self.report("Rozpoczynam raport unikalnych źródeł dla warstw w projekcie...")
        for layer in QgsProject.instance().mapLayers().values():
            if layer.type() != QgsMapLayer.VectorLayer:
                continue
            provider = layer.providerType().lower()
            if provider in ["wms", "wfs", "wmts", "xyz"]:
                continue
            source = layer.source()
            if not source:
                continue
            if provider in ["ogr", "spatialite"]:
                source = source.split("|")[0]
            unique_sources.add(source)
        if unique_sources:
            self.report("Unikalne źródła dla warstw w projekcie:")
            for src in unique_sources:
                self.report(src)
                self.report("-" * 15)
        else:
            self.report("Brak warstw wektorowych w projekcie.")
            
    def pog_to_xslx(self):
        layer = iface.activeLayer()
        if not layer:
            self.report("Nie wybrano poprawnej warstwy ze strefą planistyczną lub OUZ - brak kolumny \"symbol\".")
            return
        field_names = [f.name() for f in layer.fields()]
        if "symbol" not in field_names:
            self.report("Nie wybrano poprawnej warstwy ze strefą planistyczną lub OUZ - brak kolumny \"symbol\".")
            return
        path, _ = QFileDialog.getSaveFileName(None, "Zapisz plik XLSX", "", "Excel (*.xlsx)")
        if not path:
            return
        if not path.lower().endswith(".xlsx"):
            path += ".xlsx"
        wanted = [
            "oznaczenie",
            "symbol",
            "profilDodatkowy",
            "maksNadziemnaIntensywnoscZabudowy",
            "maksUdzialPowierzchniZabudowy",
            "maksWysokoscZabudowy",
            "minUdzialPowierzchniBiologicznieCzynnej"
        ]
        existing = [f for f in wanted if f in field_names]
        unique_symbols = set()
        for f in layer.getFeatures():
            unique_symbols.add(str(f["symbol"]))
        temp_layers = []
        for sym in sorted(unique_symbols):
            extract = processing.run(
                "native:extractbyexpression",
                {
                    "INPUT": layer,
                    "EXPRESSION": "\"symbol\" = '{}'".format(str(sym).replace("'", "''")),
                    "OUTPUT": "TEMPORARY_OUTPUT"
                }
            )["OUTPUT"]
            mapping = []
            for name in existing:
                fld = extract.fields().field(name)
                mapping.append({
                    "name": name,
                    "type": fld.type(),
                    "length": fld.length(),
                    "precision": fld.precision(),
                    "expression": f"\"{name}\""
                })
            refactored = processing.run(
                "native:refactorfields",
                {
                    "INPUT": extract,
                    "FIELDS_MAPPING": mapping,
                    "OUTPUT": "TEMPORARY_OUTPUT"
                }
            )["OUTPUT"]
            sorted_layer = processing.run(
                "native:orderbyexpression",
                {
                    "INPUT": refactored,
                    "EXPRESSION": "to_int(regexp_replace(\"oznaczenie\",'[^0-9]',''))",
                    "ASCENDING": True,
                    "NULLS_FIRST": False,
                    "OUTPUT": "TEMPORARY_OUTPUT"
                }
            )["OUTPUT"]
            sorted_layer.setName(str(sym))
            temp_layers.append(sorted_layer)
        processing.run(
            "native:exporttospreadsheet",
            {
                "LAYERS": temp_layers,
                "USE_ALIAS": False,
                "FORMATTED_VALUES": False,
                "OVERWRITE": True,
                "OUTPUT": path
            }
        )
        if sys.platform.startswith('win'):
            subprocess.Popen(['explorer', '/select,', os.path.normpath(path)])
        else:
            from PyQt5.QtGui import QDesktopServices
            from PyQt5.QtCore import QUrl
            QDesktopServices.openUrl(QUrl.fromLocalFile(os.path.dirname(path)))
        self.report(f"Zapisano arkusz do: {path}")



# xD